<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[设计模式之适配器模式和外观模式]]></title>
      <url>%2F2016%2F12%2F08%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[工厂也来了小明公司的项目越来越多，一家做污水处理的工厂也找上门了，这家污水处理厂最近和一家新的工厂签约了，这家新签约排放污水的工厂之前是和另一个污水处理厂合作，但是之前那家倒闭了，找到了他们，但是他们遇到了一个问题，排放污水的工厂不想改变他们之前排放污水的方式，但是现在这家污水处理厂接收污水的方式又和之前的污水处理厂的接收污水的方式完全不同，所以找到小明他们公司，希望能帮助解决。 这是排放污水工厂之前的方式，排放类： public interface Discharge{ public void oldDischargeSewage(); } 排放实现类： public class OldFactoryDischarge implements Discharge{ // 省略其他细节 public void oldDischargeSewage(){ // 具体的实现 } } 污水排放工厂： public class SewageFactory{ // 用排放类排放 pubclic void discharge(Discharge discharge){ discharge.oldDischargeSewage(); } } 排放： Discharge discharge = new OldFactoryDischarge(); // 工厂不想变动使用排放的方式 SewageFactory sewageFactory = new SewageFactory(); sewageFactory.discharge(discharge); 而新的污水处理厂接收污水并处理的是这样的： public class NewFactoryDischarge { // 省略其他细节 public void newDischargeSewage(){ // 接收污水的实现 } } 小明和主管一起开会讨论，主管说是该适配器登场的时候了。小的主管只让小明新加了一个类： public class FactoryDischargeAdapter implements Discharge{ NewFactoryDischarge newFactoryDischarge; public NewFactoryDischarge(NewFactoryDischarge newFactoryDischarge){ this.newFactoryDischarge = newFactoryDischarge; } public void oldDischargeSewage(){ newFactoryDischarge.newDischargeSewage(); } } 然后新的排放方式就成这样了： Discharge discharge = new FactoryDischargeAdapter(new NewFactoryDischarge()); // 工厂不想变动使用排放的方式和之前没有任何变化 SewageFactory sewageFactory = new SewageFactory(); sewageFactory.discharge(discharge); 小明很快就清楚了这就是适配器模式，接口使用者，在这里也就是污水排放的工厂不想改变旧的排放方式，但接收方又和之前的方式不一样，这样就引进了适配器类，它的作用就是完全的避免使用接口的客户端和实现接口的另一端的耦合。小明的主管又说了，小明，刚才我们使用的这种方式，严格的说它应该叫对象适配器模式，还有另外一种适配器模式，它叫类适配器，你知道该怎么做吗？小明思考了一会，从名字领悟到了这两种方式的区别，然后很快的实现了它： public class FactoryDischargeAdapter extends NewFactoryDischarge implements Discharge{ public void newDischargeSewage(){ // 接收污水的实现 } public void oldDischargeSewage(){ newDischargeSewage(); } } 排放污水： Discharge discharge = new FactoryDischargeAdapter(); // 工厂不想变动使用排放的方式和之前没有任何变化 SewageFactory sewageFactory = new SewageFactory(); sewageFactory.discharge(discharge); 的确，从名字就可以读出，对象适配器是通过适配器和新的需要适配的类组合实现适配，而类的方式没有组合，通过直接继承需要适配的类实现适配，两者用法不同，但是都达到了同样的效果。两种应该在不同的场景下被选择，比如对象的适配器比较适配那些变化不大的，不会有更新扩展的的类，因为一旦对象变化了，需要修改适配器本身去适应新的变化。而类的适配器更适合适配单一的需要适配的类，因为如果适配器中牵扯到多个类时，类的适配方式就不那么灵活了，所以我们应该因材施教。 适配器定义将一个类的接口，装换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。 对象适配器： 类适配器： 说一说适配器模式和装饰者模式回想一下装饰者模式，好像和适配器非常相似，那么两者有什么区别呢？其实他们的区别从定义就可以总结出来：装饰者会对装饰的组件增加新的责任，也就是功能，但是适配器没有给适配对象增加的责任，而只是让它满足客户的需求，好比有一个中间人，联络着客户和适配方。 标题中的另一种模式文章的标题还提到了另一种模式：外观模式，为什么这次是两个模式一起来讲呢？因为外观模式和适配器模式非常相似，甚至有人任务两种模式是同一种模式，其实不然，外观模式和适配器模式用法是不一样的，也就是他们有各自的用途，我们已经知道适配器模式的用途，那么接下来看看外观模式的用途。 极客小明小明是一名极客，特别喜欢把各种东西攒在一起，这不，他为了给家里营造更好的观影感受，买了一大堆电子产品，有投影仪、自动屏幕、音响、DVD，甚至还有一个爆米花机。但是每次观影时的他是这样的： 打开投影仪 接通自动屏幕 打开调试音响音量 打开DVD放入碟片 将玉米放入爆米花机…… 实在太繁琐了！小明不想做这一切，如果他只需要按一下遥控器，其他的这些动作都不用他去一个一个完成该多好，这时候，外观模式就派上用场了！外观模式是干什么的呢，他就是向外部提供一个接口，然后内部去完成一些复杂的、多步骤的、使用其他很多对象动作的功能。而对于外观的使用者来说，只需要调用一个动作即可，这就是外观模式。所以，小明去国外买了一个机器人，然后让机器人学会了他之前做的上述一切事情，每次小明回家就只对机器人说：我要看电影！然后只需要美美的坐在沙发上稍加等待，就可以开始观看优美的电影了。 以前的小明： openProjector(); openSceen(); openSound(); openDVD(); …… // 观影结束后还要关闭它们（省略）…… 现在的小明： Robot robot = new Robot(); robot.open(); // 观影结束 robot.off(); 我们看到，对于小明来说，之前需要做很多事，现在只需要做很简单的动作就可以了，这就是外观模式给使用者带来的好处。 外观模式的定义提供一个统一的接口，用来访问子系统中的一群接口。外观模式定义了一个高层接口，让子系统更容易使用。 外观模式完美体现了最少知道原则 那么通过对外观模式和适配器模式的深入了解，我们也能很清楚的知道他们之间的不同点了：外观模式是为了让接口更简单，而适配器是为了适配客户的接口。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之命令模式]]></title>
      <url>%2F2016%2F12%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[披萨店的生意越来越好小明公司之前给披萨店做了一个项目，主要用了工厂模式，披萨店的老板非常满意，这不，由于披萨店的生意越来越好，小明他们公司又接到了披萨店的新需求。 披萨店招了一名服务员，专门负责顾客的下单，主要职责就是将顾客点的菜单交给做披萨的师傅，然后师傅将披萨做好。现在需要有一套程序来模拟这个场景，小明这次很开心，因为他知道这种就是一个很明确的命令模式的场景：对于顾客来说，每个人点的披萨是不一样的，他们并不关心厨师做披萨的过程，而主要在意是自己的需求能够明确到厨师那里。而服务员主要做的就是将顾客的想法传单到厨师那里，然后一个简单的命令模式就出现了： 芝士披萨厨师： public class CheesePizzaChef { public void createCheesePizza(){ // 做一个芝士披萨 } } 榴莲披萨厨师： public class DurianPizzaChef { public void createDurianPizza(){ // 做一个榴莲披萨 } public void sendGift(){ // 送一个礼物 } } 抽象命令： public interface Order { public void execute(); } 点一个芝士披萨： public class CheesePizzaOrder implements Order{ CheesePizzaChef chef; public CheesePizzaOrder(CheesePizzaChef chef){ this.chef = chef; } public void execute(){ chef.createCheesePizza(); } } 点一个榴莲披萨： public class DurianPizzaOrder implements Order{ DurianPizzaChef chef; public DurianPizzaOrder(DurianPizzaChef chef){ this.chef = chef; } public void execute(){ chef.createDurianPizza(); chef.sendGift(); } } 服务员： public class Service { Order order; public Service(){ } public void setOrder(Order order){ this.order = order; } public void orderUp(){ order.execute(); } } 顾客： public class Customer { public static void main(String[] args){ Service sevice = new Service(); //点一个芝士披萨 CheesePizzaChef cheesePizzaChef = new CheesePizzaChef(); CheesePizzaOrder cheesePizzaOrder = new CheesePizzaOrder(cheesePizzaChef); service.setOrder(cheesePizzaOrder); service.orderUp(); //又点了一个榴莲披萨 DurianPizzaChef durianPizzaChef = new DurianPizzaChef(); DurianPizzaOrder durianPizzaOrder = new DurianPizzaOrder(durianPizzaChef); service.setOrder(durianPizzaChef); service.orderUp(); } } 顾客先点了一个芝士披萨，又点了一个榴莲披萨，可以看到，对于顾客而言，他只用了服务员做了点餐（setOrder()方法），而服务员和厨师之前也没有过多的耦合，服务员就只是再执行了orderUp()方法，然后接下来的的事顾客和服务员就再也没有关心了，那么可以看到里面有很重要的一个类就是实现Order接口的两个类：CheesePizzaOrder和DurianPizzaOrder，他们就被称为命令，命令里面包含了真正的接收者，对于这两个命令，他们的接收者分别是CheesePizzaChef和DurianPizzaChef，也就是最终做事的对象，服务员每次都设置了不同的命令，然后在orderUp()方法了调用命令的execute()方法，命令实现类对execute()做了不同实现，在CheesePizzaOrder里面是调用CheesePizzaChef做了一个芝士披萨，DurianPizzaOrder是DurianPizzaChef做了一个榴莲披萨，而且还送了一个礼物。我们注意到，在两个Order的实现类里，execute()方法用不同的类做了不同的事情，这也是我们命令模式很重要的一点，请求发出者不用关心最终的接收者到底做了什么，任何类都可以接收者，所以命令的接收者彼此之间是独立的（上面的两个厨师并没有关联，我们的接接收者还可以是老板、经理等店里任何可以为顾客服务的人），顾客和最终的接收者之间的桥梁是我们服务员中的命令对象，也就是CheesePizzaOrder和DurianPizzaOrder，这样让顾客和接收者之间是松耦合，同样服务员和接收者之间也是松耦合。 定义命令模式将“请求”封装成对象，以便使用不同的请求、队列、或者日志来参数化其他对象。 角色 抽象命令 Command 具体命令 ConcreteCommand 接收者 Receiver 要求命令对象执行请求 Invoker 创建命令者 Client 接收者不是必须的，具体的命令也可以自己处理一些事 优缺点优点： 降低对象之间的耦合度。 新的命令可以很容易地加入到系统中。 可以比较容易地设计一个组合命令。 调用同一方法实现不同的功能 缺点： 使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用 命令模式的具体使用对象命令模式的定义大家可能还是很模糊，那我们就再仔细看看命令的使用，加深一下对命令模式的理解。接下来我们实现一个空调遥控器调节风力的功能： 空调： public class AirConditioner { public static final int HIGH = 3; public static final int MEDIUM = 2; public static final int LOW = 1; public static final int OFF = 0; String name; int speed = 0; public AirConditioner(String name){ this.name = name; } public void high(){ // 设置强风 speed = HIGH; } public void medium(){ // 设置低风 speed = MEDIUM; } public void low(){ // 设置弱风 speed = LOW; } public void off(){ // 空调关 speed = OFF; } public int getSpeed(){ return speed; } } 抽象命令： public interface Command { public void execute(AirConditioner airConditioner); public void undo(); } 强风命令： public class ConditionerHighCommand implements Command{ AirConditioner airConditioner; int speed; public void execute(AirConditioner airConditioner){ speed = airConditioner.getSpeed(); this.airConditioner = airConditioner; airConditioner.high(); } public void undo(){ if(speed = AirConditioner.HIGH) airConditioner.high(); else if (speed = AirConditioner.MEDIUM) airConditioner.medium(); else if (speed = AirConditioner.LOW) airConditioner.low(); else if (speed = AirConditioner.OFF) airConditioner.off(); } } 弱风命令： public class ConditionerLowCommand implements Command{ AirConditioner airConditioner; int speed; public void execute(AirConditioner airConditioner){ speed = airConditioner.getSpeed(); this.airConditioner = airConditioner; airConditioner.low(); } public void undo(){ if(speed = AirConditioner.HIGH) airConditioner.high(); else if (speed = AirConditioner.MEDIUM) airConditioner.medium(); else if (speed = AirConditioner.LOW) airConditioner.low(); else if (speed = AirConditioner.OFF) airConditioner.off(); } } 关闭命令： public class ConditionerLowCommand implements Command{ AirConditioner airConditioner; int speed; public void execute(AirConditioner airConditioner){ speed = airConditioner.getSpeed(); this.airConditioner = airConditioner; airConditioner.off(); } public void undo(){ if(speed = AirConditioner.HIGH) airConditioner.high(); else if (speed = AirConditioner.MEDIUM) airConditioner.medium(); else if (speed = AirConditioner.LOW) airConditioner.low(); else if (speed = AirConditioner.OFF) airConditioner.off(); } } 空命令: public class NoCommand implements Command{ public void execute(AirConditioner airConditioner){ // 什么也不做 } public void undo(){ // 什么也不做 } } 遥控器： public class RemoteControl { // 记录最后一次命令，首次为空命令 Command lastCommand = new NoCommand(); //遥控器上一共有4个按钮：除了撤销，其他按钮是可以自由让它有特定的功能 Command[] commands; public RemoteControl(Command[] commands){ commands = commands; } public void onePressed(AirConditioner airConditioner){ commands[0].execute(airConditioner); lastCommand = commands[0]; } public void twoPressed(AirConditioner airConditioner){ commands[1].execute(airConditioner); lastCommand = commands[1]; } public void threePressed(AirConditioner airConditioner){ commands[2].execute(airConditioner); lastCommand = commands[2]; } // 撤销按钮被按 public void undoPressed(){ lastCommand.undo(); } } 人： public class People { public static void main(String[] args){ Command[] commands = new Command[3]; commands[0] = new ConditionerHighCommand(); commands[1] = new ConditionerLowCommand(); commands[2] = new ConditionerOffCommand(); // 暂且给三个按钮赋予这三个相应的功能，强风、弱风、关闭功能 RemoteControl rc = new RemoteControl(commands); AirConditioner airConditioner = new AirConditioner(&quot;客厅的空调&quot;); rc.twoPressed(airConditioner); rc.onePressed(airConditioner); rc.twoPressed(airConditioner); rc.undoPressed(airConditioner); // 最终风速为？ } } 我们可以按遥控器了，每一次按了以后，接收者空调会做出相应的处理（除了撤销按钮），处理由被赋予按钮的命令决定，而且我们还可以更换三个按钮为其他功能，比如已经有的一个命令：空命令，如果实例化空调时，给其中一个按钮赋予空命令职责，他将什么都不会做，空命令在也是一个有非常大用处的命令。不过这个遥控器的还有很多需要优化的地方，比如撤销按钮，目前看来，撤销只能撤销前一次操作（恢复到前一次操作后的状态），大家可以再优化一下，看看怎么实现连续撤销功能，这也和命令模式的一个很重要的作用类似：实现事务系统。 还有哪些用法队列请求命令模式可以用来实现一个异步耗时队列请求的功能，我们可以实现一些列不同的命令，这些命令可能是某一个功能，也可能是一组功能，我们创建很多不同的命令，把他们放进一个队列，然后可能会有另一个线程从队列里面取出这些命令，挨个去执行他们。 状态恢复当我们程序执行一些命令，我们可以将每一次的执行的命令写进我们的日志，当电脑死机重启后，我们将日志信息读取出来，然后再挨个的去执行这些命令，让电脑恢复到之前死机时候的状态。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之单例模式]]></title>
      <url>%2F2016%2F12%2F05%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[小明请假了，直入主题单例模式，望文生义，就是只有一个实例的类，我们真的需要这种只有一个实例的类吗？答案的肯定的，在平时的程序中，单例也是我们经常会遇见和使用的，现在我们就来深入的认识一下单例模式。 用途我们都知道单例模式的用途很多，那么具体哪些情况下会使用它呢？现在我们就来总结一下：线程池、缓存、对话框、处理偏好设置和注册表对象、日志对象、充当打印机、显卡等设备的驱动程序对象等等……在这些情况下，一般我们不需要也不允许存在多个对象，如果不这样，可能会给我们带来一些问题。单例模式我们一定要清楚一点，就是在程序中有且只有一个类的实例。 如何确保只有一个实例我们都知道，实例化对象的方式是通过new的方式，那么其实我们可以在很多地方通过new的方式生成一个类的实例，如果只能让类有一个实例，我们就必须去屏蔽这种做法，让这个类不能通过这种方式去实例化，那么可以这样做吗？好消息是：在Java中，我们可以申明一个私有的构造方法，像这样 public MyClass { private MyClass(){ } } 这样，我们的类就不能被实例化了，那么新的问题来了，我们怎么实例化那唯一的一个实例呢？在类的外部我们不能访问这个类的构造函数，但是在类的内部我们可以访问啊，但是这个类没有实例化，我们不能访问它啊！这不就成了先有蛋还是先有鸡的问题了么，其实不然，我们不能用它的实例对象名，我们可以访问它的类名啊，在Java中可以通过类名去访问一个静态的方法，在这个方法中我们就可以实例化这个唯一个的对象： public MyClass { private MyClass(){ } public static MyClass getInstance(){ return new MyClass(); } } 似乎还有一些问题，我们并没有确保唯一性，所以稍微修改一下： 方法一（懒汉式）： public Singleton { private static Singleton instance; private Singleton(){ } public static Singleton getInstance(){ if(instance == null){ instance = new Singleton(); } return instance; } } 代码很容易理解，在单线程中，我们要获得这个类的实例，只能通过Singleton.getInstance()方法去得到，而且返回的实例永远都是同一个（第一次会先实例化）。那么这就是一个单例模式的实现。 定义单例模式确保只有一个实例，并提供一个全局访问点。 优点 单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例 因为类控制了实例化过程，所以类可以灵活更改实例化过程 缺点 虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题 还有更重要的事我们可以看到，单例模式的缺点很少，这也是因为他足够简单（但是作用很大），那么先解决上面缺点说的解决每次都检查实例是否存在的问题，解决他的方式也是实现单例模式的一种很重要的方式之一：饿汉式 public class Singleton{ private static final Singleton instance = new Singleton(); private Singleton(){ } public static Singleton getInstance(){ return instance; } } 这样，在类被加载时，我们需要的那个唯一的实例就存在了，以后的每一次访问都是那同一个实例。但是这样的就完美了吗？在某些情况下，它是完美的，就是我们的这个实例所占的资源很少，并且在程序的生命周期里，它是一定会被使用的。这样，我们就可以使用这种方式，否则这种方式可能会造成一些资源的浪费。那么如果有那种占用资源很多，还可能不会被使用的单例，我们怎么去设计呢？很容易想到，在我们真正使用到它的时候才去实例化它，就如我们上面的懒汉式。但在大多数情况下，我们的程序是多线程的，所以使用上面的方法一会出现一个问题，因为我们的new不是原子操作，所以在多线程情况下，还是会出现多实例化的情况。我们知道在多线程情况下，为了防止某个资源同时被多个线程访问，我们需要给它加锁进行同步： public class SingletonClass{ private static SingletonClass instance; public static synchronized SingletonClass getInstance(){ if(instance==null){ instance=new SingletonClass(); } return instance; } private SingletonClass(){ } } 这种方式防止了在多线程情况下会出现的问题，并且是在需要的时候才去实例化它。但是它完美了吗？同样的，在某些情况下它是完美的。因为加锁同步的方式会比不加锁的方式更低效，而且懒汉式的单例模式每次访问单例时都会加锁再释放锁，所以会失去一些效率。所以，懒汉式的方式在我们对效率要求不那么严苛的情况下，它是完美的。那如果我们对效率有要求，单例又很占用资源，还可能不会经常使用到它，那么在这种情况下有完美的方式吗？答案是肯定的，那就是双重检查加锁： public class SingletonClass{ private volatile static SingletonClass instance; public static SingletonClass getInstance(){ if(instance == null){ synchronized(SingletonClass.class){ if(instance == null){ instance=new SingletonClass(); } } } return instance; } private SingletonClass(){ } } 如果对性能的要求极高，而且单例被访问的频率很高，双重检查加锁的方式是可取的，否则这种方式可能会是杀鸡用了牛刀。那么这种方式是怎么避免效率的损失呢，可以看到，我们不是每一次都对资源进行了加锁，而是当知道单例对象为空时再加锁，这样就只会在第一次会出现加锁，不会有效率问题（同样会有每一次的为空判断）。那么volatile的作用呢？模拟一下，ThreadOne到第一个为空判断时，发现instance为空，这时候系统将资源给ThreadTwo，由于ThreadOne还没来得及对单例实例化，所以ThreadTwo任然判断instance为空，所以会继续往下实例化instance，实例化完成以后，ThreadOne继续往下走……现在明白了吧，如果没有volatile的修饰，在ThreadOne中的instance还是为空，有了volatile，会更新ThreadOne中的instance，这样再第二次判断为空时，instance已经不再为空了，就不会再实例化了。明白刚刚说的为什么这是牛刀了吧！ 单例的新鲜实现化在Android中，我们会经常使用一个类就是LayoutInflater，用它将我们的布局文件转化成具体的View控件，其实在程序中我们的LayoutInflater就是一个单例，我们看看它如何实现： LayoutInflater.java中from方法 public static LayoutInflater from(Context context) { LayoutInflater LayoutInflater = (LayoutInflater)context .getSystemService(Context.LAYOUT_INFLATER_SERVICE); if (LayoutInflater == null) { throw new AssertionError(&quot;LayoutInflater not found.&quot;); } return LayoutInflater; } 最终会调用到Contextimpl.java中的 @Override public Object getSystemService(String name) { return SystemServiceRegistry.getSystemService(this, name); } 然后是SystemServiceRegistry中的getSystemService(ContextImpl ctx, String name)方法，这个方法是这样的 private static final HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS =new HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;(); public static Object getSystemService(ContextImpl ctx, String name) { ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name); return fetcher != null ? fetcher.getService(ctx) : null; } private static &lt;T&gt; void registerService(String serviceName, Class&lt;T&gt; serviceClass,ServiceFetcher&lt;T&gt; serviceFetcher) { SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName); SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher); } 可以看到我们的对象是从一个map中通过key的方式取出来的，而单例的对象又是通过registerService(String serviceName, Class serviceClass, ServiceFetcher serviceFetcher)方法将服务类单例添加到map中的。这也是一种Android中单例模式的使用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之工厂模式]]></title>
      <url>%2F2016%2F12%2F04%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[又来了新的项目这一天，小明主管找到小明说：我们之前的项目里面其实有很多通过new的方式去创建对象，而且是创建的一些实际的对象，这样的做法是不太好的。小明很诧异，不通过new方式，还有其他的方式创建？主管对小明说：没事，做了我们的项目你就明白这一切了。这次我们的新项目是做给一家披萨店的，我和你一起来做这个项目，你先做，我再做进一步的改进。 小明很快做了一个版本出来： Pizza orderPizza(String type) { Pizza pizza; if(type.equals(&quot;cheese&quot;)){ pizza = new CheesePizza(); }else if(type.equals(&quot;greek&quot;)){ pizza = new GreekPizza(); }else if(type.equals(&quot;durian&quot;)){ pizza = new DurianPizza(); } pizza.prepare(); pizza.make(); pizza.cut(); pizza.box(); return pizza; } 主管对小明说：如果我现在有新种类的Pizza，你的程序会犯了什么问题？小明一下发觉了问题所在，代码里面除了make()方法以外，上面的都是变化的，我应该把它们独立出来： public class SimplePizzaFactory{ public Pizza createPizza(String type) { Pizza pizza; if(type.equals(&quot;cheese&quot;)){ pizza = new CheesePizza(); }else if(type.equals(&quot;greek&quot;)){ pizza = new GreekPizza(); }else if(type.equals(&quot;durian&quot;)){ pizza = new DurianPizza(); } return pizza; } } public class PizzaStore{ SimplePizzaFactory factory; public PizzaStore(SimplePizzaFactory factory){ this.factory = factory; } public Pizza orderPizza(String type) { Pizza pizza = factory.createPizza(type); pizza.prepare(); pizza.make(); pizza.cut(); pizza.box(); return pizza; } } 主管继续对小明说，嗯，不错，已经慢慢走上正轨了，你现在使用的就是不算是一种设计模式的模式—简单工厂：将对象的创建放在另外的类中去解决，这样能够简单的将变化的部分独立出来，我们再有新的Pizza或者其中一种Pizza不在制作时，可以不用去修改PizzaStore的代码，因为PizzaStore是不应该被经常修改的。但是，简单工厂还不是我们想要的，如果出现了其他加盟店，我们需要将其他加盟店的整个流程都管理起来，那么仅仅只有生成Pizza的工厂是不够的，从准备到装盒的整个流程我们都需要规范其起来（prepare()、make()、cut()、box()方法），不然其他的加盟店只利用我们提供的工厂生产Pizza，而这些流程有自己的方式，那Pizza店的服务就不能统一标准了。那小明问那我们应该怎么改进呢？主管说，很简单，我们使用工厂方法模式： public abstract class PizzaStore{ public Pizza orderPizza(String type) { Pizza pizza = createPizza(type); pizza.prepare(); pizza.make(); pizza.cut(); pizza.box(); return pizza; } abstract Pizza createPizza(String type); } public class ChengDuPizzaStore extends PizzaStore{ Pizza createPizza(String type){ if(type.equals(&quot;cheese&quot;)){ return new CheesePizza(); }else if(type.equals(&quot;greek&quot;)){ return new GreekPizza(); }else if(type.equals(&quot;durian&quot;)){ return new DurianPizza(); }else { return null; } } } 小明说，等等，这种模式怎么又出现了可能会改变的部分啊？而且这和简单工厂的方式区别就是新的创建对象类成了PizzaStore的子类。主管说，你说到关键了，这和简单工厂的方式很相似，但是仅仅只是相似，它和简单工厂的区别很大：简单工厂仅仅只是把对象的创建封装到另一个类中，而工厂方法模式提供了一个框架，所有子类都依靠这个框架（prepare()、make()、cut()、box()），然后把对象的创建交给了子类，因为在Pizza店和其他的一些实际的需求中，子类可能只需要决定产生什么要的东西，而其他的流程都是统一规范的。这里面体现了一个很重要的原则：依赖倒置原则，披萨店在使用Pizza时，没有具体依赖某一种披萨实现自己的流程（prepare()、make()、cut()、box()），而是一个通过依赖于一个Pizza接口。 工厂方法模式定义定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类的实例化推迟到子类。 角色 抽象产品 产品实现 抽象工厂 具体工厂 优缺点优点 在工厂方法中，用户只需要知道所要产品的具体工厂，无须关系具体的创建过程，甚至不需要具体产品类的类名 在系统增加新的产品时，我们只需要添加一个具体产品类和对应的实现工厂，无需对原工厂进行任何修改，很好地符合了“开闭原则” 缺点 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，是的系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事 披萨店的新问题没过多久，主管找到小明说，披萨店在使用我们的程序时，出现了一个问题，披萨店的出售流程是规范了，但是有一些加盟店开始在原料上偷工减料，造成披萨在顾客中的口碑褒贬不一，所以我们需要改进一下，让每个店使用的原料是可以被监控的。小明很快想到了办法，我们将披萨生成（new的时候）统一为一个简单工厂，那么就可以统一知道披萨的生成了。主管说这样表面是解决了问题，但其实这样会使每个店生成的都是一样的，我们的目的是为了监控原料，而非统一原料。所以我们真正需要使用的是抽象工厂模式： public interface PizzaIngredientFactory{ public Dough createDough(); public Sauce createSauce(); public Cheese createCheese(); public Veggies[] createVeggies(); public Clams createClams(); } public abstract class Pizza{ String name; Dough dough; Sauce sauce; Cheese cheese; Veggies[] veggies; Clams clams; public void make(){ } public void cut(){ } public void box(){ } abstract void prepare(); } public class CheesePizza extends Pizza{ PizzaIngredientFactory factory; public CheesePizza(PizzaIngredientFactory factory){ this.factory = factory; } void prepare(){ dough = factory.createDough(); sauce = factory.createSauce(); cheese = factory.createCheese(); veggies = factory.createVeggies(); clams = factory.createClams(); } } 这样一来，我们的披萨名字是一样的，但是不同的地方制作相同披萨的原料可以不一样（自己实现PizzaIngredientFactory），这就是抽象工厂模式。 抽象工厂模式定义提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。 角色 抽象工厂 实现工厂 抽象产品 具体产品 产品族不同的产品等级结构，功能相关联的产品组成的家族。抽象工厂就是创建出分属于不同产品等级机构的对象组成产品族。 优缺点优点： 抽象工厂模式隔离了具体类的生产，使得客户并不需要知道什么被创建 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则” 缺点： 增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之装饰器模式]]></title>
      <url>%2F2016%2F12%2F03%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[经典咖啡厅问题小明的公司又接到了新的项目，这次是要做程序的是一家咖啡厅，他们需要把他们的咖啡好好的管理起来，小明了解需求以后，很快就根据咖啡店的情况设计出了第一版咖啡厅程序： 很快，新的需求来了，由于顾客的增多，有许多客户对咖啡有特殊的要求，如加奶、加糖，巧克力风味的等等，加了不同料的咖啡价格是不一样的。小明很快就着手开始新建更多类，加奶焦糖玛奇朵，巧克力摩卡……但这时的他突然发现有问题：相同的咖啡，因为加料的不同出现了很多的配搭，会导致严重的类剧增。 小明立即请教了主管，并提出了新的解决方案，给Coffee接口增加方法，如setMilk()、hasMilk()等方法来确保某一个咖啡是加了哪些其他调料的，但是一个问题直接就否定了这样设计：如果我要加双倍调料呢？而且如果出现了一种新的不能加任何调料的饮料时，就会违背接口隔离原则，小明陷入了很大的困难之中，这是主管让小明去了解一下装饰器模式，然后再做出新的设计，小明再了解之后，很快做出了新的设计： 定义小明用的设计模式就叫装饰者模式：动态的将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。 角色 抽象组件（Component） 具体组件（Concrete Component） 装饰（Decorator） 具体装饰角色（Concrete Decorator） 注意：装饰者模式并非针对具体的组件进行装饰 真实世界的装饰者：Java I/O 这是Java I/O中字节输入流的类图结构，我们发现和咖啡厅的设计几乎是一样的，不同的是InputStream是通过抽象类实现，而非接口。我们把左边的三个类（FileInputStream、 StringBufferInputStream、ByteArrayInputStream，不止这是三个）在装饰者模式中称为组件，而把继承至FilterInputStream的类称之为装饰者，装饰者就是用来装饰组件的。看看I/O内部BufferedInputStream是怎么修饰的呢？我们可以用BufferedInputStream来修饰FileInputStream，如果不用BufferedInputStream修饰，直接使用FileInputStream，在调用read()方法时，我们每读出一个字节，就需要做处理，使用了BufferedInputStream，它会给我们提供一个缓冲区，这个缓冲区可以我们自定义大小，也可以使用BufferedInputStream的默认8兆的大小，缓冲区都作用就是将读取出来的数据缓存起来供我们使用，而不是读取一个字节就要使用。 装饰者模式的优缺点和体现的原则优点： 不用继承扩展了类的功能 装饰者可以叠加使用，创造不同的功能，体现了不针对实现的编程 缺点： 程序复杂性会增加 会出现很多小类 针对抽象组件编程，而非具体组件 原则 多有组合，少用继承 开闭原则：对扩展开发，对修改关闭]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之观察者模式]]></title>
      <url>%2F2016%2F12%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[论坛每日精选项目小明的公司又接到了新的项目，这次的项目是一个论坛管理员给他们的论坛做的，论坛每天会选出优秀的文章发给读者，读者需要订阅这个推送，小明不太明白从何入手，于是请教了他的主管…… 然后小明的主管很快设计出了两套程序让小明选择， 程序A: 程序B: 程序A和B都是通过注册的方式将观察者关联到可观察者中，当有新的文章时，在notifyObservers()方法中调用所有Observer的update()方法。主管问小明我们应该选择哪一个呢？小明仔细分析了A和B，然后说选择B。主管说，A中我用的JDK中的可观察者类（java.util.Observable），为什么不选择A呢，还要自己定一个接口去做和Observable做差不多的事呢？小明说，上个项目用到策略模式时，有一个原则：针对接口编程，如果我们用继承的方式，会有很多问题： 1）如果ArticleData还需要干其他事情，因为Java不能多继承，所以会陷入两难 2）建立自己的实现时，破坏对扩展开发，对修改关闭的原则。因为Observable中已经对注册、删除、更新做了自己的实现 3）直接使用Observable时，很大的情况下Observable无法满足我们的需求 主管补充了一条： 4）JDK中的Observable在调用notifyObservers()时，依赖与setChanged()中的changed(boolean)，可能不是我们需要的 还有一个需要注意的地方：注意Observable中的存放Observer的Vector是倒序遍历的，所以要注意调用Observer update()方法的顺序和我们注册时的顺序是相反的。另外一个值得我们关注的地方，对于更新，我们可以有两种方式：被观察者主动推和观察者自己取拉。JDK中Observable的notifyObservers(Object)和notifyObservers()体现了这两种不同的方式。 定义在对象之间建立一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会受到通知，并自动更新。优缺点优点： 观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个具体现察者聚集，每一个具体现察者都符合一个抽象观察者的接口。被观察者并不认识任何一个具体观察者，它只知道它们都有一个共同的接口。由于被观察者和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次 观察者模式支持广播通信。被观察者会向所有的登记过的观察者发出通知 缺点： 如果一个被观察者对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间 如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。在使用观察考模式时要特别注意这一点 如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方式进行的 虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的 观察者模式中体现的原则找出变化的部分，和不变的地方分离改变的是关注者的数量和类型，所以观察者被分离出来了 针对接口编程，不针对实现编程被观察者和观察者都使用接口，观察者利用被观察者接口注册、取消注册，被观察者利用观察者的更新接口通知观察者。这样让两者之间独立运作，具有松耦合的优点 多用组合，少用继承被观察者和观察者是通过关联在一起，而不是通过继承的方式 观察者模式的运用如在Java中JButton的监听事件注册；另外在Android中的控件适配器Adapter这一功能，我们的控件（ListView、RecycleView、GridView等）里面都有一个观察者实现类通过继承AdapterDataSetObserver实现了对变化的观察，在setAdapter()时，将该实现了对象注册到Adapter中。看一看源码一下就清楚了： BaseAdapter.java public abstract class BaseAdapter implements ListAdapter, SpinnerAdapter { private final DataSetObservable mDataSetObservable = new DataSetObservable(); /……/ public void registerDataSetObserver(DataSetObserver observer) { mDataSetObservable.registerObserver(observer); } public void unregisterDataSetObserver(DataSetObserver observer) { mDataSetObservable.unregisterObserver(observer); } /** * Notifies the attached observers that the underlying data has been changed * and any View reflecting the data set should refresh itself. */ public void notifyDataSetChanged() { mDataSetObservable.notifyChanged(); } /** * Notifies the attached observers that the underlying data is no longer valid * or available. Once invoked this adapter is no longer valid and should * not report further data set changes. */ public void notifyDataSetInvalidated() { mDataSetObservable.notifyInvalidated(); } /……/ } AbsListView.java public abstract class AbsListView extends AdapterView&lt;ListAdapter&gt; implements TextWatcher, ViewTreeObserver.OnGlobalLayoutListener, Filter.FilterListener, ViewTreeObserver.OnTouchModeChangeListener, RemoteViewsAdapter.RemoteAdapterConnectionCallback { AdapterDataSetObserver mDataSetObserver; /……/ class AdapterDataSetObserver extends AdapterView&lt;ListAdapter&gt;.AdapterDataSetObserver { @Override public void onChanged() { super.onChanged(); if (mFastScroll != null) { mFastScroll.onSectionsChanged(); } } @Override public void onInvalidated() { super.onInvalidated(); if (mFastScroll != null) { mFastScroll.onSectionsChanged(); } } } /……/ } ListView.java public class ListView extends AbsListView { /……/ @Override public void setAdapter(ListAdapter adapter) { if (mAdapter != null &amp;&amp; mDataSetObserver != null) { mAdapter.unregisterDataSetObserver(mDataSetObserver); } resetList(); mRecycler.clear(); if (mHeaderViewInfos.size() &gt; 0|| mFooterViewInfos.size() &gt; 0) { mAdapter = new HeaderViewListAdapter(mHeaderViewInfos, mFooterViewInfos, adapter); } else { mAdapter = adapter; } mOldSelectedPosition = INVALID_POSITION; mOldSelectedRowId = INVALID_ROW_ID; // AbsListView#setAdapter will update choice mode states. super.setAdapter(adapter); if (mAdapter != null) { mAreAllItemsSelectable = mAdapter.areAllItemsEnabled(); mOldItemCount = mItemCount; mItemCount = mAdapter.getCount(); checkFocus(); mDataSetObserver = new AdapterDataSetObserver(); mAdapter.registerDataSetObserver(mDataSetObserver); mRecycler.setViewTypeCount(mAdapter.getViewTypeCount()); int position; if (mStackFromBottom) { position = lookForSelectablePosition(mItemCount - 1, false); } else { position = lookForSelectablePosition(0, true); } setSelectedPositionInt(position); setNextSelectedPositionInt(position); if (mItemCount == 0) { // Nothing selected checkSelectionChanged(); } } else { mAreAllItemsSelectable = true; checkFocus(); // Nothing selected checkSelectionChanged(); } requestLayout(); } /……/ } 代码很清晰，在AbsListView中实现了一个观察者内部类，并在setAdapter()时，实例化了这个实现类，将它注册到了Adapter中，当Adapter中数据有更新时，就会调用观察者的更新方法，也就是AbsListView中的那个观察者中的onChanged方法。一般情况下，Adapter就只有一个观察者，我们可以通过调用Adapter中的registerDataSetObserver(DataSetObserver)方法增加观察者，可以观察Adapter的数据变化。大家可以想一想他和我们上面的实现有什么区别，然后为什么是这样的呢？思考一下………… 被观察者通过实现接口，而观察者是通过继承然后和AbsListView组合的方式构成的。为什么AbsListView不直接是观察者呢？就是我们上面说的，如果直接通过AbsListView继承Observable，那么AbsListView将不能再继承自View，这也是JDK种我们Observable不是一个接口会出现的问题，我们需要换一种方式去表示我们的被观察者，自己定义一个接口或者和JDK的Observable实现类组合使用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之策略模式]]></title>
      <url>%2F2016%2F12%2F01%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[马戏团问题现在程序员小明需要设计一个关于马戏团的程序，最初，马戏团只有一个人，也只有一个动物（猴子），因此，小明很快就设计出来了： 没过多久，马戏团又来了一只猴子，会表演跳舞，于是小明将程序改成了： 后来，马戏团的猴子越来越多，小明发现，每次来了一种会不同表演的猴子，都必须重新增加相应的类，并覆盖相应的perform()方法，小明发现这样程序这样下去会变得不好维护： 代码在多个子类中重复（有其他会表演跳舞的动物） 运行时行为不容易改变（比如有一只什么都不会表演的猴子学会了戴帽子） 牵一发动全身（修改父类的perform()方法，会造成不该改变的猴子改变） 很难知道猴子所有的表演 此时，小明的主管告诉小明，设计或者修改程序时，我们遵循一个原则：找出类中的变化部分，将它独立出来。小明首先想到了接口，用接口去表示猴子不同的表演，然后让不同的猴子去实现不同表演，但是仔细一想，上面的1）2）还是不可避免。这时，小明的主管说，把猴子的表演单独成一个类，然后和猴子通过组合模式进行组合，然后猴子的表演行为用其他一些类去实现，并且要记住：面向接口编程。小明经过深思熟虑，设计出了新的程序： 这样，我们再增加猴子时，只需要增加不同的表演实现类即可，如果来了其他会跳舞的动物，我们也可以复用表演实用类。那么主管给说小明说的面向接口编程又体现在哪里呢？注意Animal，与它组合的并不是具体实现的表演类，而是一个抽象出来的表演行为类（PerformBehavior），这也是设计模式中的依赖倒置原则 定义你刚刚看到的就是策略模式，定义：定义了方法族，分别封装起来，让他们相互之间可以替换，此模式让算法的变化独立于使用算法的客户，那么上面的表演行为就是一些列算法，而猴子就是使用它的客户，算法可以自己新增、修改而并不需要修改客户。我们也可以从上面的例子得出一个结论：组合比继承更好（有一个比是一个好）。 角色 客户：方法的调用者 抽象策略 具体策略 优缺点优点 策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码转移到父类里面，从而避免重复的代码。 策略模式提供了可以替换继承关系的办法。继承可以处理多种算法或行为。如果不是用策略模式，那么使用算法或行为的环境类就可能会有一些子类，每一个子类提供一个不同的算法或行为。但是，这样一来算法或行为的使用者就和算法或行为本身混在一起。决定使用哪一种算法或采取哪一种行为的逻辑就和算法或行为的逻辑混合在一起，从而不可能再独立演化。继承使得动态改变算法或行为变得不可能。 使用策略模式可以避免使用多重条件转移语句。多重转移语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重转移语句里面，比使用继承的办法还要原始和落后。 缺点： 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。 策略模式造成很多的策略类，每个具体策略类都会产生一个新类。有时候可以通过把依赖于环境的状态保存到客户端里面，而将策略类设计成可共享的，这样策略类实例可以被不同客户端使用。换言之，可以使用享元模式来减少对象的数量。 啰嗦一下继承（抽象、多态、封装）是我们的OO思想，我们可以用OO思想写出很多程序，但是为什么会出现设计模式呢？其实，设计模式就是在OO思想之后出现，工程师们一点一点总结出来的，它不是被发明的，而是被发现的。它是为了我们写出更容易扩展、修改和理解的程序，要知道软件开发过程中唯一不变得就是变化，所以设计模式有很多好处： 共享词汇，最大化沟通交流的价值 有利于程序的变化 有利于程序的理解 有利于程序的维护 有利于程序的复用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式六大原则]]></title>
      <url>%2F2016%2F11%2F29%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%2F</url>
      <content type="text"><![CDATA[开闭原则定义：对扩展开放，对修改关闭在平时我们程序迭代更新的过程当中，往往会对现有的功能进行修改，但是这样又往往会对我们的程序造成破坏甚至带来致命的错误，所以在对程序进行修改时，尽量不要修改原有的功能，而是通过扩展的方式增加新功能。开闭原则算是六大原则中的一个总原则，之后的五大原则都遵循这个总的开闭原则。 单一职责原则定义：一个类只负责一项职责（同样适用于方法和接口）当在设计一个类时，我们应该注意一个类应该只能具有某一种功能，而不能有多个。同样在重构时，如果发现某一个同时负责着多个功能，应该将它的功能进行拆分。此原则是为了防止我们一个类有多个职责时，我们在修改它的其中一个职责时，可能会对另外的职责功能造成影响。 里氏替换原则定义：在程序中，子类可以完整的替换父类完成父类的功能通俗的说，当使用继承时，子类可以可以扩展父类的功能，但不能改变父类的功能。主要有四层含义： 1）子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法 2）子类中可以增加自己特有的方法 3）当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松 4）当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格 依赖倒置原则定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象从定义看，有两层意思，分别解释，首先，高层模块不应该依赖底层模块：类A与类B存在依赖关系（何为依赖），当我们需要将类A修改为依赖于类C，这个时候，我们就需要修改类A。这种情况中，类B类C属于底层模块，类A属于高层模块，我们要做到不修改类A，那么我们的类A就不能依赖类B和类C(底层模块)，所以，我们需要将类A依赖改为类B类C的抽象，也就是类B类C实现同一接口，无论之后类需要依赖哪个类，我们都不再需要修改类A了。抽象不应该依赖细节，细节应该依赖抽象：在进行抽象时，不关注具体的细节，也就是具体的实现，而在具体实现时，要依赖抽象，有点不好理解。通俗的说，我们在设计一个框架时，首先要通过抽象的方式搭建，在Java中就是通过抽象类和接口的方式，而具体的实现通过抽象类和接口来实现实现类。依赖原则的中心思想就是面向接口编程。 接口隔离原则定义：实现类不应该依赖它不需要实现接口具体方法的接口接口I需要实现方法a、b、c，具体实现类A实现方法a、b，实现类B实现a、c。A,B都需要实现它们不需要的方法，就违背了这个原则，解决方法其实很简单，就是对接口I进行拆分，然后A和B取分别实现它需要的接口。 迪米特法则定义：一个对象应该对其他对象保持最少的了解迪米特法则又可以叫最少知道原则，就是一个类依赖另一个类时，应该对它的依赖类知道得越少越好，也就是降低类和类的耦合。违背这个原则带来的问题是显而易见的：类和类的之间的耦合过高，修改一个类时，会影响其他的类，所以我们要做到低耦合，高内聚。如何避免知道过多的对象，在该对象的方法内，我们应该调用属于以下范围的方法： 该对象本身 被当着方法的参数而传递进来的对象 此方法所创建或实例化的任何对象 对象的任何组件（组合关系）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java内存回收简介]]></title>
      <url>%2F2016%2F09%2F12%2FJava%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[前言大家都知道，C++的内存管理是由开发人员自己掌握的，而Java则是自动完成的，那么它是怎么实现的呢？在前人们设计垃圾收集技术时，解决了下面三件事情： 1）那些内存需要回收？ 2）什么时候回收？ 3）如何回收？ 那些内存需要回收和什么时候回收要确认那些对象可以回收，就需要确认该对象实例是否已经不再被使用了，那么常见的实现由哪些呢？ 引用计数法此方法的实现为：给每一个对象实例添加一个引用计数器，每当有一个地方引用它了，该计数器就加一。当对象引用计数器为零的时候，说明没有再引用它的地方了，所以该对象实例“死了”，可以被回收了。那么是不是这种算法就可以了呢？但是实际情况中，主流的一些Java虚拟机并没有采用此算法，原因是因为，当遇到循环引用的情况时，就不好处理了。 Java采用的算法：可达性分析算法该算法通过一些列可以作为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，说明该对象已死（不过不一定就被回收，可以自救，但是实际情况中不会这么做）。在Java中，可以作为GC Roots对象的对象包括： 1）栈帧中的局部变量引用的对象 2）方法区静态变量引用的对象 3）方法区中常量引用的对象 4）本地方法栈中Native方法里应用的对象 延伸上面讲的是堆中的垃圾回收，在Java中，除了堆中会有垃圾回收，还有其他内存区域有内存回收吗？是有的，那就是方法区，方法区中存放的是和类相关的一些信息，那么如果确定那些类可以被回收呢： 1）该类的所有实例都被回收，在堆中已经不存在该类的实例 2）加载该类的ClassLoader已经被回收 3）该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法 如何回收如何回收已经成为垃圾对象实例，也有很多不同的算法，每种算法有它的优势和劣势。 标记-清除算法这种算法是最容易理解的，它就是通过上面可达性分析算法后，标记出已死的对象实例，然后将这些区域的内存进行回收。不过它有两个明显的不足： 1）标记和清除两个步骤的效率很低 2）由于被回收的区域可能是不连续的，所以当需要连续内存时，必须提前触发一次垃圾收集动作 复制算法复制的具体实现原理就是将内存分为两块，每次只使用其中一块，当这一块快使用完了的时候，就将这块中还存活的对象复制到另一块中，然后清理掉前一块中的内存空间。这种算法用于商业虚拟机回收新生代，因为新生代的对象98%都是“朝生夕死”，就将这块区域分为一块大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，当回收时，将较少存活对象复制到另一块Survivor中，清理掉之前使用的Eden和其中一块Survivor。 标记-整理算法标记-整理算法和标记-清除算法的前面步骤是一样的，只是在标记后，并不马上清理，而是让所有存货的对象向一端移动，然后清理掉另一端的边界以外的对象。这种算法和上面的标记-清除算法用于虚拟机中老年代的回收算法。 分代收集法 分代收集法就是根据对象的存活周期将内存划分为两块：新生代和老年代，然后不同的区域采用不同的垃圾回收算法，如上面介绍到的：新生代采用复制算法，老年代采用标记-清除或者标记-整理算法。在实际情况中，当新生代中另一块Survivor区域无法存放下存活下来的对象时，这些对象将进入老年代，那么有哪些情况，新生代的对象会进入老年代呢？ 1）大对象 2）每次Eden进行MinorGC后对象年龄加1进入survivor，对象年龄达到15时进入老年代 3）如果Survivor空间中相同年龄所有对象大小的总和大于survivor空间的一半，年龄大于等于该年龄的对象就直接进入老年代 4）如果survivor空间不能容纳Eden中存活的对象。由于担保机制会进入老年代。如果survivor中的对象存活很多，担保失败，那么会进行一次Full GC]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java内存区域简介]]></title>
      <url>%2F2016%2F09%2F12%2FJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[前言为什么是简介呢？因为自己实在不敢用详解两字，不过还是希望用简短易懂的语言来描述，使大家能有一个初步的认识，这些内容主要是从《深入Java虚拟机》中同时加入自己的一些零碎知识总结而来的，所以还是希望大家可以多看书，然后总结为自己的知识体系。 线程和进程为什么会提到这两个老生常谈的东西呢？因为Java的内存区域是分为共享和非共享的，那么直接就和线程和进程相关了，线程和进程的区别在这里我就不详细介绍了，不太了解的同学可以看看这篇文章进程与线程的一个简单解释，比较形象和生动。 单核可以多线程吗我们从这个问题入手，看看Java虚拟机是如何实现多线程的。首先，这个问题的答案是肯定的（可以），多个线程会被CPU分配不同的时间，CPU快速的切换（一般在几十毫秒）不同的线程来实现多线程，我们把分配给线程的时间叫着时间片，不停的切换时间片就是上下文切换，在一秒时间里，上下文切换的次数可以达到数千次（2000次左右）。所以接下来第一块我们需要介绍到的，就是在切换中起着很大作用的程序计数器。 运行时数据区 程序计数器程序计数器是一块很小的内存，它是线程私有的，它记录着当前线程Java方法虚拟机字节码指令的地址（如果为Native方法，计数器值为空），为什么需要记录这个东西呢？因为再上下文不断切换时，我们需要保存将被切换线程执行到哪里了，然后再恢复时，可以根据保存的信息进行恢复。在这个内存区域中，是不会出现OutOfMemoryError的，也是内存区域中唯一个。 Java虚拟机栈Java虚拟机栈也是线程私有的，它的生命周期和线程相同。一个线程中有多个方法，每一个方法都会创建一个栈帧，这个栈帧里面保存了局部变量表、操作数栈、动态链接、方法出口等信息。很多个栈帧不断的在虚拟机栈中入栈和出栈，就是这个线程不断的执行，同时随着入栈和出栈，一个方法的调用也执行完成了。 局部变量表一个方法有一个局部变量表，它存放了方法中各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，对象引用不是对象本身，而是指向对象起始地址的引用指针、一个代表对象的句柄或者其他对象的相关位置）、returnAddress类型（指向了一条字节码指令的地址）。虚拟机栈中局部变量表的大小在运行期间是不会变化的，进入一个方法时，这个大小就已经确定了。 异常在虚拟机栈中，可能会发生两种异常：StackOverflowError和OutOfMemoryError。发生这两种异常的情况分别是： 1）线程所请求的栈深度大于虚拟机所允许的深度。 2）如果虚拟机扩展无法申请足够的内存。 这两个描述还是比较模糊的，那么实际情况中，什么情形下会产生这两种不同的异常呢？有一个统一的结论，大家可以实际去证明，那就是：在单个线程下，无论是由于栈帧太大还是栈容量太小（大小是可配置的），但内存无法分配时，都抛出StackOverflowError。在多线程中，线程越多，供每个线程瓜分的虚拟机栈空间越少，当把最后能被瓜分的内存耗尽时，就会抛出OutOfMemoryError。 本地方法栈本地方法栈和Java虚拟机栈作用是非常相似的，Java虚拟机栈是服务于Java方法（也就是字节码），而本地方法栈是服务于Native方法的。甚至有的虚拟机（如HotSpot，目前最新版本JDK使用的虚拟机）直接将这两部分合二为一，所以同样的，本地方法栈也会抛出StackOverflowError和OutOfMemoryError。 Java堆Java堆一般来说是Java虚拟机所管理的内存中最大的一块。它是一块被线程共享的内存区域。他存放的就是对象的实例和数组，如上面提到局部变量中对象引用就可能指向这里。这一块的内容主要就是内存回收相关的东西，这里不再深入，后面单独对内存回收做介绍。无论这块内存有多大，还是会出现无法再扩展的情况，就会抛出OutOfMemoryError异常。 方法区这个区域和堆一样，是线程共享的，它用来存储已被虚拟机加载的类信息（类名、访问修饰符等）、常量、静态变量、即时编译器编译后的代码等数据，因此它是堆得一个逻辑区域。不过大家容易被这个名字所误导，所以需要特别注意。 运行时常量区此区域属于方法区的一部分，在编译时，会产生一些类的常量信息，就存放在此区域中，当然在运行时，也可以产生一些常量，如调用String的intern方法，就会将该常量放入常量池中。在方法区中，如果无法满足内存分配时，将抛出OutOfMemoryError异常。 延伸知识刚才提到，使用String的intern方法，会把常量放入方法区的运行时常量区中，不过JDK 1.6和JDK 1.7有一些区别： 1）1.6intern方法会把首次遇到的字符串实例复制到永久代中，并返回实例的引用。 2）1.7不会复制实例，而是在常量池中记录首次出现的实例引用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LeetCode 394.Decode String]]></title>
      <url>%2F2016%2F09%2F08%2FLeetCode%20394.Decode%20String%2F</url>
      <content type="text"><![CDATA[LeetCode新题LeetCode最近好像又更新了，之前刷了100道左右的Easy和Medium，但是之前刷的题都没有写博客，这次写是因为网上的解法还很少，所以发上来供大家查阅。 题意和解法这道题的题意其实很简单，就不过多解释了，看到此类表达式的计算，我们第一个想到的数据结构就是栈，利用栈的先进后出性质进行计算。 过程遍历字符串，遇到数字、字母和[直接进栈，遇到]，然后出栈，先找出所有字母，直到[(也要出栈)，然后再继续出栈找出数字，这里注意数字可能是多位的，比如123[a]，所以出栈的终止条件是栈空或者遇到非数字的字符，通过上面出栈的字符串和数字，组成新的字符串，如字符串2[ab]，新的字符串应该为abab，这些新的字符也必须再重新进栈。就这么简单~ AC代码第一版代码，后面如果优化了会再更新 public static String decodeString(String s) { if (s == null || s.length() == 0) return s; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (char c : s.toCharArray()) { if (c == &apos;]&apos;) { StringBuilder sb = new StringBuilder(); while (!stack.isEmpty() &amp;&amp; ((stack.peek() &gt;= &apos;a&apos; &amp;&amp; stack.peek() &lt;= &apos;z&apos;) || stack.peek() == &apos;[&apos;)) { char ccc = stack.pop(); if (ccc == &apos;[&apos;) break; sb.insert(0, ccc); } if (stack.isEmpty()) { return sb.toString(); } else { int count = 0; int w = 1; while (!stack.isEmpty() &amp;&amp; stack.peek() &gt;= &apos;0&apos; &amp;&amp; stack.peek() &lt;= &apos;9&apos;) { int val = stack.pop() - &apos;0&apos;; count += val * w; w *= 10; } char[] chars = sb.toString().toCharArray(); while (count &gt; 0) { for (char cc : chars) stack.push(cc); count--; } } } else stack.push(c); } StringBuilder sb = new StringBuilder(); while (!stack.isEmpty()) sb.insert(0, stack.pop()); return sb.toString(); }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[马拉车(Manacher)算法]]></title>
      <url>%2F2016%2F08%2F25%2F%E9%A9%AC%E6%8B%89%E8%BD%A6(Manacher)%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[解决的问题马拉车算法主要是为了解决求一个字符串的最长回文串，当然求解这个问题的算法很多，比如穷举法（轮询所有子串得出最长的是回文串子串），但是时间复杂度太高（复杂度为O(n^3)）。马拉车算法可以有效的降低时间复杂度（复杂度为O(n)）。 原理与实现原理利用已知的对称信息和回文串的对称性得出其他位置的对称信息，并且不用考虑字符串长度是奇数还是偶数的，因为首先我们对字符串进行处理：在字符串的首尾和字符间加上&quot;#&quot;，如&quot;nbbn&quot;改变后为&quot;#n#b#b#n#&quot;，再在首位加上&quot;&amp;&quot;，所以最终经过处理的字符串为&quot;&amp;#n#b#b#n#&quot;。另外我们还需要辅助一个和处理后长度一致的int数组，该数组用来存字符串对应位置的最长回文长度加上本身（就是最长回文数+1），如下： 如字符串第二个b两边对称的长度为1，所以它对应的int数组内的值为2。有了这个表格，我们就知道，只要求出字符串对应位置上int数组的值，那么回文串自然就出来了，那int[]数组怎么求出来呢？也就是怎么利用已知的对称信息和回文串的对称性得出其他位置的对称信息呢？首先假设最长回文所在位置为id，到最长回文长度的位置为idMax,如果我们要求i位置上的最长回文长度（也就是int[i]的值），可以根据int[j]的值，前提条件是(0&lt;=j&lt;i,所以int[j]是已知的)，那么是什么原理呢？分为两种情况： i &lt;= idMax，通过id的位置找到和i位置对称的j点 如过int[j] &lt; idMax - i，那么int[i]就等于int[j]。如果int[j] &gt;= idMax - i，那么int[i]的值大于或者等于int[j]。然后再在这个位置继续向左右延伸判断是否还有回文长度。i &gt; idMax时，所以中心点为i的回文还没有匹配，只有通过循环去匹配了。实现这里就直接用Java代码实现了，每一次算出当前位置的回文长度后，要更新相关信息： public static String longestPalindrome(String s) { if (s.length() &lt;= 1){ return s; } StringBuilder stringBuilder = new StringBuilder(&quot;$&quot;); for (char c : s.toCharArray()) { stringBuilder.append(&quot;#&quot;); stringBuilder.append(c); } stringBuilder.append(&quot;#&quot;); String str = stringBuilder.toString(); int id = 0; int idMax = 0; int index = 0; int maxLength = 0; int p[] = new int[str.length()]; for (int curr = 1; curr &lt; str.length(); curr++) { int j = 2 * id - curr; // p[curr] = idMax &gt; curr ? Math.min(p[symmetryId], idMax - curr) : 1; // 更容易理解的写法 if (idMax &gt; curr) { if (p[j] &lt; idMax - curr) p[curr] = p[j]; else p[curr] = idMax - curr; } else { p[curr] = 1; } while (curr + p[curr] &lt; str.length() &amp;&amp; str.charAt(curr + p[curr]) == str.charAt(curr - p[curr])) { p[curr]++; } if (curr + p[curr] &gt; idMax) { id = curr; idMax = curr + p[curr]; } if (p[curr] &gt; maxLength) { maxLength = p[curr]; index = curr; } } return s.substring((index - maxLength) / 2, (index + maxLength) / 2 - 1); }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java设计模式中类的关系总结]]></title>
      <url>%2F2016%2F08%2F08%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[概述在面向对象设计模式中，类与类之间的关系存在6中，分别为：依赖、关联、聚合、组合、继承和实现，它们的耦合度依次增强。下面我们在Java中讨论它们的定义和特点。 汇总 关系 定义 UML图例表示 赋值方式 例子 依赖（Dependence） 类A中使用了类B，其中类B作为类A中方法的参数、方法中的局部变量或者静态方法的调用 无 无 关联（Association） 单向：类A中使用了类B作为成员变量。双向：类A当中使用了类B作为成员变量；同时类B中也使用了类A作为成员变量。类A类B无任何关系 类中赋值 车和房 聚合（Aggregation） 关联的一种，类A和类B存在包容关系，但相互是可以独立的（整体-个体） set方法 人（车和房） 组合（Composition） 关联的一种，类B是类A的一部分，类B不能单独存在（整体-部分），整体代表了部分的生命周期 构造方法中 人（灵魂和肉体） 继承（Generalization） 子类和父类的关系，子类是具有父类的属性和行为，并且扩展了新的能力 无 无 实现（Implementation） 实现一个或多个接口方法的类 无 无 注意1：判断关系通过语义，然后结合上下文判断。 注意2：UML图例的箭头指向。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java异常详解]]></title>
      <url>%2F2016%2F06%2F07%2FJava%E5%BC%82%E5%B8%B8%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[异常和错误首先，我们需要重塑对异常和错误的理解，在我们的程序中，不存在所谓的“异常”，只存在错误，错误会导致我们的程序在运行期无法继续运行，如除数为零、尝试打开不存在的文件、试图使用指向为空的对象引用……如果是上述任意一个情形发生，那么我们的程序都将无法继续运行，当然这些错误都是可以通过编码避免，但如果某一个方法的功能就是实现除法的功能，这个方法无法控制不接受获取除数为零的意外，也无法处理当接收到除数为零时的情况，那么这个时候，你需要从当前环境中抛出一个异常，通知其他环境，这里发生了一个问题，我无法处理，我将它交给你处理（不然程序就中止了）。到这里，大家大概知道了Java中的异常和问题的关系了，异常是Java为了解决在出现问题时发出的一个通知，这个通知到达它该到达的地方，然后在这个地方得到解决，然后使程序继续向错误发生时的情况运行。 Java中的异常结构图Java异常类结构图 ErrorError用来表示编译时和系统错误，一般我们不用关心，这里再重申一个概念，异常是发生错误时被抛出的一个通知，所以Error是在编译时和系统错误时被抛出的异常。 Exception这是我们需要关心的异常，因为当这些异常抛出时，说明了我们程序出现了问题，我们需要处理这些问题。Exception又分为不检查异常和检查异常： 不检查异常 public void method(String s) { if(s == null) throw new NullPointerException(); } 首先，我们在代码中不会写这样的代码，因为这样的情况在我们的中可能数不胜数，如果都需要我们去手动的抛出异常，那么我们的代码会很难维护，那么当出现使用了指向空的引用时，系统会自动帮你抛出，所以我们不用手动抛出所有RuntimeException类型（它的子类）的异常。 其次，当有方法会抛出RuntimeException类型的异常时（系统自动抛出），我们不需要去捕获它（try-catch），所以这类异常被称为`不检查异常`。有经验的大家会知道，往往我们的程序的问题就是出现在这些不被检查的异常，如NullPointerException（经常在一些群中发现新手贴出空指针异常，然后求助……）。所以正因为RuntimeException类型的异常不用我们去捕获，因此我们在Code的时候一定要注意防止RuntimeException的发生。 #### 检查异常 这一类异常抛出时，我们必须去捕获它，如SQLException、XMLStreamException等异常。至于说如何处理，根据具体的业务逻辑来编写处理的代码，那么接下来我们来看看Java中是如何设计异常处理的。 ## 捕获异常 ### 监控区域 如果在方法内部抛出了异常或者在方法内部调用的其他方法抛出了异常，这方法将在抛出异常后终止，如果不希望方法就此终止，那么在方法内设置一个特殊的块来捕获异常，所以称为`try块`： try { // Code that might generate exceptions } ### 异常处理程序 再次强调一下，不被检查的异常编译时不会强制让我们捕获，所以需要大家自己注意这些异常。抛出的异常需要在某处得到处理，这个“地点”就是`异常处理程序`，而且在Java中，针对捕获到的不同异常，有不同的处理程序： try { // Code that might generate exceptions } catch(Type1 t1){ // Handle exceptions of type1 } catch(Type2 t2){ // Handle exceptions of type2 } catch(Type3 t3){ // Handle exceptions of type3 } 当发生异常事时（监控区域抛出异常），Java异常处理机制将负责搜寻catch中与异常类型相匹配的第一个处理程序，进入这个catch块，也就是说只有匹配的catch字句才能执行，即便是下面还有匹配的类型（为什么下面还会存在匹配的类型，因为类继承原因，下面还存在父类的异常），也不会执行，具有唯一匹配性。Java的这种异常捕获、处理的模式，可以很好的将正常的代码和出现问题时处理的代码分开，而不是混在一起。 ### finally 有一些代码，无论try中是否抛出异常，它们都能得到执行，这就是`finally字句`的作用。 try { // Code that might generate exceptions } catch(Type1 t1){ // Handle exceptions of type1 } catch(Type2 t2){ // Handle exceptions of type2 } catch(Type3 t3){ // Handle exceptions of type3 } finally { } 无论放生了什么，finally字句始终都会执行，即便是你在try或catch中加入了continue、break或者return。 #### finally用来做什么 Java中主要通过finally把资源恢复到它们的初始状态，如：已打开的文件或网络链接等，总言之，就是与外界“世界”的某个开关。这里有一个原则，就是在产生了一个必须被清理的对象之后，立即进入一个try-finally语句块，为什么会是在之后而不是把这个对象初始化也放进这个try中呢，因为finally总会执行，就会导致可能去做了释放没有被初始化的对象，这样会出现不良的代码结构。 ### 终止模式 Java对于异常的处理采取的是`终止模式`，一旦发生问题，程序将不能继续执行，与之对应的是`恢复模式`，就是当异常抛出时，程序能够继续执行，而不是终止。在Java中如果我们要使用恢复模式，就需要将try块放在while循环中，直到满意，但这明显是不靠谱的，也是我们不提倡的。所以当当前方法终止时，我们只能在异常处理块中使程序向不同的方向继续执行，而具体向什么方向，取决于具体的实现。 ## 异常说明 `异常说明`属于方法说明的一部分，紧跟在参数列表之后： void method() throws IOException{ //………… } 如果某个方法有了异常说明，我们在使用的时候就必须捕获它，即使可能该方法根本不可能真实的抛出过该异常。当然，必须捕获的情况还要除去RuntimeException类型的异常（它的所有子类），因为他是不检查异常，即便是我们加了RuntimeException类型的异常说明，也是可以不去捕获的，所以我们加RuntimeException类型的异常说明是多此一举的（特别是对于不能看到方法源码的情况下）。 ### 继承中的方法说明限制 在继承了某个类时，如果父类中某个方法（public或者protected）有异常说明，子类在覆盖方法时，异常说明只能是父类的一样的异常说明或者无异常说明，不能添加父类方法没有的异常说明。还有一个特殊情况，一个类的父类方法和接口方法同名，而且都添加了异常说明： class A { void a() throws XPathException { } } interface B { void a() throws DataFormatException; } class AB extends A implements B { @Override public void a() {} // public void a() throws XPathException {} 不能编译 } 这种情况该方法不能添加任何异常说明。 ## 异常类型 Java中已存在许多定义好的异常类型供我们使用，可通过查看[Java文档](http://tool.oschina.net/apidocs/apidoc?api=jdk_7u4)查看，我们可以自己定义异常类，就必须从现有的异常类继承。那我们先来看看Throwable类相关的方法。 ### 方法汇总 直到Java1.7，Throwable提供了4个公开的(public)和1个自身和子类可以访问（protected）的构造方法： // 构造方法 // public Throwable() Throwable(String message) Throwable(Throwable cause) Throwable(String message, Throwable cause) // protected Throwable(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) addSuppressed(Throwable exception) fillInStackTrace() getCause() getLocalizedMessage() getMessage() getStackTrace() getSuppressed() initCause(Throwable cause) printStackTrace() printStackTrace(PrintStream s) printStackTrace(PrintWriter s) setStackTrace(StackTraceElement[] stackTrace) toString() 接下来通过一些例子来看看部分方法的使用： ### 方法使用例子 public class Test { public static void main(String[] args) { try { throw new Exception("My Exception"); } catch (Exception ex) { System.out.println("getMessage(): " + ex.getMessage()); System.out.println("getLocalizedMessage(): " + ex.getLocalizedMessage()); System.out.println("toString(): " + ex.toString()); System.out.println("printStackTrace(): "); ex.printStackTrace(System.out); } } }/* Output: getMessage(): My Exception getLocalizedMessage(): My Exception toString(): java.lang.Exception: My Exception printStackTrace(): java.lang.Exception: My Exception at com.exercise.Test.main(Test.java:13) *///:~ 在不改写getLocalizedMessage()方法时，getLocalizedMessage()和getMessage()获取的都是使用了带有参数的构造方法传入的信息，如上列为“My Exception”。toString()方法包含了getMessage()方法的信息，printStackTrace()方法则包含了toString()方法的内容，printStackTrace()方法打印的的是此异常调用栈的轨迹，显示了把你带到异常抛出点的方法调用序列，可以根据类名和行号具体定位。接下里我们结详细介绍一下printStackTrace()打印的栈轨迹。 ### 栈轨迹 printStackTrace()提供的信息可以通过getStackTrace()方法获取到更详细的内容，该方法将返回一个数组，由栈轨迹元素(StackTraceElement)构成，每个元素表示栈中的一桢，元素0是栈顶元素，是方法调用序列中最后一个方法调用，也就是在这个方法中创建或抛出了异常。数组中最后一个元素（栈底）是调用序列中的第一个方法调用。如下： public class Test { static void methodOne() { try { throw new Exception(); } catch (Exception e) { for (StackTraceElement stackTraceElement : e.getStackTrace()) { System.out.println(stackTraceElement.getMethodName()); } } } static void methodTwo() { methodOne(); } static void methodThree() { methodTwo(); } public static void main(String[] args) { methodOne(); System.out.println("------------分割线------------"); methodTwo(); System.out.println("------------分割线------------"); methodThree(); } }/* Output: methodOne main ------------分割线------------ methodOne methodTwo main ------------分割线------------ methodOne methodTwo methodThree main *///:~ 此例只打印了方法名，还可以通过StackTraceElement答应更多的信息。其他方法不会专门为了介绍它而介绍，注意下面的内容，会不断地提到其他的方法。 ## 重新抛出异常和异常链 有时我们在捕获到异常后，可能在捕获的地方不适合处理该异常，我们需要将它重新抛出： catch(Exception e){ throw e; } 这样有一个好处，我们可以将异常交给上一级环境处理，但是这样就会存在一个问题，抛出的的异常携带的信息，也就是printStackTrace()方法显示的是原来异常抛出点的调用栈信息，而非重新抛出点的信息，这样重新抛出点的调用信息就被掩盖了。如果想更新重新抛出点信息到这个异常调用栈中，就可以使用fillInStackTrace()方法： catch(Exception e){ throw e.fillInStackTrace(); } 那么当前调用栈的信息就更新到了这个异常对象中了，还有一种情况，也会存在类似的丢失现象： catch(Exception e){ throw new Exception(); } 这样我们上一级的抛出的异常信息就丢了，接收异常的地方就是只能得到`new Exception()`这个异常的信息。在JDK1.4以前如果你希望保存丢失的那个异常信息，只能通过编码的方式自己实现，而在JDK1.4后，Throwable类有一个构造方法接收一个Throwable类型的参数（文章上方`方法汇总`可以查看该构造方法）。那么这个传入的参数称为`cause`，它用来表示原始异常，那么就可以通过异常链从新的异常追踪到异常最初发生的位置。除了构造方法，我们还可以通过initCause(Throwable cause)方法传入一个Throwable对象，它的作用和构造函数传入一个Throwable对象是一样的。大家还记得之前介绍过finally字句吗？，它其实也会造成异常丢失： class VeryImportantException extends Exception { @Override public String toString() { return "A very important exception!"; } } class OtherException extends Exception { @Override public String toString() { return "Other exception"; } } public class Test { void f() throws VeryImportantException { throw new VeryImportantException(); } void dispose() throws OtherException { throw new OtherException(); } public static void main(String[] args) { try { Test test = new Test(); try { test.f(); } finally { test.dispose(); } } catch (Exception e) { System.out.println(e); } } }/* Output: Other exception *///:~ 我们把最外一层try看着是上一级程序的处理，在这个try里面发生了两次异常，但是我们只能获得从finally中抛出的异常信息，而在f()方法中的异常信息丢失，这种情况我们称上一个`异常被抑制了`。这在JDK1.7之前同样需要我们自己编码去解决这个问题，在JDK1.7之后，新加入了两个方法帮助我们能够很好的去解决这个问题了，那就是addSuppressed(Throwable exception)和getSuppressed()，对于上述问题的解决： class VeryImportantException extends Exception { @Override public String toString() { return "A very important exception!"; } } class OtherException extends Exception { @Override public String toString() { return "Other exception"; } } public class Test { void f() throws VeryImportantException { throw new VeryImportantException(); } void dispose() throws OtherException { throw new OtherException(); } public static void main(String[] args) { try { Test test = new Test(); Exception exception = null; try { test.f(); } catch (VeryImportantException e) { exception = e; } finally { try { test.dispose(); } catch (OtherException e) { if (exception != null) { exception.addSuppressed(e); } else { exception = e; } } if (exception != null) { throw exception; } } } catch (Exception e) { System.out.println(e); for (Throwable throwable : e.getSuppressed()) { System.out.println(throwable); } } } }/* Output: A very important exception! Other exception *///:~ ## Throwable JDK1.7新特性补充 ### 同时捕获多个异常 try { Integer.parseInt("Hello"); } catch (NumberFormatException | RuntimeException e) { } 这种情况不能将RuntimeException放在首位，编译不能通过。 ### try-with-resources 之前我们释放资源的需通过finally，但在JDK1.7后，可以使用try-with-resources方式，它可以实现自动释放功能，而不需要加上finally子句。需要做的就是将需要释放的资源对象放在try语句： public String read(String filename) throws IOException { try (BufferedReader reader = new BufferedReader(new FileReader(filename))) { StringBuilder builder = new StringBuilder(); String line = null; while((line=reader.readLine())!=null){ builder.append(line); builder.append(String.format("%n")); } return builder.toString(); } } 并且可以放入多个需要释放的资源： public void copyFile(String fromPath, String toPath) throws IOException { try (InputStream input = new FileInputStream(fromPath); OutputStream output = new FileOutputStream(toPath)) { byte[] buffer = new byte[8192]; int len = -1; while ((len = input.read(buffer)) != -1) { output.write(buffer, 0, len); } } } 关于Java的异常就介绍到这里，希望大家能支持，你的支持是我继续前进的不断动力！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[泰国曼谷、苏梅岛8日游]]></title>
      <url>%2F2016%2F06%2F07%2F%E6%B3%B0%E5%9B%BD%E6%9B%BC%E8%B0%B7%E3%80%81%E8%8B%8F%E6%A2%85%E5%B2%9B8%E6%97%A5%E6%B8%B8%2F</url>
      <content type="text"><![CDATA[行程时间安排 时间 地点 安排 03-28 成都东-永川 与老友小聚 03-29 永川 茶山竹海半日游 03-29 永川-重庆江北机场 搭乘到曼谷飞机 03-29 曼谷 入住Tara Place 03-30 曼谷 曼谷一日游（大皇宫、四面佛） 03-30 曼谷-南园岛 搭乘Lomprayah公司车船联运前往南园岛 03-31 南园岛 到达入住南园岛、潜泳 04-01 南园岛-苏梅岛 入住Code Hotel 04-02 苏梅岛 环岛 04-03 苏梅岛 换酒店入住Rajapruek Samui Resort 04-04 苏梅岛-曼谷 搭乘亚航联运前往曼谷，入住Asias Boutique Club /The homestays 04-05 曼谷-重庆江北机场 购买动车票回成都 04-05 重庆-成都 回到成都 为什么又是苏梅岛这是第二次去苏梅岛了，很多朋友知道了都问为什么又去泰国？！又是苏梅岛？！首先选择去泰国是因为机票很便宜，往返1098元/人。第一次去泰国时单身汪一枚，也是我第一次出国旅游，有了女朋友后，不想让她错过我去过的地方。虽然和女朋友也已经去过一些地方，但是这种长时间、出国的度假还是第一次，而且是自由行，所以选择了比较熟悉的苏梅岛。 详细行程三月二十九日一高中好哥们在永川定居了，也是借这次要去重庆路过永川的机会，小聚了一下，他带我们去了《十面埋伏》的拍摄地茶山竹海。 十面埋伏 竹海中午下山吃完饭，坐车前往江北机场，从永川到重庆江北机场留了2个小时，但是差点误了飞机~ 18:50准时起飞 3个小时后准时到达曼谷 入住的酒店 选择这个酒店的主要原因是因为离考山路比较近，因为第二天要在考山路坐车船联运去南苑岛，然后这个酒店的评价还不错。入住后，整个酒店很干净，然后前台有24小时中文服务，进门左手有一个小桌子，上面有一些小吃、饮料和咖啡，小吃的味道还是很不错的。如果在考山路一带活动，这个酒店是很不错的选择。 三月三十日Lomprayah是在晚上，所以今天安排了曼谷一日游，选择了大皇宫和四面佛，起床后退了房，把行李寄存到酒店（免费），然后坐头天晚上在酒店预定好的免费突突车去大皇宫了。 然后故事开始了，本来打算在大皇宫周围先转转，没一会遇到一个很热情的大叔，很有激情的给我们介绍着，大概意思是说现在大皇宫还没开门，建议我们先去坐船，然后帮我们叫了一个突突车，很便宜，20泰铢就把我们送到了河边，坐船是1200泰铢一个人，当时想了一会，到底坐不坐呢？最后还是决定坐一次，但是到了船上以后，想想就发现有点不太对劲，有点怀疑刚才那个大叔，心里就有点不太美丽了~ 下了船，就前往大皇宫了，里面人山人海，而且大多数都是中国旅行团，本来是打算买票进大皇宫参观的，但是还在刚才被坑的坏心情当中，所以买了个冰棍坐了一会就走了，打车前往四面佛。 到了四面佛，开始买香火拜佛，又一件不太开心的事情发生了，被外面的小贩坑惨了，拜完佛以后，小哥还硬要了300泰铢的小费，在结合介绍坐船的大叔那件事，此刻的我对泰国的印象从第一次来后的好评变成了差评，不过这个印象在我离开泰国的最后一天又被刷新了，后面会介绍。也在这提醒大家，去四面佛拜佛时，千万不要在外面购买香火，那怕你已经把价格讲到最低了！直接进去，在里面购买，价格是最合理的。拜完佛差不多也就快天黑了，然后打了个的回酒店，然后在Tripadvisor上选择了酒店附近排名第一的、在整个泰国排名第64位的纯素泰国餐馆：May Kaidee Samsen - Vegetarian Restaurant 然后随便逛了逛，就回到酒店了，因为退了房，所以就在酒店大厅里的沙发上休息，蹭着免费的WiFi，还下了几集《欢乐喜剧人》，晚上坐夜车的时候打发时间，酒店落地窗上有很多小壁虎 时间差不多了，拿上行李准备前往考山路坐长途汽车了，这次去苏梅岛选择的是坐Lomprayah的车船联运（比较便宜），然后从苏梅岛回来是坐亚航的飞机，不过也要坐船加大巴到机场，只是时间比较Lomprayah的要少一点，至于Lomprayah如何订票和安排，推荐看看这篇攻略写得比较详细。夜班车开始，这个大巴大概要从晚上9点到第二天早上6、7点左右，是从曼谷到春蓬的一个码头 三月三十一日早上天还没亮就到了，要在码头上等天亮再上船出发，这就是到了海边了，天没亮时可以听听海浪声，早上还可以看日出，大概早上9点左右，开始检票上船 上船以后就没什么可讲的了，因为女朋友晕船了，这也是我这次旅程中没有考虑好的一点，以后再也不选择这种船了，晕到开始吐，但我不知道她是什么时候还在船尾拍了一张 船要到达是南苑岛，南苑岛是苏梅岛一个附属小岛屿，是被一个日本人买了的，在泰国，这个岛就永久属于这个日本人了，这个岛很小很小，但是上岛有限制，如果你没在上面预定住宿，就要给上岛费，而且不能携带垃圾上岛，如果要在上面住，需要提前预定，相对于住宿的环境和配备：小贵，可以在某宝上搜索，也可以进他们的官网预定，推荐某宝，因为官网有很多房型，不知道怎么选择，某宝上可以咨询着预定，而且价格好像还便宜一点 酒店是独栋的，在小山上，山上有很多树。所以蚊子很多，备好驱蚊液，南苑岛水很清，可以自己潜浮，潜浮可以看到各种鱼，因为是私人岛，和住的一样，吃的也没有选择，味道一般。白天潜浮了一会就回房间睡觉了,这个时间段海里的珊瑚特别多，特别硌脚，不像上次11月份来的时候，整个沙滩都是很柔软的。一直到天黑，下去吃了点饭，拿了两瓶啤酒，在沙滩的躺椅上聊聊人生 四月一日早上起床以后就准备前往此次的最终目的地苏梅岛，方式也是坐船，女朋友又要开始晕船了，船票也是和之前的票在Lomprayah上预定的 到了以后，买了他们的接送服务，上岸以后直接送到你的酒店，酒店是之前已经订好了的，两天，名字叫Code Hotal，位置一般，不过酒店整体还是不错的，完全可以整天待在里面，好好度假休息，下面前三张张是酒店主页上的，后面是自己拍的 四月二日到了酒店后就开始休息了，晚上下去711买了点东西，在附近吃了点东西，有点远，最好找酒店借辆自行车，是免费的，然后就一直待在酒店到第二天。酒店是免早的，早餐很丰富，待在酒店一直到下午，酒店提供摩托租赁服务，一天好像是60RMB（24小时），然后租了一辆摩托车开始环岛，太阳非常毒，所以一定记得涂上防晒霜。本来打算去祖父石、祖母石那个景点看看，但是用导航走了很远都没有找到，最后就在附近的沙滩上转了转 中午去苏梅岛上一个在国内排行评价第一的大排档吃海鲜-米特拉苏梅大排档 （Mitra Samui Restaurant），味道还行，服务也还可以，价格也不贵，喜欢吃海鲜但是又不想太奢侈的可以考虑，而且这里来的大部分都是中国人，还能用支付宝支付，店里的服务员也会中文 环岛结束以后，回酒店休息了一下，又在Tripadvisor找了一家排名第一的餐厅，是吃欧洲菜的，因为不是自己的口味，所以就不评价味道了，但是老板娘很热情，给我们不断地翻译介绍 四月三日这一晚后我们会换一个酒店，是在这个岛上最后一个酒店，这个酒店离我们离开这个岛的码头非常近，只有5公里，挨着海滩，但是环境一般，吃的也一般，而且酒店人很少，有点阴冷的感觉 四月四日第二天回曼谷，先坐船，再汽车到机场，飞机再到曼谷，到了曼谷都大概中午了，天气很热，这家酒店在网上的评分很高很高，入住以后，的确，如果不是因为这个酒店，我们就会丢失我们的手机再也找不回，怎么回事呢？下面慢慢说，这家酒店的名字叫亚细亚精品俱乐部/民宿住宿加早餐旅馆 Asias Boutique Club /The homestays，离机场很近，强烈推荐！ 酒店能收到所有的国内频道，没错，是所有的。在酒店吃了点东西，然后就准备去市区购物，还记得之前说过四面佛的遭遇吗？我们打车又经过了四面佛，然后我心里还是很不爽，就说了一句：我下车去收拾一下他们。然后我女朋友就说，你不要在佛面前说这种话，果然，悲剧的事情发生了，下出租车时，手机掉在车上了，刚走进商场就发现了，因为我女朋友手机是电信的，在泰国不能使用，就找了一个中国同胞，借了一个手机，电话是通的，但是没人接听，还抱有一丝希望，然后想起酒店在临走时给了我们一个地图卡片，上面有酒店的位置和电话，是为了方便我们打车回去，再来苹果手机有一个丢失模式，然后我就用我女朋友的手机上了网，登录到查找我的iPhone，辛亏我的手机3G一直是打开的，在上面留了一条信息，电话是酒店的 过了一会，给酒店打电话，酒店说那个司机已经给酒店回了电话了，还是很激动，这个过程中，因为一直开着丢失模式，所以能够知道手机的定位，出租车司机是一个老人家，年龄66了，在这个过程当中一直还在城里跑，其实心里还是相信，他会把手机送回酒店。当时在市区草率的买了一点小东西，就又打车回酒店了，然后酒店的人说他会把手机送回来，只是可能会晚一点，我们一直都没回房间，在酒店的大厅里等着，一直等到晚上11点多，老人家把我们的手机送回来了，我们之前就想好了，过来往返费用还有一些小费，总共给老人家1000泰铢，但是老人家最后死活只收了500，这个时候，泰国给我的印象又好了，最后仔细想一想，其实不管在哪里，都有一部分人会因为生活而做一些不该做的事情，我们在旅游时，需要理智，平心而论，泰国整个国家的人的素质都是非常好的，他们的交通、他们每个人的朴实，整体上是超过国人的 四月五日手机找回来了，但是就没有购物了，回国后女朋友也说了很久，不过的确是因为我的一些小问题导致的，以后一定要做好所有准备，精确到小时，不然真的会出很多问题，还有旅游的一些坑都需要提前了解和时刻的理智，期待下一次旅行吧！回国……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[编辑距离及算法实现]]></title>
      <url>%2F2016%2F03%2F08%2F%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E5%8F%8A%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[简要各位一定体验到过搜索引擎的纠错功能，当你在无意识的情况下将你搜索的内容输入错误时，搜索引擎会自动帮你纠错。如你本来想搜索happy，却不小心按到了y旁边的u，这时我们依然达到了我们想要的目的 那么这个是怎么实现的呢，先不考虑这个功能整体使用到的技术，先解决一个问题，它是怎么知道从happu到happy的，这就是我们今天要讲的编辑距离 概念编辑距离（Edit Distance）又称Levenshtein距离，是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。一般来说，编辑距离越小，两个串的相似度越大。 从happu到happy只是把u替换成了y，操作次数为一次，所以编辑距离为1 运用因此，有了这个概念，当我们知道一个词是错误的时候（怎么知道它错了，后面讨论），就只需从正确的词中找出和它编辑距离最小的一个或多个，就可以帮助用户纠错了 如何计算编辑距离比如要计算cafe到coffee的编辑距离 先创建一个6x8的表（cafe长度为4，coffee长度为6，各加2）,先在表中如下位置填入相应数字 0 0 c o f f e e 0 0 1 2 3 4 5 6 c 1 o 2 f 3 e 4 再从c到c对应的表格，也就是表格的（3，3）位置开始，按照以下规则填充数字 如果最上方的字符等于最左方的字符，则为左上方的数字。否则为左上方的数字+1。（对于3,3来说为0） 左方数字+1（对于3,3格来说为2） 上方数字+1（对于3,3格来说为2） 取上面得出的三个数字中最小数字填入（3，3）位置，根据上面得出的，最小为0，所以在（3，3）位置填入0，以此类推，完成所有空格的填充，如下 0 0 c o f f e e 0 0 1 2 3 4 5 6 c 1 0 1 2 3 4 5 o 2 1 1 2 3 4 5 f 3 2 2 1 2 3 4 e 4 3 3 2 2 2 3 取得表中右下角数字，既为cafe和coffee的最小编辑距离，为3 Java代码 public static double ld(String s, String t) { int d[][]; int sLen = s.length(); int tLen = t.length(); int si; int ti; char ch1; char ch2; int cost; if(sLen == 0) { return tLen; } if(tLen == 0) { return sLen; } d = new int[sLen+1][tLen+1]; for(si=0; si&lt;=sLen; si++) { d[si][0] = si; } for(ti=0; ti&lt;=tLen; ti++) { d[0][ti] = ti; } for(si=1; si&lt;=sLen; si++) { ch1 = s.charAt(si-1); for(ti=1; ti&lt;=tLen; ti++) { ch2 = t.charAt(ti-1); if(ch1 == ch2) { cost = 0; } else { cost = 1; } d[si][ti] = Math.min(Math.min(d[si-1][ti]+1, d[si][ti-1]+1),d[si-1][ti-1]+cost); } } return 1 - (double) d[sLen][tLen] / Math.max(src.length(), tar.length()); }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[搭建Hexo静态博客]]></title>
      <url>%2F2016%2F03%2F07%2F%E6%90%AD%E5%BB%BAHexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[概述开源项目Hexo是由Node.js完成，所有源码位于GitHib上，可以使用它搭建自己的静态博客网页。很重要的一点，该框架可以使用轻量级标记语言Markdown编辑文章，可参考Markdown入门资料 环境搭建(OS X)Node.js访问Node.js官网下载对应版本并安装 Hexo$ npm install hexo -g –no-optional –svaeHexo 3.0以后直接使用此命令，不然使用命令时可能会产生一些警告，-g是表示全局安装，--no-optional为了防止刚才提到的一些警告。 Git安装Xcode后会默认安装git，如还未安装git，可自行搜索安装，这里就不再赘述。 初始化Hexo进入你想存放文件的目录，如我是在/Document/hexo/blog下，命令进入到相应目录下，执行： 1 $ hexo init2 $ npm install启动本地服务器 $ hexo s浏览器打开http://localhost:4000，至此本地的静态网页博客已经搭建成功，那么如何让其他人也能够访问到呢，我们需要将他部署到GitHub上 部署到GitHub前提申请GitHub社区账号，并新建新的Repository，注意Repository的名字一定要遵守用户名.github.io，如图是我的 配置在本地的静态博客根目录下，找到_config.yml文件，找到deploy关键字，根据自己新建的Repository修改为如以下配置 deploy: type: git repo: git@github.com:Jucongyuan/Jucongyuan.github.io.git branch: master部署到GitHub，在博客根目录下执行以下命令 1 $ hexo clean2 $ hexo generate3 $ hexo deploy 注意事项由于采用的SSH，所以需要在本地生成SSH Key，可参照GitHub官网 访问你的http://用户名.github.io，至此完成整个搭建过程 Hexo可以配置不同的主题，如本博客采用的是国内的一个主题NexT，在该主题上可以在博客中增加其他如分享、搜索、评论等其他第三方功能和自定义样式主题，更多请访问NexT]]></content>
    </entry>

    
  
  
</search>
