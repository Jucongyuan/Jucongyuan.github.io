<?xml version="1.0" encoding="utf-8"?>
<search>
  
    
    <entry>
      <title><![CDATA[《数据库原理》三章读书笔记]]></title>
      <url>%2F2017%2F02%2F28%2F%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E3%80%8B%E4%B8%89%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[结构化查询语言结构化查询语言(Structured Query Language)简称SQL，由IBM开发，并被美国标准制定委员会（ANSI）定位国家标准。SQL命令可以分为几大类，今天主要介绍其中两类，数据定义语言DDL(data definition Language)和数据操作语言DML(Data Manipulation Language)。 数据定义语言DDLDDL用于创建和改变数据库结构 注：本文使用的数据库系统为MySQL和SQLite，相关环境请自行搭建 创建数据库命令：CREATE DATABASE demo; 在SQLite的命令行中，直接使用sqlite3 demo可以直接创建和使用名字为demo的数据库。打开MySQL可视化工具MySQLWorkbench，创建一个名为demo的数据库。 创建数据表 CREATE TABLE NewTableName( ColumnName DataType OptionalConstraint, ColumnName DataType OptionalConstraint, ColumnName DataType OptionalConstraint, optional table constraint ); NewTableName为表名，ColumnName为数据表中的列名，也就是字段名，DataType为该列的数据类型，OptionalConstraint为该列的数据约束，是可选的，常见的数据约束有：PRIMARY KEY，NULL，NOT NULL，UNIQUE，FOREIGN KEY。optional table constraint为表约束，可以定义表的主键和参照完整性约束等。SQLite数据类型可以查考这里。MySQL的数据类型可以查考这里。现在我们在刚才的demo数据库中创建四个Table，MySQL语句如下： 下载以上SQL SQLite语句如下： 下载以上SQL CHAR和VARCHAR都是表示字符，但是CHAR是固定长度的，括号内可声明最大长度，存储时不能超过最大长度，而无论比最大长度少多少，存储时都存储最大长度，不足用空格代替。而VARCHAR存储的长度是可变的，根据实际的长度存储，不过这就需要额外的空间来存储它的长度，才能在内存或者硬盘中组织不定长度的值。 NUMERIC(5, 2)表示带两位小数的八位数字，如果插入数据位123.34，则该数据存储为12334，不会存储小数点。 CONSTRAINT XX_PK 和CONSTRAINT XX_FK都为约束名，一个是主键的约束名称，一个是外键的约束名称，习惯性用表名加PK表示主键，表名加FK表示主键，定义这个约束名是为了方便以后对数据库的操作，比如删除某个表的主键。 CONSTRAINT ASS_PRO_FK FOREIGN KEY (ProjectID) REFERENCES PROJECT(ProjectID) ON UPDATE NO ACTION ON DELETE CASCADE解释：定义一个约束名为ASS_PRO_FK的外键ProjectID，这个外键关联到PROJECT表中的主键ProjectID，当更新时，外键不做任何处理（实际上该ProjectID在PROJECT中永远不会更新，因为它是自增长的），当删除PROJECT某一行时，同时也删除所有在ASSIGNMENT中ProjectID为同样值的数据。然后再看CONSTRAINT ASS_EMP_FK FOREIGN KEY (EmployeeNumber) REFERENCES EMPLOYEE(EmployeeNumber) ON UPDATE NO ACTION ON DELETE NO ACTION，更新EmployeeNumber时没有操作，原因同样是EmployeeNumber是不会变的，但是当删除一个Employee时，就和上面不一样了，这里不会有任何操作，这是什么原因呢？其实这个是和实际的业务规则有关系的，删除一个项目，我们会把项目的所有指派全部删了，因为没有项目的指派是没有意义的。但是如果一个员工离职了，指派还是有意义的，我们可以指派另一个员工嘛，这就是我们的业务规则。NO ACTION是默认的，我们可以不定义，但是一般情况下我们需要显示的展示出来，这是为了生成更好的文档。 数据操作语言DMLDML用于数据的修改操作，包括：插入、修改和删除 插入数据 下载以上SQL SQLite插入数据的SQL和上面一致 插入数据的SQL很好理解，值得注意的是，除了数字类型的数据，其他的在赋值时都需要加引号（普通的、无方向的）。 查询数据从表中读取所有列SELECT * FROM EMPLOYEE; 结果： 从表中读取指定列SELECT FirstName, LastName, Email FROM EMPLOYEE; 结果： 从单个表中读取指定行SELECT * FROM DEPARTMENT WHERE Phone = &#39;360-2858310&#39;; 从单个表中读取指定行和列SELECT DepartmentName FROM DEPARTMENT WHERE Phone = &#39;360-2858310&#39;; WHERE字句WHERE字句中可以使用的条件：=、&gt;、&lt;、&gt;=、&lt;=、!=、IN、NOT IN、BETWEEN AND、IS NULL、IS NOT NULL、LIKE，这些条件的判断都很容易理解，条件右边的值同样是除了数字以外，都需要加引号。LIKE和通配符符配合使用，通配符有_和%，前者表示一个未指定的字符，后者表示一个或多个为指定的字符。使用BETWEEN AND时，注意是包括两端的值的。这些条件都可以使用AND和OR连接。 对结果进行排序SELECT * FROM DEPARTMENT ORDER BY BudgetCode; 默认是升序，如果需要降序排列则使用 SELECT * FROM DEPARTMENT ORDER BY BudgetCode DESC; 升序的关键字为ASC。可以使用多个列来排序，用逗号隔开，越靠前优先级越高 SELECT * FROM DEPARTMENT ORDER BY BudgetCode DESC, OfficeNumber; 分页查询SELECT * FROM table_name LIMIT [no of rows] OFFSET [row num] 检索记录行 6-15： SELECT * FROM table LIMIT 5,10; 为了检索从某一个偏移量到记录集的结束所有的记录行，可以指定第二个参数为-1，检索记录行 96-Last: SELECT * FROM table LIMIT 95,-1; 如果只给定一个参数，它表示返回最大的记录行数目： SELECT * FROM table LIMIT 5; 检索前5个记录行，换句话说，LIMIT n等价于LIMIT 0, n。 内置函数和计算内置行数有：COUNT、SUM、AVG、MAX和MIN： SELECT COUNT(DepartmentName) AS DepartmentNum FROM DEPARTMENT; SELECT ProjectName, (MaxHours / 8) AS Day FROM PROJECT; SELECT MIN(MaxHours) AS MinCost FROM PROJECT; 这些函数都是对结果进行计算，一般来说不能用于WHERE字句。 对结果进行分组SELECT Department, COUNT(*) FROM EMPLOYEE GROUP BY Department; 结果按照部门名字分组，别显示出部门名字和该部门的数量，如果要在结果中再继续筛选，可以对组使用HAVING SELECT Department, COUNT(*) AS Number FROM EMPLOYEE GROUP BY Department HAVING COUNT(8) &gt; 2; GROUP BY和WHERE同时使用时，一般将WHERE字句放在前面，所以WHERE先被运行。上面使用了AS，我们使用函数计算的数据列展示时是没有列名的，我们可以通过AS给它指定一个，同样的，即便是有列名的列，我们也可以通过AS给它换一个用于展示的列名，如下： SELECT Department, COUNT(*) FROM EMPLOYEE GROUP BY Department; SELECT Department AS Name, COUNT(*) AS Number FROM EMPLOYEE GROUP BY Department; 使用子查询处理多个表有时我们需要用一个表中的数据作为条件在另一个表中查数据，我们就可以使用子查询 SELECT * FROM EMPLOYEE WHERE Department = (SELECT DepartmentName FROM DEPARTMENT WHERE Phone = &#39;360-2858210&#39;); 在DEPARTMENT中查出电话号码为360-2858210的部门名字，再在EMPLOYEE中查出该部门名字下的所有员工。子查询可以扩展到3层、4层或更多层。 使用内连接连接查询多个表刚才的子查询处理虽然用了多个表，但是最终显示的数据只是来自某一个表，如果我们要显示两个表或者更多表中的数据怎么办？这是我们可以使用join（连接）操作 SELECT FirstName, LastName, HoursWorked From EMPLOYEE AS E,ASSIGNMENT AS A WHERE E.EmployeeNumber = A.EmployeeNumber; 这样就从EMPLOYEE和ASSIGNMENT中分别查处了不同的信息。我们也可以使用JOIN…ON实现上面的查询： SELECT FirstName, LastName, HoursWorked From EMPLOYEE AS E JOIN ASSIGNMENT AS A ON E.EmployeeNumber = A.EmployeeNumber; 外链接通过上面的查询，我们可以产出所有分配了任务的员工在EMPLOYEE和ASSIGNMENT的信息，但是如果想显示没有被分配项目的员工信息怎么办？这个时候我们就可以使用外链接LEFT JOIN…ON，它会连接左边表的所有数据 SELECT FirstName, LastName, HoursWorked From EMPLOYEE AS E LEFT JOIN ASSIGNMENT AS A ON E.EmployeeNumber = A.EmployeeNumber; 同样的，可以使用RIGHT JOIN…ON，这里就不再演示了。 修改数据UPDATE…SET可以修改已有数据，可以通过WHERE指定修改莫一行，SET后也可以修改指定列的值为多少。 UPDATE EMPLOYEE SET Email = &#39;Tom.Cruse@WPC.com&#39; WHERE EmployeeNumber = 3; 删除数据DELETE FROM可以删除行，可以通过WHERE字句指定某行或多行，如删除员工号为1的员工： DELETE FROM EMPLOYEE WHERE EmployeeNumber = 1; 我们删除员工号为3的员工，但是并不能成功，为什么呢？因为在ASSIGNMENT中，该员工已经分配了任务，存在外键的参照完整性约束，所以不能被删除，我们必须将3员工所有分配的任务指派给其他人或者全部删除，才能删除员工3，这与我们的实际情况也是相符的 修改表名RENAME TABLE…TO可以修改表名 RENAME TABLE PROJECT TO OLD_PROJECT; 删除表DROP TableName可以删除表，和上面一样，表中存在任何包含或者可以包含需要实施参照完整性约束的值，删除不能生效。 DROP TABLE EMPLOYEE; 修改表结构使用ALETER TABLE修改表的结构 增加列ALTER TABLE EMPLOYEE ADD Sex INT; 修改列先为所有数据添加一个默认的性别，然后增加Sex不为空的限制 UPDATE EMPLOYEE SET Sex = 1; 我们发现，直接在MySQL中执行此SQL更新所有行并不能成功，因为MySQL默认在安全模式下，不允许这种全局更新，所以我们先修改MySQL的安全模式，执行： SET SQL_SAFE_UPDATES = 0; 再执行上面的SQL，则可以成功更新数据。现在我们修改列，增加一个不为空的约束 ALTER TABLE EMPLOYEE CHANGE Sex Sex INT NOT NULL; 可以看出，这个语句可以修改列名、列数据类型和约束。 删除列ALTER TABLE EMPLOYEE DROP COLUMN Sex; 删除主键或外键前面提到我们一般会给主键和外键定义一个约束名，现在大家应该知道他的作用了，我们可以使用约束名删除主键和外键约束 ALTER TABLE ASSIGNMENT DROP FOREIGN KEY ASS_EMP_FK; 增加主键或外键ALTER TABLE ASSIGNMENT ADD CONSTRAINT ASS_EMP_FK FOREIGN KEY (EmployeeNumber)REFERENCES EMPLOYEE(EmployeeNumber) ON UPDATE NO ACTION ON DELETE NO ACTION; SQLite的ALTER TABLE在 SQLite 中，除了重命名表和在已有的表中添加列，ALTER TABLE 命令不支持其他操作。所有我们在SQLite中更新表名需要使用： ALTER TABLE database_name.table_name RENAME TO new_table_name; 在表中增加列： ALTER TABLE database_name.table_name ADD COLUMN column_def...; CHECK约束在MySQL中，不能使用CHECK约束，而SQLite中可以。那么在MySQL如何限制一些输入值呢，有两种方式，第一种可以使SET和ENUM类型的数据类型： CREATE TABLE TEST( sex ENUM(&apos;F&apos;, &apos;M&apos;) ); INSERT INTO TEST VALUES (&apos;Y&apos;); //执行失败 INSERT INTO TEST VALUES (&apos;F&apos;); //执行成功 ENUM和SET都是比较特殊的字符串数据列类型，它们的取值范围是一个预先定义好的列表。ENUM或SET数据列的取值只能从这个列表中进行选择。ENUM和SET的主要区别是：ENUM只能取单值，它的数据列表是一个枚举集合。它的合法取值列表最多允许有65535个成员。例如：ENUM(“N”,”Y”)表示，该数据列的取值要么是”Y”，要么就是”N”。SET可取多值。它的合法取值列表最多允许有64个成员。空字符串也是一个合法的SET值。ENUM和SET的值是以字符串形式出现的，但在内部，MySQL以数值的形式存储它们。ENUM的合法取值列表中的字符串被按声明定义的顺序被编号，从1开始。在MySQL中另外一中约束的方法就是触发器。 Distinct关键字我们可以使用Distinct消除重复的记录，如： SELECT DISTINCT FirstName FROM EMPLOYEE; SELECT COUNT(DISTINCT FirstName) FROM EMPLOYEE; 后者可以作为一种统计：员工中有多少个不同的名字。 完全连接和交叉连接刚才我们提到了内连接和外连接（包括左连接和右连接），除了内外连接还有完全连接和交叉连接，全连接是在内连接的基础上，在不符合条件的数据上填写NULL，可以理解为左连接加上右连接，使用FULL JOIN关键字。交叉连接是将两个表进行组合，行数为两个表的行数乘积，使用CROSS JOIN关键字。我们用图形表示这些关系就一目了然了：]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[《数据库原理》一二章读书笔记]]></title>
      <url>%2F2017%2F02%2F24%2F%E3%80%8A%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8E%9F%E7%90%86%E3%80%8B%E4%B8%80%E4%BA%8C%E7%AB%A0%E8%AF%BB%E4%B9%A6%E7%AC%94%E8%AE%B0%2F</url>
      <content type="text"><![CDATA[使用数据库的原因单纯的数据表格可以解决我们一般的数据记录需求，但是数据表格会有一些因为增、删、改造成的问题。例如：在一张学校信息表中，有一列记录了学生老师的Email，如果这个老师的Email修改了，我们需要花费很大精力去修改整张表。因此，关系模型的方法就随之诞生，成为了一项解决这些问题的新技术。 关系模型关系是一种特殊类型的表（由行和列组成的二维表），这不和表格一样的吗？从目前信息的确如此，不过这种关系模型的关系必须具备一些特征，因此说关系是一种特殊类型的表。那么关系模型的特征有哪些呢？特征如下： 行包含实体的数据 列包含实体属性的数据 表中的单元格存储单个值 每列的所有实体类型一致 每列具有唯一名称 列的顺序任意 行的顺序任意 任意两行互不重复 所以，和单纯的数据表格不一样，有了这些特征的表格，就为关系表。有一种特殊的情况，就是在实际的应用中，我们的关系表中可能会存在重复的行，这时我们也默认该表也为关系表。 第一范式在数据库设计的过程中，我们的数据库需要满足一些规范，根据不同的程度，要求满足不同的规则，这些规则称为范式，目前的关系型数据库一共有六种方式，对于关系模型的表，它就是满足了我们的第一范式。其它五种范式将在后续介绍，不过要满足后面的范式，必须先满足前面的范式。 表的一些术语 表 行 列 文件 记录 字段 关系 元组 属性 键的类型键的定义：可以用来标识行的一列或多列。也就是说键可以唯一，也可以不唯一。 复合键它包含多个属性（至少两个）的键称为复合键 候选键唯一标识表中每一行的键，获选键可以使单列建，也可以是复合键 主键主键的定义和候选键一样，但是在一个表中，只有一个主键（单列建或者复合键），这个主键就是从候选键中选举出来的 EMPLOYEE (EmployeeNumber, FirstName, LastName, Department, Email, Phone) 在这个表中，可以唯一标识每一行的键有：EmployeeNumber、Email和复合键（FirstName, LastName, Department），一般情况下，我们选择EmployeeNumber键作为主键，这样候选键和主键的概念大家就明白了。那么这个主键是怎么从候选键中选择出来的的呢？也就是选举的规则是怎样的呢？后面我们会提到 代理建TEACHER (Name, Age, Sex) 在这张表中，我们很难选择一个键作为主键，那么此时在实际的操作中，我们会给这张表增加一个字段，来作为它的主键： TEACHER (TeacherId, Name, Age, Sex) 那么这个我们增加的主键，就是代理建，它是主键，但是并不是这个实体的某一个属性，也不会有现实的使用情况。 外键将一个表的值放入第二个表来表示关联，所使用的值是第一个表的主键值(在必要时可包括复合主键值)。此时，第二个表中保存这些值的属性称为外键(foreign key)。例如学生表中一般会存在一个TeacherId，这个TeacherId标识TEACHER表中的一个教师，那么在学生表中的这个TeacherId就是外键，当然，在学生表中这个字段的命名可以不和TeacherId一致，例如也可以是Teacher。如果一个表中存在外键，应该在相应的表中存在对应的主键，这个规则称为参照完整性约束。 表的表示 函数依赖做一个表中，如果其中一个字段可以决定另一个字段的值，那么，我们就说某一个字段依赖于该字段。例如在学生表中，一个学生的身高决定了他穿衣服的大小，那么我就说衣服大小依赖于身高，或者身高决定衣服大小，用表达式表示： Height → Size 对于两边的属性，可以是多个，如： (Quantity, UnitPrice) → ExtendedPrice 一份订单的总结依赖于单价和数量，同样可以一对多和多对多，这里就不再举例了。 从候选键到主键有了函数依赖的概念，我们就可以回答刚才怎么选举的问题了？表的主键可以定义为：该表中一个或多个可以通过函数决定其他所有属性的属性，那么候选键也如此，所以从候选键中选举主键是，我们要选择最有意义和最重要的函数依赖。 规范化在我们创建完表后，可能这个表不是最优的，因为它可能存在一些问题，所以我们必须优化这个表，那么具体的步骤和规则是怎样的呢？这就不得不提到规范了： 在结构良好的表中，每个决定因子都必须是候选键 非结构良好的表应分解成两个或多个结构良好的表 规范化的过程 找出所有候选键 列出所有函数依赖 检查函数依赖的决定因子，如果决定因子不是候选键则需要：a. 把函数依赖的列放在它自己的新表中。 b. 把函数依赖的决定因子作为新表的主键。 c. 将决定因子的副本作为原表中的外键。 d. 在新表和原表之间创建参照完整性约束 重复第三步，直到所有的表都满足条件 规范化的示例EMPLOYEE (EmployeeNumber, LastName, Email, Department, DeptPhone) 1.找出候选键在这个表中，候选键为EmployeeNumber和Email 2.找出函数依赖Department → DeptPhone 3.判断决定因子是否为候选键Department并不是候选键，所以我们需要将函数依赖放入一个新的表中： DEPARTMENT (Department, DeptPhone) 用决定因子Department作为主键，将主键放入前一个表作为外键： EMPLOYEE (EmployeeNumber, LastName, Email, Department) 4.重复3步骤决定因子都为候选键了，规范过程结束，最终表的设计： EMPLOYEE (EmployeeNumber, LastName, Email, Department) DEPARTMENT (Department, DeptPhone)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之享元模式]]></title>
      <url>%2F2016%2F12%2F22%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[这次又需要大量对象 从图片可以知道，小明他们这次要做一个围棋的游戏，其中小明负责的就是围棋棋子的创建，棋子的数量很多，小明第一时间想到了之前游戏的小怪，也是需要大量的对象，所以是不可以用原型模式的，当然不是，我们今天讲的是享元模式！分析一下为什么不是原型模式，原型模式的重要一点是为了快速的产生对象，而产生的新对象和之前的对象在内存中不是指向同一块内存，因为我们本来就是需要大量的不同对象，可能它们的各种状态都不一样。而这次，我们的棋子，颜色、大小和材质都是一模一样，而唯一不一样的就是它们的位置，所以这次，我们需要的是相同的对象，现在我们就用享元模式来实现这个需求 首先定义一个抽象享元类： public abstract class Piece { public abstract String getColor(); public void display() { System.out.println(&quot;棋子颜色:&quot; + getColor()); } } 黑色棋子： public class BlackPiece extends Piece { @Override public String getColor() { return &quot;黑色&quot;; } } 白色棋子： public class WhitePiece extends Piece { @Override public String getColor() { return &quot;白色&quot;; } } 工厂类： public class PieceFactory { private static PieceFactory instance = new PieceFactory(); private HashMap&lt;String, Piece&gt; pieceHashMap = new HashMap&lt;&gt;(); public static PieceFactory getInstance() { return instance; } private PieceFactory() { pieceHashMap.put(&quot;黑色&quot;, new BlackPiece()); pieceHashMap.put(&quot;白色&quot;, new WhitePiece()); } public Piece getPiece(String color) { return pieceHashMap.get(color); } } 使用棋子： public class Client { public static void main(String[] args) { Piece p1 = PieceFactory.getInstance().getPiece(&quot;黑色&quot;); Piece p2 = PieceFactory.getInstance().getPiece(&quot;黑色&quot;); Piece p3 = PieceFactory.getInstance().getPiece(&quot;白色&quot;); Piece p4 = PieceFactory.getInstance().getPiece(&quot;白色&quot;); p1.display(); p2.display(); p3.display(); p4.display(); System.out.println(&quot;p1: &quot; + p1); System.out.println(&quot;p2: &quot; + p2); System.out.println(&quot;p3: &quot; + p3); System.out.println(&quot;p4: &quot; + p4); } } 结果： 棋子颜色:黑色 棋子颜色:黑色 棋子颜色:白色 棋子颜色:白色 p1: com.jucongyuan.testsdk.BlackPiece@1b6d3586 p2: com.jucongyuan.testsdk.BlackPiece@1b6d3586 p3: com.jucongyuan.testsdk.WhitePiece@4554617c p4: com.jucongyuan.testsdk.WhitePiece@4554617c 可以看到，相同颜色棋子的内存地址是一样的，这就是我们的享元模式，我们的棋子就是享元类，另外我们还是用了工厂模式 定义运用共享技术有效地支持大量细粒度对象的复用。系统只使用少量的对象，而这些对象都很相似，状态变化很小，可以实现对象的多次复用 角色 抽象享元类 具体享元类 非共享具体享元类 享元工厂类 非共享具体享元类指的是不被共享的享元类，可以直接使用，没有非共享具体享元类为单纯享元模式，如果有，则为复合享元模式 是否我们的需求还没有完成我们的对象是共用了，但是有一个问题，虽然说所有白色的对象都是一个，所有黑色的也是一样，但是我们要他们的位置不一样啊！这里就不得不提我们享元模式的内部状态和外部状态了，刚才我们的实现，享元类只有内部状态，内部状态是不变的，也是被大家共享的，比如刚才提到过的棋子的颜色、大小和材质，现在我们引入外部状态 先实现一个外部状态类，来表示坐标 public class Coordinates { private int x; private int y; public Coordinates(int x, int y) { this.x = x; this.y = y; } public int getX() { return x; } public void setX(int x) { this.x = x; } public int getY() { return y; } public void setY(int y) { this.y = y; } } 现在，在享元类中加入外部状态 public abstract class Piece { public abstract String getColor(); public void display(Coordinates coordinates) { System.out.println(&quot;棋子颜色：&quot; + this.getColor() + &quot;，棋子位置：&quot; + coordinates.getX() + &quot;，&quot; + coordinates.getY()); } } 再使用一下棋子： public class Client { public static void main(String[] args) { Piece p1 = PieceFactory.getInstance().getPiece(&quot;黑色&quot;); Piece p2 = PieceFactory.getInstance().getPiece(&quot;黑色&quot;); Piece p3 = PieceFactory.getInstance().getPiece(&quot;白色&quot;); Piece p4 = PieceFactory.getInstance().getPiece(&quot;白色&quot;); Coordinates coordinates1 = new Coordinates(3, 6); Coordinates coordinates2 = new Coordinates(4, 5); Coordinates coordinates3 = new Coordinates(1, 5); Coordinates coordinates4 = new Coordinates(5, 5); p1.display(coordinates1); p2.display(coordinates2); p3.display(coordinates3); p4.display(coordinates4); System.out.println(&quot;p1: &quot; + p1); System.out.println(&quot;p2: &quot; + p2); System.out.println(&quot;p3: &quot; + p3); System.out.println(&quot;p4: &quot; + p4); } } 结果： 棋子颜色：黑色，棋子位置：3，6 棋子颜色：黑色，棋子位置：4，5 棋子颜色：白色，棋子位置：1，5 棋子颜色：白色，棋子位置：5，5 p1: com.jucongyuan.testsdk.BlackPiece@1b6d3586 p2: com.jucongyuan.testsdk.BlackPiece@1b6d3586 p3: com.jucongyuan.testsdk.WhitePiece@4554617c p4: com.jucongyuan.testsdk.WhitePiece@4554617c JDK中的享元模式Java中的String就是享元模式，我们用一个例子来看看 public class Client { public static void main(String[] args) { String str1 = &quot;abcd&quot;; String str2 = &quot;abcd&quot;; String str3 = &quot;ab&quot; + &quot;cd&quot;; String str4 = &quot;ab&quot;; str4 += &quot;cd&quot;; System.out.println(str1 == str2); System.out.println(str1 == str3); System.out.println(str1 == str4); str2 += &quot;e&quot;; System.out.println(str1 == str2); } } 结果： true true false false 可以看到，对于字符串abcd，第一次创建后，再次创建是，对象引用会指向第一次创建的内存位置。如果有一个字符串str4，其初值为”ab”，再对它进行操作str4 += “cd”，此时虽然str4的内容与str1相同，但是由于str4的初始值不同，在创建str4时重新分配了内存，所以第三个输出语句结果为false。最后一个输出语句结果也为false，说明当对str2进行修改时将创建一个新的对象，修改工作在新对象上完成，而原来引用的对象并没有发生任何改变，str1仍然引用原有对象，而str2引用新对象，str1与str2引用了两个完全不同的对象]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之责任链模式]]></title>
      <url>%2F2016%2F12%2F22%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[小明公司要做财务ERP系统小明公司随着项目的增多，公司发展得越来越壮大，所以有一些财务上的审批，如果报账的金额在100以下，团队主管直接审批后就可以，如果在100以上5000以下，需要部门经理审批，如果在5000以上，需要公司经理审批。公司想通过线上的方式去将这个流程实现 不出意外，小明负责这个程序的编写，小明这次很谨慎，因为之前做的东西都有一些不足的地方，所以小明再思考了一番后，开始编码去实现了 public class Reimbursement { private float value; public Reimbursement(float value) { this.value = value; } public void handler() { if (value &lt;= 100) handleByLeader(); else if (value &gt; 100 &amp;&amp; value &lt;= 5000) handleByManager(); else if (value &gt; 500) handleByGeneralManager(); } private void handleByLeader() { // 处理省略 } private void handleByManager() { // 处理省略 } private void handleByGeneralManager() { // 处理省略 } } 小明写完后仔细的思考了一下，这个代码存在很多问题，比如不符合单一原则，这个类负责了三个不同的事情。同时，不符合开闭原则，如果新增加一个审批角色，需要修改代码来扩展。但是小明一时也想不到解决办法，于是找到了主管，主管说，这是一个典型的责任链模式，我们可以通过责任链模式来设计这个项目 定义避免请求发送者与接收者耦合在一起，让多个对象都有可能接收请求，将这些对象连接成一条链，并且沿着这条链传递请求，直到有对象处理它为止 用责任链模式来现实首先我们要实现处理类 public abstract class Handler { protected Handler nextHandler; public void setNextHandler(Handler nextHandler) { this.nextHandler = nextHandler; } public abstract void handleRequest(int request); } 团队主管处理类： public class LeaderHandler extends Handler { @Override public void handleRequest(int request) { if (request &lt; 100) { System.out.println(&quot;团队主管处理了&quot;); } else { this.nextHandler.handleRequest(request); } } } 经理处理类： public class ManagerHandler extends Handler { @Override public void handleRequest(int request) { if (request &lt;= 5000) { System.out.println(&quot;部门经理处理了&quot;); } else { this.nextHandler.handleRequest(request); } } } 总经理处理类： public class GeneralManagerHandler extends Handler { @Override public void handleRequest(int request) { System.out.println(&quot;总经理处理了&quot;); } } 然后我们来开始报账 public class Client { public static void main(String[] args) { LeaderHandler leaderHandler = new LeaderHandler(); ManagerHandler managerHandler = new ManagerHandler(); GeneralManagerHandler generalManagerHandler = new GeneralManagerHandler(); leaderHandler.setNextHandler(managerHandler); managerHandler.setNextHandler(generalManagerHandler); leaderHandler.handleRequest(2000); leaderHandler.handleRequest(50); leaderHandler.handleRequest(6000); } } 结果： 部门经理处理了 团队主管处理了 总经理处理了 这样实现后，刚才小明想到的那两个问题也解决了，如果我们现在增加了一个环节，不需要修改请求者的代码，只需要在责任链中加入新的角色即可 纯与不纯的责任链模式纯的责任链模式一个纯的职责链模式要求一个具体处理者对象只能在两个行为中选择一个：要么承担全部责任，要么将责任推给下家，不允许出现某一个具体处理者对象在承担了一部分或全部责任后又将责任向下传递的情况。而且在纯的职责链模式中，要求一个请求必须被某一个处理者对象所接收，不能出现某个请求未被任何一个处理者对象处理的情况。在前面的采购单审批实例中应用的是纯的职责链模式 不纯的责任链模式在一个不纯的职责链模式中允许某个请求被一个具体处理者部分处理后再向下传递，或者一个具体处理者处理完某请求后其后继处理者可以继续处理该请求，而且一个请求可以最终不被任何处理者对象所接收。Android的控件点击事件就是不纯的责任链模式，当点击控件时，Android系统将把事件发送到控件的顶层，然后从控件的顶层开始先下分发，某一层可以将该事件消费掉，也可以继续将该事件向下分发，不过每一层都会对事件进行一些处理]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之解释器模式]]></title>
      <url>%2F2016%2F12%2F21%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%A3%E9%87%8A%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[这次没有小明，我们来做加减乘除现在我们要计算6*(5+(25+15)/8+22)这个表达式的值，大家应该觉得很简单，写一个方法，一步一步计算就是了，这样是可以计算出来这个表达式的结果，那如果换了一个另外一个表达式，我们又要写一个方法去单独计算这另外一个表达式，所以我们应该想一种办法，用一个算法，可以计算出所有加减乘除带括号的表达式 注意，我们说的是算法，还没有涉及到模式，那么什么算法可以解决这个问题呢？让我们现在请出它，它叫做逆波兰算法，什么是逆波兰算法呢？我们先模拟分步计算上面的表达式 最先计算25+15，得到40 再用40/8，得到5 计算5+5，得到10 计算10+22，得到32 最后计算6*32，得到192 逆波兰算法的作用就是将我们的表达式装换一下，装换成什么样呢？比如上面的表达式，通过逆波兰算法装换后，我们的表达式是这样的： 6 5 25 15 + 8 / + 22 + * 那么它和我们的计算步骤有什么联系呢，逆波兰表达式又叫做后缀表达式，上面的逆波兰表达式可以很明显体现我们的运算步骤，从左向右遍历，遇到运算符，就将此运算符用于此运算符前面两个数，比如上面的逆波兰表达式，第一个遇到的运算符号是加号，将它作用于25和15，计算得出40，一次类推，我们可以发现，和我们上面列出的1-5步骤是一毛一样的！接下来我们用代码实现，将普通表达式转化为逆波兰表达式 首先，写一个方法，将我们的表达式转换为中序表达式，就是一个存储运算符和数字的List public static List&lt;String&gt; stringToList(String str) { List&lt;String&gt; numberAndOperators = new ArrayList&lt;&gt;(); char[] chars = str.toCharArray(); int i = 0; char c; String number; while (i &lt; chars.length) { c = chars[i]; if (c &lt; &apos;0&apos; || c &gt; &apos;9&apos;) { numberAndOperators.add(String.valueOf(c)); i++; } else { number = &quot;&quot;; while (i &lt; chars.length &amp;&amp; c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;) { number += c; i++; c = chars[i]; } numberAndOperators.add(number); } } return numberAndOperators; } 此方法很简单，遍历字符串中的字符，如果是运算符直接放进List，如果是数字，继续先前遍历，直到不是数字，将这些数字字符拼接，例如上面的25，先遍历到2，再遍历到5，组成字符串25，放进List。进过这个算法，我们的字符串表达式被装换为 6 * ( 5 + ( 25 + 15 ) / 8 + 22 ) 接下来遍历上面的List，生成逆波兰表达式，同样用List保存这个字符序列 public static List&lt;String&gt; listToNBLList(List&lt;String&gt; list) { List&lt;String&gt; numberAndOperatorsNBL = new ArrayList&lt;&gt;(); Stack&lt;String&gt; stackNPL = new Stack&lt;&gt;(); for (String s : list) { if (s.matches(&quot;\\d+&quot;)) numberAndOperatorsNBL.add(s); else if (s.equals(&quot;(&quot;)) stackNPL.push(s); else if (s.equals(&quot;)&quot;)) { while (!stackNPL.peek().equals(&quot;(&quot;)) numberAndOperatorsNBL.add(stackNPL.pop()); stackNPL.pop(); } else { while (stackNPL.size() != 0 &amp;&amp; getValue(stackNPL.peek()) &gt;= getValue(s)) numberAndOperatorsNBL.add(stackNPL.pop()); stackNPL.push(s); } } while (stackNPL.size() != 0) numberAndOperatorsNBL.add(stackNPL.pop()); return numberAndOperatorsNBL; } /** * 获取运算符优先级 * +,-为1 *,/为2 ()为0 */ public static int getValue(String s) { if (s.equals(&quot;+&quot;)) { return 1; } else if (s.equals(&quot;-&quot;)) { return 1; } else if (s.equals(&quot;*&quot;)) { return 2; } else if (s.equals(&quot;/&quot;)) { return 2; } return 0; } 解释一下这个方法： 读到操作数，直接放入List 读到(，直接压入Stack栈顶 读到)，则弹出离Stack栈顶最近的到左括号(的所有操作符放入Lis,之后弹出该( 读到非括号操作符，则按照优先级操作。如果操作符比Stack栈顶操作符优先级高，则直接压入Stack；如果操作符不比Stack栈顶操作符优先级高，则弹出Stack栈顶并放入List，直到当前操作符高于Stack栈顶或者Stack为空，然后将当前操作符压入Stack 当中缀表达式读取完毕，将Stack内剩余的操作符逐个弹出并放入List List中即为逆波兰表达式 通过此方法，可以将上面的6 * ( 5 + ( 25 + 15 ) / 8 + 22 )转化为我们的逆波兰表达式：6 5 25 15 + 8 / + 22 + *，那么怎么计算呢，大家可能会发现，到现在我们都还没提到解释器模式，不过现在，我们可以用到他了，我们要用解释器模式来计算我们转化为逆波兰表达式的值。现在先来看看解释器模式的定义 定义定义一个语言的文法，并且建立一个解释器来解释该语言中的句子，这里的“语言”是指使用规定格式和语法的代码 角色 抽象表达式 终结符表达式 非终结符表达式 环境类 什么是表达式表达式就是就是代表我们上面的表达式，不过，具体的表达式会根据表达式的规则和语法来定义成最小单元的表达式，例如对于上面的整个表达式，里面的操作数是一个表达式，25+15是一个表达式，( 25 + 15 ) / 8是一个复合表达式，复合表达式是由简单表达式共同组合成的。根据表达式的不同，可以分为终结表达式和非终结符表达式。终结表达式很简单，比如上面的例子，每一个操作数就是终结表达式。非终结符表达式就是对非终结表达式和终结表达式的解释，比如25+15、( 25 + 15 ) / 8，非终结表达式中可以包含终结表达式和非终结表达式，终结表达式和非终结表达式都继承至抽象表达式。环境类我们稍后解释，现在我们就用解释器来计算我们上面的逆波兰表达式 抽象表达式： public abstract class AbstractExpression { public abstract int interpret(); } 数字表达式： // 终结表达式 public class NumberExpression extends AbstractExpression { private int number; public NumberExpression(int number) { this.number = number; } @Override public int interpret() { return number; } } 加法表达式： public class PlusExpression extends AbstractExpression { private AbstractExpression left; private AbstractExpression right; public PlusExpression(AbstractExpression left, AbstractExpression right) { this.left = left; this.right = right; } @Override public int interpret() { return left.interpret() + right.interpret(); } } 减法表达式： public class MinusExpression extends AbstractExpression { private AbstractExpression left; private AbstractExpression right; public MinusExpression(AbstractExpression left, AbstractExpression right) { this.left = left; this.right = right; } @Override public int interpret() { return left.interpret() - right.interpret(); } } 乘法表达式： public class MultiplyExpression extends AbstractExpression { private AbstractExpression left; private AbstractExpression right; public MultiplyExpression(AbstractExpression left, AbstractExpression right) { this.left = left; this.right = right; } @Override public int interpret() { return left.interpret() * right.interpret(); } } 除法表达式： public class DivideExpression extends AbstractExpression { private AbstractExpression left; private AbstractExpression right; public DivideExpression(AbstractExpression left, AbstractExpression right) { this.left = left; this.right = right; } @Override public int interpret() { return left.interpret() / right.interpret(); } } 除了数字表达式是终结表达式以外，加、乘、除都是非终结表达式，他们的实现方法用了递归的方式计算。接下来是我们的环境类，他一般就是用来计算我们的表达式，里面有一些方法和变量，方便客户端调用，类似一个工具类 public class Context { public int NBL(String expression) { List&lt;String&gt; numberAndOperators = stringToList(expression); List&lt;String&gt; NBLList = listToNBLList(numberAndOperators); Stack&lt;AbstractExpression&gt; stackCalculateNPL = new Stack&lt;&gt;(); for (String s : NBLList) { System.out.print(s + &quot; &quot;); if (s.matches(&quot;\\d+&quot;)) { stackCalculateNPL.push(new NumberExpression(Integer.valueOf(s))); } else { AbstractExpression right = stackCalculateNPL.pop(); AbstractExpression left = stackCalculateNPL.pop(); AbstractExpression nonterminalExpression = null; if (s.equals(&quot;+&quot;)) nonterminalExpression = new PlusExpression(right,left); else if (s.equals(&quot;-&quot;)) nonterminalExpression = new MinusExpression(right,left); else if (s.equals(&quot;*&quot;)) nonterminalExpression = new MultiplyExpression(right,left); else if (s.equals(&quot;/&quot;)) nonterminalExpression = new DivideExpression(right,left); stackCalculateNPL.push(nonterminalExpression); } } return stackCalculateNPL.pop().interpret(); } /** * 获取运算符优先级 * +,-为1 *,/为2 ()为0 */ private int getValue(String s) { if (s.equals(&quot;+&quot;)) { return 1; } else if (s.equals(&quot;-&quot;)) { return 1; } else if (s.equals(&quot;*&quot;)) { return 2; } else if (s.equals(&quot;/&quot;)) { return 2; } return 0; } private List&lt;String&gt; stringToList(String str) { List&lt;String&gt; numberAndOperators = new ArrayList&lt;&gt;(); char[] chars = str.toCharArray(); int i = 0; char c; String number; while (i &lt; chars.length) { c = chars[i]; if (c &lt; &apos;0&apos; || c &gt; &apos;9&apos;) { numberAndOperators.add(String.valueOf(c)); i++; } else { number = &quot;&quot;; while (i &lt; chars.length &amp;&amp; c &gt;= &apos;0&apos; &amp;&amp; c &lt;= &apos;9&apos;) { number += c; i++; c = chars[i]; } numberAndOperators.add(number); } } return numberAndOperators; } private List&lt;String&gt; listToNBLList(List&lt;String&gt; list) { List&lt;String&gt; numberAndOperatorsNBL = new ArrayList&lt;&gt;(); Stack&lt;String&gt; stackNPL = new Stack&lt;&gt;(); for (String s : list) { if (s.matches(&quot;\\d+&quot;)) numberAndOperatorsNBL.add(s); else if (s.equals(&quot;(&quot;)) stackNPL.push(s); else if (s.equals(&quot;)&quot;)) { while (!stackNPL.peek().equals(&quot;(&quot;)) numberAndOperatorsNBL.add(stackNPL.pop()); stackNPL.pop(); } else { while (stackNPL.size() != 0 &amp;&amp; getValue(stackNPL.peek()) &gt;= getValue(s)) numberAndOperatorsNBL.add(stackNPL.pop()); stackNPL.push(s); } } while (stackNPL.size() != 0) numberAndOperatorsNBL.add(stackNPL.pop()); return numberAndOperatorsNBL; } } 这个类里面除了NBL方法外，其他三个方法都是我们上面讲NBL算法时讲解了的，可以看到NBL方法，里面就用了各种实现AbstractExpression的表达式解释出了我们的算术表达式的值。有了这个方法，不管我们什么形式的四则运算都可以计算出来，而且只用了一个方法，最后我们来使用一下，计算一个新的表达式6*(5+(3+2)/5+22)，如果正确，应该得到的结果为168 public class Client { public static void main(String[] args) { Context context = new Context(); int result = context.NBL(&quot;6*(5+(3+2)/5+22)&quot;); System.out.println(); System.out.println(result); } } 结果： 6 5 3 2 + 5 / + 22 + * 168 解释器模式的用处在平时的编程中，解释器模式用得比较少，但是它的作用非常明显，比如在一些对大型数据做统计的程序中，可能我们数据是固定的，而不同的计算都是通过统一的语法，但是计算形式不同，有的是加两个数据，有的是两个数据相乘等等，这时候我们可以实现对这个同一语法的解释器，来计算经过统一语法构成的不同表达式。一般的，在这些情况下我们需要使用解释器 可以将一个需要解释执行的语言中的句子表示为一个抽象语法树。 一些重复出现的问题可以用一种简单的语言来进行表达。 一个语言的文法较为简单。 执行效率不是关键问题 解释器模式的优缺点优点 易于改变和扩展文法。由于在解释器模式中使用类来表示语言的文法规则，因此可以通过继承等机制来改变或扩展文法 每一条文法规则都可以表示为一个类，因此可以方便地实现一个简单的语言 实现文法较为容易。在抽象语法树中每一个表达式节点类的实现方式都是相似的，这些类的代码编写都不会特别复杂，还可以通过一些工具自动生成节点类代码 增加新的解释表达式较为方便。如果用户需要增加新的解释表达式只需要对应增加一个新的终结符表达式或非终结符表达式类，原有表达式类代码无须修改，符合“开闭原则” 缺点 对于复杂文法难以维护。在解释器模式中，每一条规则至少需要定义一个类，因此如果一个语言包含太多文法规则，类的个数将会急剧增加，导致系统难以管理和维护，此时可以考虑使用语法分析程序等方式来取代解释器模式。 执行效率较低。由于在解释器模式中使用了大量的循环和递归调用，因此在解释较为复杂的句子时其速度很慢，而且代码的调试过程也比较麻烦。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之备忘录模式]]></title>
      <url>%2F2016%2F12%2F20%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%A4%87%E5%BF%98%E5%BD%95%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[新的游戏功能之前公司的游戏小明通过原型模式完成了游戏中的小怪对象，现在公司游戏有一个需求，需要定期保存游戏的进度，并且用户可以恢复到保存的进度 小明对于这个功能无从下手，于是请教了主管，主管让小明去了解一下备忘录模式，使用备忘录模式就可以完成这个功能，于是小明去搜集了一下备忘录的资料，然后将这个模式迅速掌握并应用到了新的功能上 定义在不破坏封装性的前提下，捕获一个对象的内部状态，并在该对象之外保存这个状态。这样就可以将该对象恢复到原先保存的状态 角色 发起人 备忘录 管理角色 用备忘录实现功能通过备忘录模式的类图和角色，我们来实现一下我们的程序。首先，我们要定义我们的备忘录类，他记录了具体的状态 public interface IMemento { } public class Memento implements IMemento { private int progress; public Memento(int progress) { this.progress = progress; } public int getProgress() { return progress; } public void setProgress(int progress) { this.progress = progress; } } 我们需要保存的是游戏的进度，所以我们游戏进度类是发起人，它来定义游戏进度类中哪些状态需要保存 游戏状态类，也就是我们的发起者： public class Originator { int progress; public Originator() { } public int getProgress() { return progress; } public void setProgress(int progress) { this.progress = progress; } public Memento createMemento() { return new Memento(this.progress); } public void restoreMemento(IMemento memento) { this.setProgress(((Memento) memento).getProgress()); } } 另外，我们还需要一个类来管理我们这些状态，可以根据实际需求来指定这个管理角色的管理形式，我们使用一个Map来管理，这样可以保存多个状态 public class Caretaker { Map&lt;String, IMemento&gt; mementos; public Caretaker() { mementos = new HashMap&lt;&gt;(); } public IMemento getMemento(String name) { return mementos.get(name); } public void addMemento(String name, Memento memento) { this.mementos.put(name, memento); } } 现在我们来使用这个备忘录，帮助我们完成状态的恢复 public class Client { public static void main(String[] args) { Originator originator = new Originator(); originator.setProgress(1); System.out.println(&quot;当前进度 &quot; + originator.getProgress()); Caretaker caretaker = new Caretaker(); caretaker.addMemento(&quot;进度一&quot;, originator.createMemento()); originator.setProgress(2); System.out.println(&quot;当前进度 &quot; + originator.getProgress()); originator.setProgress(3); System.out.println(&quot;当前进度 &quot; + originator.getProgress()); caretaker.addMemento(&quot;进度三&quot;, originator.createMemento()); originator.restoreMemento(caretaker.getMemento(&quot;进度一&quot;)); System.out.println(&quot;当前进度 &quot; + originator.getProgress()); originator.restoreMemento(caretaker.getMemento(&quot;进度三&quot;)); System.out.println(&quot;当前进度 &quot; + originator.getProgress()); } } 最初时，游戏进度为1，调用游戏进度生成方法，也就是发起者产生一个此刻状态下的备忘录，并且将它保存到我们的Caretaker，名字为进度一，然后们游戏进度改变，从2再到3，我们只在1和3的时候生成了备忘录，然后将它保存到了Caretaker，然后在状态3时我们恢复到了状态1，再恢复到了3 执行结果： 当前进度 1 当前进度 2 当前进度 3 当前进度 1 当前进度 3 备忘录和发起者管理角色的功能很清晰，我们看看备忘录和发起者，发起者就是我们需要保存和恢复的，具体的备忘录也是由发起者产生的，备忘录里面需要存储的是由实际的需求来制定的，比如，有一些属性和状态无关，我们就不需要保存。备忘录模式比起其他模式算是比较简单的，不管是使用还是实现，但是它也有自己明显的优缺点： 优点： 当发起人角色中的状态改变时，有可能这是个错误的改变，我们使用备忘录模式就可以把这个错误的改变还原。 备份的状态是保存在发起人角色之外的，这样，发起人角色就不需要对各个备份的状态进行管理。 缺点： 在实际应用中，备忘录模式都是多状态和多备份的，发起人角色的状态需要存储到备忘录对象中，对资源的消耗是比较严重的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[从源码看commit和commitAllowingStateLoss方法区别]]></title>
      <url>%2F2016%2F12%2F19%2F%E4%BB%8E%E6%BA%90%E7%A0%81%E7%9C%8Bcommit%E5%92%8CcommitAllowingStateLoss%E6%96%B9%E6%B3%95%E5%8C%BA%E5%88%AB%2F</url>
      <content type="text"><![CDATA[Fragment介绍在很久以前，也就是我刚开始写Android时（大约在2012年的冬天……），那时候如果要实现像下面微信一样的Tab切换页面，需要继承TabActivity，然后使用TabHost，在TabHost中添加子Activity来实现 现在大家都知道，我们一般情况下会使用FragmentActivity加Fragment来实现，Fragment是Android 3.0新增的，另外我们的support v4包也提供能Fragment的支持，所以现在在所有版本的SDK中我们都可以使用Fragment。Fragment是Activity的一部分，其中一个很重要的需要大家掌握的就是关于Fragment的生命周期，当然这次我们不会讨论这个问题，不过提供一个图片供大家参考，图片来自xxv/android-lifecycle 从使用开始 FragmentManager fm = getSupportFragmentManager(); FragmentTransaction ft = fm.beginTransaction(); ft.hide(firstStepFragment); if (secondStepFragment==null){ ft.add(R.id.fl_content, secondStepFragment); }else { ft.show(secondStepFragment); } ft.commit(); 一般我们会这样动态使用Fragment，从代码可以明显体现出这个功能是通过事务的方式执行的，但在一些情况下，我们执行commit()时，会出现异常，例如stackoverflow上的一个报错，解决办法很简单，用commitAllowingStateLoss方法代替commit即可。那这个异常是怎么产生的呢？今天我们从源码来看看它的发生 逐步参看源码从FragmentActivity的getSupportFragmentManager方法开始： public class FragmentActivity { final FragmentController mFragments = FragmentController.createController(new HostCallbacks()); // …… public FragmentManager getSupportFragmentManager() { return mFragments.getSupportFragmentManager(); } // …… } public class FragmentController { private final FragmentHostCallback&lt;?&gt; mHost; public FragmentManager getSupportFragmentManager() { return mHost.getFragmentManagerImpl(); } } public abstract class FragmentHostCallback&lt;E&gt; extends FragmentContainer { FragmentManagerImpl getFragmentManagerImpl() { return mFragmentManager; } } 所以我们的FragmentTransaction是从FragmentManager的实现类FragmentManagerImpl的中的方法返回的，我们看一看FragmentManagerImpl源码中的beginTransaction方法： final class FragmentManagerImpl extends FragmentManager implements LayoutInflaterFactory { @Override public FragmentTransaction beginTransaction() { return new BackStackRecord(this); } } 可以看到，返回的是一个BackStackRecord，并且每一次调用都是最新实例化的，等下我们会看到，BackStackRecord的commit方法只能执行一次，或者会抛出一个异常。现在我们看一下我们关注的BackStackRecord的一些源码： final class BackStackRecord extends FragmentTransaction implements FragmentManager.BackStackEntry, Runnable { final FragmentManagerImpl mManager; static final class Op { Op next; Op prev; int cmd; Fragment fragment; int enterAnim; int exitAnim; int popEnterAnim; int popExitAnim; ArrayList&lt;Fragment&gt; removed; } public BackStackRecord(FragmentManagerImpl manager) { mManager = manager; } @Override public FragmentTransaction add(Fragment fragment, String tag) { doAddOp(0, fragment, tag, OP_ADD); return this; } @Override public FragmentTransaction add(int containerViewId, Fragment fragment) { doAddOp(containerViewId, fragment, null, OP_ADD); return this; } @Override public FragmentTransaction add(int containerViewId, Fragment fragment, String tag) { doAddOp(containerViewId, fragment, tag, OP_ADD); return this; } @Override public FragmentTransaction remove(Fragment fragment) { Op op = new Op(); op.cmd = OP_REMOVE; op.fragment = fragment; addOp(op); return this; } @Override public FragmentTransaction hide(Fragment fragment) { Op op = new Op(); op.cmd = OP_HIDE; op.fragment = fragment; addOp(op); return this; } @Override public FragmentTransaction show(Fragment fragment) { Op op = new Op(); op.cmd = OP_SHOW; op.fragment = fragment; addOp(op); return this; } private void doAddOp(int containerViewId, Fragment fragment, String tag, int opcmd) { final Class fragmentClass = fragment.getClass(); final int modifiers = fragmentClass.getModifiers(); if (fragmentClass.isAnonymousClass() || !Modifier.isPublic(modifiers) || (fragmentClass.isMemberClass() &amp;&amp; !Modifier.isStatic(modifiers))) { throw new IllegalStateException(&quot;Fragment &quot; + fragmentClass.getCanonicalName() + &quot; must be a public static class to be properly recreated from&quot; + &quot; instance state.&quot;); } fragment.mFragmentManager = mManager; if (tag != null) { if (fragment.mTag != null &amp;&amp; !tag.equals(fragment.mTag)) { throw new IllegalStateException(&quot;Can&apos;t change tag of fragment &quot; + fragment + &quot;: was &quot; + fragment.mTag + &quot; now &quot; + tag); } fragment.mTag = tag; } if (containerViewId != 0) { if (containerViewId == View.NO_ID) { throw new IllegalArgumentException(&quot;Can&apos;t add fragment &quot; + fragment + &quot; with tag &quot; + tag + &quot; to container view with no id&quot;); } if (fragment.mFragmentId != 0 &amp;&amp; fragment.mFragmentId != containerViewId) { throw new IllegalStateException(&quot;Can&apos;t change container ID of fragment &quot; + fragment + &quot;: was &quot; + fragment.mFragmentId + &quot; now &quot; + containerViewId); } fragment.mContainerId = fragment.mFragmentId = containerViewId; } Op op = new Op(); op.cmd = opcmd; op.fragment = fragment; addOp(op); } void addOp(Op op) { if (mHead == null) { mHead = mTail = op; } else { op.prev = mTail; mTail.next = op; mTail = op; } op.enterAnim = mEnterAnim; op.exitAnim = mExitAnim; op.popEnterAnim = mPopEnterAnim; op.popExitAnim = mPopExitAnim; mNumOp++; } @Override public int commit() { return commitInternal(false); } @Override public int commitAllowingStateLoss() { return commitInternal(true); } int commitInternal(boolean allowStateLoss) { if (mCommitted) throw new IllegalStateException(&quot;commit already called&quot;); if (FragmentManagerImpl.DEBUG) { Log.v(TAG, &quot;Commit: &quot; + this); LogWriter logw = new LogWriter(TAG); PrintWriter pw = new PrintWriter(logw); dump(&quot; &quot;, null, pw, null); } mCommitted = true; if (mAddToBackStack) { mIndex = mManager.allocBackStackIndex(this); } else { mIndex = -1; } mManager.enqueueAction(this, allowStateLoss); return mIndex; } } 可以看到，不管我们执行add、remove、hide、show中的哪一个方法，最终都会执行addOp方法，这个方法会生成一个双向链表的数据结果，具体的对象就是Op，对于不同的方法，Op中的cmd这个值是不一样的。大致的流程是这样的，我们调用add、remove、hide、show等方法后，会生成不同的操作命令，然后这些操作命令形成一个双向链表，其中任何一个操作命令，我们都可以知道它的前一个和后一个是什么命令。 最关键的部分来了，我们的commit和commitAllowingStateLoss也出现了，可以看到，最终两个方法都会调用commitInternal方法，只是传入的参数不同，我们也可以看到commitInternal方法的第一句有一个判断，也就是上面我们提到的，如果再执行事务的commit或者commitAllowingStateLoss方法，会抛出一个IllegalStateException(&quot;commit already called&quot;)异常，这也是我们会经常遇见的，所以们在使用Fragment时，每一次都需要调用beginTransaction方法生成新的事务，然后再commit，不能同一个事务commit两次 接着往下看，刚刚看到commit和commitAllowingStateLoss唯一的不同就是在调用commitInternal时，传入的参数不同，而在commitInternal方法中，用到了这个参数的是这个方法的倒数第二句代码：mManager.enqueueAction(this, allowStateLoss);，mManager就是我们的FragmentManagerImpl，我们看看这个类中的enqueueAction方法干了什么： final class FragmentManagerImpl extends FragmentManager implements LayoutInflaterFactory { public void enqueueAction(Runnable action, boolean allowStateLoss) { if (!allowStateLoss) { checkStateLoss(); } synchronized (this) { if (mDestroyed || mHost == null) { throw new IllegalStateException(&quot;Activity has been destroyed&quot;); } if (mPendingActions == null) { mPendingActions = new ArrayList&lt;Runnable&gt;(); } mPendingActions.add(action); if (mPendingActions.size() == 1) { mHost.getHandler().removeCallbacks(mExecCommit); mHost.getHandler().post(mExecCommit); } } } private void checkStateLoss() { if (mStateSaved) { throw new IllegalStateException( &quot;Can not perform this action after onSaveInstanceState&quot;); } if (mNoTransactionsBecause != null) { throw new IllegalStateException( &quot;Can not perform this action inside of &quot; + mNoTransactionsBecause); } } } 报错的地方出来了，就是在我们checkStateLoss方法中，因为执行commit方法时传入的参数为false，所以会执行checkStateLoss，在checkStateLoss方法中会抛出两个异常，一个是因为mStateSaved为true，一个是因为mNoTransactionsBecause不为空，那么接下来我们就分别看一下为什么会出现这两种情况 mStateSaved什么时候为truecheckStateLoss方法中mStateSaved只要为true，我们调用commit就会抛出异常，所以寻找问题就很简单了，看看什么情况下mStateSaved的值会被赋为true。通过查看FragmentManagerImpl的源码，这两个方法被执行时，mStateSaved被赋为了true： static final boolean HONEYCOMB = android.os.Build.VERSION.SDK_INT &gt;= 11; Parcelable saveAllState() { execPendingActions(); if (HONEYCOMB) { mStateSaved = true; } // 下面的代码省略…… } public void dispatchStop() { mStateSaved = true; moveToState(Fragment.STOPPED, false); } 那么什么时候会执行FragmentManagerImpl的这两个方法呢，通过查看，它们都是在我们的FragmentActivity的生命周期函数中被调用的： public class FragmentActivity{ @Override protected void onSaveInstanceState(Bundle outState) { super.onSaveInstanceState(outState); Parcelable p = mFragments.saveAllState(); if (p != null) { outState.putParcelable(FRAGMENTS_TAG, p); } if (mPendingFragmentActivityResults.size() &gt; 0) { outState.putInt(NEXT_CANDIDATE_REQUEST_INDEX_TAG, mNextCandidateRequestIndex); int[] requestCodes = new int[mPendingFragmentActivityResults.size()]; String[] fragmentWhos = new String[mPendingFragmentActivityResults.size()]; for (int i = 0; i &lt; mPendingFragmentActivityResults.size(); i++) { requestCodes[i] = mPendingFragmentActivityResults.keyAt(i); fragmentWhos[i] = mPendingFragmentActivityResults.valueAt(i); } outState.putIntArray(ALLOCATED_REQUEST_INDICIES_TAG, requestCodes); outState.putStringArray(REQUEST_FRAGMENT_WHO_TAG, fragmentWhos); } } @Override protected void onStop() { super.onStop(); mStopped = true; mHandler.sendEmptyMessage(MSG_REALLY_STOPPED); mFragments.dispatchStop(); } } 一个是FragmentActivity的onSaveInstanceState方法，它被执行后，只要是Android3.0以后都会将mStateSaved赋为true，当onStop方法执行时，mStateSaved在任何情况下都会被赋为true，我们先暂停一下看看另一个异常 mNoTransactionsBecause什么时候不为空一般情况下，我们的mNoTransactionsBecause的值一直都为null，只有当我们使用了Loader时，mNoTransactionsBecause才可能会被赋值，具体的代码就不再像上面那样这么细的看了，大家有兴趣可以参阅相关源码，不过我们需要道Loader是个什么东西，才能更好的理解，大家可以看看这篇文章，讲的比较详细和清楚。 为什么commit会抛出异常刚才我们看了异常的抛出的具体位置和引发条件，那么为什么commit会抛出异常呢，而commitAllowingStateLoss不会呢？我们都知道Activity在资源不足的情况下会被销毁，在销毁之前，会调用onSaveInstanceState，将fragments、views等保存下来，当Activity再被创建时，可以将保存的状态取出来重新装载Activity的状态，当onSaveInstanceState执行后，Activity的状态保存下来了，这个时候我们再调用commit，这个FragmentTransaction事务不会被保存下来，Android为了避免丢失，就给我抛出了一个异常，当然我们可以不在乎这个丢失，所以可以调用commitAllowingStateLoss方法。那么另外一个异常的原因呢？看完上面我提到的那篇文章，你应该知道Loader是为了供我们去异步访问一些数据，而上面的mNoTransactionsBecause代表了Loader的不同状态，如果在执行异步操作，我们commit，新的状态和Loader执行完的状态可能不是预期的，所以这时Android也会抛出一个异常IllegalStateException(&quot;Can not perform this action inside of &quot; + mNoTransactionsBecause)]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之桥接模式]]></title>
      <url>%2F2016%2F12%2F18%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[开始涉足硬件小明公司最近准备做硬件了，他们开始四处去寻找订单，但是效果不是太明显，不过，功夫不负有心人，一家名为长黑的电视机厂商被他们打动，电视机厂商准备将他们的遥控器外包给小明他们公司。小明很开心，又可以开始做新的项目了 电视机厂商遥控器对电视的控制都遵循统一的标准，所以长黑电视机厂商将这个标准和他们对标准的实现给了小明他们 遥控器的统一标准： public interface Control { void on(); void off(); void setChannel(int channel); } 长黑电视对电视的控制是现实： public class CHControl implements Control { @Override public void on() { System.out.print(&quot;Open CH TV&quot;); } @Override public void off() { System.out.print(&quot;Off CH TV&quot;); } @Override public void setChannel(int channel) { System.out.print(&quot;Set CH TV To &quot; + channel); } } 只要小明的公司通过CHControl的方法就可以操作长黑的电视机了，现在小明的公司只为长黑电视机生产一个功能极简的遥控器，只有三个按钮，分别是开/关、上一个节目、下一个节目，小明的主管实现把遥控器的接口类编写好了： public interface TvControl { void onOff(); void preChannel(); void nextChannel(); } 小明要做的，就是将这个具体的遥控器实现，小明想了想，他要做的事就是，实现TvControl并且通过CHControl来控制电视，所以思路非常清晰，然后小明很快实现了这个遥控器： public class CHTvControl extends CHControl implements TvControl { private boolean on = false; private int channel = 1; @Override public void onOff() { if (on) off(); else on(); } @Override public void preChannel() { if (on) setChannel(--channel); } @Override public void nextChannel() { if (on) setChannel(++channel); } } 小明高兴的开始测试遥控器了： public class Client { public static void main(String[] args){ CHTvControl chTvControl = new CHTvControl(); chTvControl.onOff(); chTvControl.nextChannel(); chTvControl.nextChannel(); chTvControl.preChannel(); chTvControl.onOff(); } } 测试结果 Open CH TV Set CH TV To 2 Set CH TV To 3 Set CH TV To 2 Off CH TV 小明找到主管，询问主管是否需要再做修改，主管看了看说，小明，我们仔细想一下你的代码如果要扩展会有什么问题。现在有新的电视机厂商找到我们，遥控器的样式是不变的，也是和之前的遥控器功能一样，你就必须要再针对新的电视机厂商再实现新的遥控器类 比如，狗熊电视机厂再找到我们，遥控器仍然只有三个按钮，那么必须产生一个新的遥控器类： public class GXTvContrlo extends GXControl implements TvControl { // 省略实现………… } 还有一个问题，现在要针对长黑电视机生产新的遥控器了，我们也必须再实现新的遥控器，我们可以看到，我们现有的设计里面，变动的两个地方，一是电视机厂商，二是遥控器的种类，所以我们的类可能会有N*N个（N个电视机厂商，N种遥控器）。那么应该怎么办呢？我们又要认识一个新的朋友了，它可以帮助我们避免这种变化的问题，它就叫桥接模式，我们先来认识一下它，然后再用它帮我们解决问题 定义通过将实现和抽象放在两个不同的类层次中而使它们可以独立改变 角色 抽象化角色 修正抽象化角色 实现化角色 具体实现化角色 注：抽象化角色包含一个实现化角色的引用 解决问题看完桥接模式的定义，我们现在来用桥接模式中各个角色对应我们上面的类，我们应该被抽象的应该是哪一个类呢？抽象化角色是用来被继承的，继承一般是扩展类的功能，在上面的例子中，我们需要扩展的类应该是遥控器，因为遥控器只会从简易化向复杂化演进，所以我们应该抽象画一个基本的遥控器父类，然后需要不同的遥控器时，我们再来扩展它。相应的，我们的实现化角色应该是我们对同步电视的控制类，对电视的控制有统一的标准，不同的厂家会实现这个标准，然后我们针对不同的厂家调用不同的实现，所以，实现化角色应该是我们的对电视的控制类。现在，一切都清晰了，开始做我们新的遥控器吧！ 重新定义我们的抽象化角色，也就是我们的遥控器基类： public abstract class TvControl { Control control; public TvControl(Control control) { this.control = control; } abstract void onOff(); abstract void nextChannel(); abstract void preChannel(); } 我们实现遥控器时，最简单的功能也必须包括这三个功能，如果需要新加功能，只需要再扩展相应的功能即可，现在我们实现一个具体的遥控器： public class SimpleTvControl extends TvControl { private boolean on = false; private int channel = 1; public SimpleTvControl(Control control) { super(control); } @Override void onOff() { if (on) control.off(); else control.on(); on = !on; } @Override void nextChannel() { if (on) control.setChannel(++channel); } @Override void preChannel() { if (on) control.setChannel(--channel); } } 使用新的遥控器： public class Client { public static void main(String[] args) { CHControl chControl = new CHControl(); SimpleTvControl simpleTvControl = new SimpleTvControl(chControl); chTvControl.onOff(); chTvControl.nextChannel(); chTvControl.nextChannel(); chTvControl.preChannel(); chTvControl.onOff(); } } 结果是和上面一样的： Open CH TV Set CH TV To 2 Set CH TV To 3 Set CH TV To 2 Off CH TV 我们看到，用了桥接模式的新设计，不会出现像上面那样的问题了，同一款遥控器，我们只需要包含不同的电视控制实现就可以，比如我们的简易遥控器，只要在构造SimpleTvControl遥控器时，放入不同的电视控制类即可。同样的，如果我们的简易遥控器需要扩展，只需继承当前的SimpleTvControl，然后扩展新功能就行了，对电视控制类不会有影响 桥接模式和策略模式仔细分析，我们的桥接模式貌似只是在策略模式的基础上加了一个继承，的确如此，那么我们看看两者的区别： 目的不同 桥接：让接口实现和抽象层可以分别演化，提高移植性 策略：将复杂的算法封装起来，从而便于替代不同的算法 使用方式不同 桥接：利用已有的类和方法 策略：扩展或者修改，并提供动态配置 重点不同 桥接：强调接口对象提供基本的操作 策略：强调接口对象提供的是一种算法 什么时候使用桥接模式桥接模式的目的是为了分离抽象和实现，便于两者的独立变化，所以当有多维度分类时，而且每一种分类又有可能变化，就可以考虑使用我们的桥接模式了]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之访问者模式]]></title>
      <url>%2F2016%2F12%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%AE%BF%E9%97%AE%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[小明公司的福利小明作为一个程序员，难免不经常加班，所以他这一年的年假也没有机会享受，但是小明的公司福利很好，对于公司没有休年假的员工作相应的补偿 具体的补偿根据员工的入职时间和职级来的，我们先看看小明公司的员工 public class Staff { String name; int workYear; int level; int vacationDay; public Staff(String name, int workYear, int level, int vacationDay) { this.name = name; this.workYear = workYear; this.level = level; this.vacationDay = vacationDay; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getWorkYear() { return workYear; } public void setWorkYear(int workYear) { this.workYear = workYear; } public int getLevel() { return level; } public void setLevel(int level) { this.level = level; } public int getVacationDay() { return vacationDay; } public void setVacationDay(int vacationDay) { this.vacationDay = vacationDay; } } 员工集合类 public class Staffs { Map&lt;String, Staff&gt; staffMap = new HashMap&lt;&gt;(20); public Staffs() { Staff xiaoming = new Staff(&quot;xiaoming&quot;, 2, 1, 5); Staff zhuguan = new Staff(&quot;zhuguan&quot;, 4, 2, 4); Staff jingli = new Staff(&quot;jingli&quot;, 5, 4, 1); staffMap.put(xiaoming.getName(), xiaoming); staffMap.put(zhuguan.getName(), zhuguan); staffMap.put(jingli.getName(), jingli); } } 现在我们要开始补偿员工了，规则是：年限的系数为1，职级的系数也为1，然后乘以每天50元的补偿。比如小明，如果还有1天没休，那么他这一天应该得到的补偿为：(1x2+1x1)x50，就是一天150块钱的补偿，所以对于小明来说，他还有5天的年假，所以他能得到750元的补偿。那么这个功能怎么加呢？由于是小明负责这个程序，他在员工集合类中加入了一个方法： public class Staffs { Map&lt;String, Staff&gt; staffMap = new HashMap&lt;&gt;(20); public Staffs() { Staff xiaoming = new Staff(&quot;xiaoming&quot;, 2, 1, 5); Staff zhuguan = new Staff(&quot;zhuguan&quot;, 4, 2, 4); Staff jingli = new Staff(&quot;jingli&quot;, 5, 4, 1); staffMap.put(xiaoming.getName(), xiaoming); staffMap.put(zhuguan.getName(), zhuguan); staffMap.put(jingli.getName(), jingli); } void printCompensation() { for (Staff staff : staffMap.values()) { System.out.println(staff.getName() + &quot; 应该得到&quot; + ((staff.getWorkYear() + staff.getLevel()) * 50 * staff.getVacationDay()) + &quot;元补偿&quot;); } } } 得到的结果： xiaoming 应该得到750元补偿 jingli 应该得到450元补偿 zhuguan 应该得到1200元补偿 小明开开心心的去找主管交代码准备领钱了，主管看了小明的代码说，你这样做违背了开闭原则。主管接着说，在没有这个福利之前，我们的员工类和员工集合类一直都没有任何的修改，而因为这个福利，加入了一个新的方法，这不是最关键的，关键是，如果明年没有这个福利了或者这个福利的补偿算法变了，你又必须修改员工集合类（Staffs），所以对于福利这一块，它是变动的。小明着急的问，那怎么办呢，主管说，对于这种结构比较固定的类，如果我们需要利用他们的元素去做一些其他事情，并且这些事情是变化的，我们需要将它独立出来，这次我们需要的是访问者模式 可被访问者接口： public interface Visitable { void accept(Visitor visitor); } 我们的员工实现我们的Visitable接口： public class Staff implements Visitable { String name; int workYear; int level; int vacationDay; public Staff(String name, int workYear, int level, int vacationDay) { this.name = name; this.workYear = workYear; this.level = level; this.vacationDay = vacationDay; } public String getName() { return name; } public void setName(String name) { this.name = name; } public int getWorkYear() { return workYear; } public void setWorkYear(int workYear) { this.workYear = workYear; } public int getLevel() { return level; } public void setLevel(int level) { this.level = level; } public int getVacationDay() { return vacationDay; } public void setVacationDay(int vacationDay) { this.vacationDay = vacationDay; } @Override public void accept(Visitor visitor) { visitor.visit(this); } } 增加一个访问者接口： public interface Visitor { void visit(Staff staff); } 实现一个具体的访问者，比如我们的计算补偿的访问者： public class CompensationVisit implements Visitor { @Override public void visit(Staff staff) { System.out.println(staff.getName() + &quot; 应该得到&quot; + ((staff.getWorkYear() + staff.getLevel()) * 50 * staff.getVacationDay()) + &quot;元补偿&quot;); } } 使用我们的模式来计算大家的补偿 public class Client { public static void main(String[] args) { CompensationVisit compensationVisit = new CompensationVisit(); Staffs staffs = new Staffs(); for (Staff staff : staffs.staffMap.values()) { staff.accept(compensationVisit); } } } 执行结果是和上面一样的： xiaoming 应该得到750元补偿 jingli 应该得到450元补偿 zhuguan 应该得到1200元补偿 如果明年我们的福利算法变了，我们只需要在Staff的accept方法中传入另一个不同实现的访问者即可，这就是我们的访问者模式 定义封装某些作用于某种数据结构中各元素的操作，它可以在不改变数据结构的前提下定义作用于这些元素的新的操作 角色 抽象元素类 元素类 抽象访问者 访问者 结构对象 访问者模式的适用场景假如一个对象中存在着一些与本对象不相干（或者关系较弱）的操作，为了避免这些操作污染这个对象，则可以使用访问者模式来把这些操作封装到访问者中去 假如一组对象中，存在着相似的操作，为了避免出现大量重复的代码，也可以将这些重复的操作封装到访问者中去]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之原型模式]]></title>
      <url>%2F2016%2F12%2F16%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[公司做游戏了小明的公司赚的钱越来越多了，他们开始尝试新的机会，公司觉得游戏是一个不错的选择，所以公司准备做游戏了 小明负责游戏中的一个模块，这个模块是负责设计游戏中的各种小怪角色，小明拿觉得这个很简单啊，于是根据游戏策划对小怪的设计，开始写代码了： class Monster { String color; int healthValue; public Monster(String color, int healthValue) { this.color = color; this.healthValue = healthValue; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } public int getHealthValue() { return healthValue; } public void setHealthValue(int healthValue) { this.healthValue = healthValue; } } 生成怪兽并使用 public class Client { public static void main(String[] args) { Monster monster = new Monster(&quot;green&quot;, 100); int i = 1; while (i &lt; 10) { if (i % 2 == 0) monster.setColor(&quot;red&quot;); else monster.setColor(&quot;blue&quot;); monster.setHealthValue(i * 200); System.out.print(monster); i++; } } } 主管说，你现在只实例化了10个怪兽，我现在需要100万个小怪兽，让游戏有一种特殊的效果，你的方式还可以吗？小明想了一下，如果100万个的话，这样效率太低了，小明想那我们用多线程吧，主管说，多线程就必须每次都生成新的对象，不能像上面那样共用一个对象，这又是一笔额外的开支，所以我们想想可以在生成对象的时候提高一下效率吗？小明问，可以吗？主管说，当然，这种情况我们使用原型模式再适合不过了，我们改造一下Monster： public class Monster implements Cloneable { String color; int healthValue; public Monster(String color, int healthValue) { this.color = color; this.healthValue = healthValue; } public String getColor() { return color; } public void setColor(String color) { this.color = color; } public int getHealthValue() { return healthValue; } public void setHealthValue(int healthValue) { this.healthValue = healthValue; } @Override protected Object clone(){ Monster monster = null; try { monster = (Monster) super.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } return monster; } } 可以看到，我们的Monster实现了Cloneable接口，并重载了clone()方法，然后我们使用新的怪兽类 public class Client { public static void main(String[] args) { Monster monster = new Monster(&quot;green&quot;, 100); int i = 1; while (i &lt;= 1000000) { Monster cloneMonster = monster.clone(); if (i % 2 == 0) cloneMonster.setColor(&quot;red&quot;); else cloneMonster.setColor(&quot;blue&quot;); cloneMonster.setHealthValue(i * 200); System.out.print(cloneMonster); i++; } } } 可以看到，我们用了clone方法来生成新的对象，这样做有什么好处呢，如果之前那种方式在我们的while中有耗时操作的话，实例化的过程效率很低，如果我们实现Cloneable接口，我们可以通过clone方法来生成对象，它是一个本地方法，直接在内存中再复制一份我们对象的二进制生成一个新的对象，而不是通过再使用构造函数去生成，这样效率会提升很多。所以在需要重复地创建相似对象时可以考虑使用原型模式。比如需要在一个循环体内创建对象，假如对象创建过程比较复杂或者循环次数很多的话，使用原型模式不但可以简化创建过程，而且可以使系统的整体性能提高很多 原型模式用原型实例指定创建对象的种类，并通过拷贝这些原型创建新的对象 使用原型模式的注意事项使用原型模式复制对象不会调用类的构造方法因为对象的复制是通过调用Object类的clone方法来完成的，它直接在内存中复制数据，因此不会调用到类的构造方法。不但构造方法中的代码不会执行，甚至连访问权限都对原型模式无效。还记得单例模式吗？单例模式中，只要将构造方法的访问权限设置为private型，就可以实现单例。但是clone方法直接无视构造方法的权限，所以，单例模式与原型模式是冲突的，在使用时要特别注意 深拷贝与浅拷贝浅拷贝被拷贝对象的所有变量都含有与原对象相同的值，而且对其他对象的引用仍然是指向原来的对象。即浅拷贝只负责当前对象实例，对引用的对象不做拷贝，然后一直基本数据类型会被拷贝 深拷贝被拷贝对象的所有变量都含有与原来的对象相同的值，除去那些引用其他对象的变量。那些引用其他对象的变量将指向被复制过的新对象，而不再是原有的那些被引用的对象。换言之，深拷贝把要复制的对象所引用的对象都复制了一遍 明白了深拷贝和浅拷贝，我们在使用clone方法的时候就必须注意，因为默认的clone方法是浅拷贝，对于一些引用对象不会拷贝为新的对象，所以在需要时，我们必须对对象引用再做一次拷贝： public class Monster implements Cloneable { String color; int healthValue; ArrayList&lt;String&gt; skills; @Override protected Monster clone() { Monster monster = null; try { monster = (Monster) super.clone(); monster.skills = (ArrayList&lt;String&gt;) this.skills.clone(); } catch (CloneNotSupportedException e) { e.printStackTrace(); } return monster; } } 深拷贝与浅拷贝问题中，会发生深拷贝的有java中的8中基本类型以及他们的封装类型，另外还有String类型。其余的都是浅拷贝]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之建造者模式]]></title>
      <url>%2F2016%2F12%2F15%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[游乐园也来了游乐园会有什么需求找到小明他们公司呢？现在游乐园需要根据顾客的不同要求为他们量身定做不同的主题假期，是量身定做哦~顾客可以选择假期天数、活动类型、是否需要住宿、餐饮、交通、一定要玩的项目等等。。。 小明认真的想了一下，这不很简单吗？一个主题都会有这些要求相应的参数，在构造时，使用一个构造函数，参数包括这一切要求就可以根据不同要求实例化了： public class Vacation{ int day; String type; boolean needHotal; boolean needTraffic; String[] mustProjects; String vacationPackage; public Vacation(int day, String type, boolean needHotal, boolean needTraffic, String[] mustProjects, String vacationPackage){ this.day = day; this.type = type; this.needHotal = needHotal; this.needTraffic = needTraffic; this.mustProjects = mustProjects; this.vacationPackage = vacationPackage; } } 小明的主管说，你确定这样的设计可以吗？小明想了想，这样的确不太好。首先，构造函数的参数过多，会造成使用这个类的其他客户需要对每一个属性都必须明确它是否需要；第二，如果有新的属性加入，凡是使用到它的客户都需要做修改。所以我们将这一部分交给其他的类来处理，现在我们就需要使用到建造者模式，用建造者来负责这个对象的构建 抽象建造类： public interface Builder { public void setDay(int day); public void setType(String type); public void needHotal(boolean needHotal); public void this.needTraffic(boolean needTraffic); public void set mustProjects(String[] projects); public void set setVacationPackage(String vacationPackage); public Vacation create(); } 具体建造类： public class ConcreteBuilder implements Builder { int day; String type; boolean needHotal; boolean needTraffic; String[] mustProjects; String vacationPackage; public void setDay(int day){ this.day = day; } public void setType(String type){ this.type = type; } public void needHotal(boolean needHotal){ this.needHotal = needHotal; } public void needTraffic(boolean needTraffic){ this.needTraffic = needTraffic; } public void set mustProjects(String[] projects){ this.mustProjects = mustProjects; } public void set setPackage(String package){ this.vacationPackage = vacationPackage; } public Vacation create(){ Vacation vacation = new Vacation; if(day == 0) vacation.setDay(1); else vacation.setDay(day); if(type == null) vacation.setType(&quot;普通&quot;); else vacation.setType(type); else vacation.setNeedHotal(needHotal); else vacation.setNeedTraffic(needTraffic); else vacation.setMustProjects(mustProjects); else vacation.setVacationPackage(day); return vacation } } 产品类： public class Vacation{ int day; String type; boolean needHotal; boolean needTraffic; String[] mustProjects; String vacationPackage; public void setDay(int day) { this.day = day; } public void setType(String type) { this.type = type; } public void setNeedHotal(boolean needHotal) { this.needHotal = needHotal; } public void setNeedTraffic(boolean needTraffic) { this.needTraffic = needTraffic; } public void setMustProjects(String[] mustProjects) { this.mustProjects = mustProjects; } public void setVacationPackage(String vacationPackage) { this.vacationPackage = vacationPackage; } } 创建产品： public class Client { public static void main(String[]args){ // 创建一个默认的产品 Builder builderOne = new ConcreteBuilder(); Vacation v1 = builderOne.create(); // 一个5天需要酒店的产品 Builder builderTwo = new ConcreteBuilder(); builderTwo.setDay(5); builderTwo.needHotal(true); Vacation v2 = builderTwo.create(); // 其他。。。 } } 可以看到，我们再创建产品时就使用了建造者，在建造者中，我们可以在客户没有设置某个产品属性时，默认给产品添加相应的属性，这就是我们的建造者模式。停！这让我想到了抽象工厂模式，这不就是抽象工厂吗！一般情况下，建造者模式还有一个导演类，导演类的主要作用是和客户端打交道，也就是我们使用建造者模式创建产品的客户端并不直接与建造者打交道，而是通过导演类，这是建造者模式和抽象工厂一个很明显的区别，就这么点区别，当然不是，我们先看定义，再继续探讨他们的区别 定义将一个复杂对象的构建与它的表示分离，使得同样的构建过程可以创建不同的表示 角色 产品类 抽象建造者 建造者 导演类 和抽象工厂的区别除了多了一个导演类的区别，还有什么区别呢，其实导演类我们可以不需要，就像我们上面的例子，如果没有了导演类，它和我们的抽象工厂模式就更像了。一般的，抽象工厂是为了创建很复杂的产品，而建造者模式用于创建更为复杂的对象！甚至会引入导演类，导演类来负责产品的创建，而不是使用产品的客户端本身。另外，抽象工厂中一般产品的创建都会涉及到产品族 在Android中的建造者大家一定在Android中使用过AlertDialog，AlertDialog的创建就是使用了建造者模式 public static class Builder { private final AlertController.AlertParams P; public Builder(Context context) { this(context, resolveDialogTheme(context, 0)); } public Builder(Context context, int themeResId) { P = new AlertController.AlertParams(new ContextThemeWrapper( context, resolveDialogTheme(context, themeResId))); } public Context getContext() { return P.mContext; } public Builder setTitle(@StringRes int titleId) { P.mTitle = P.mContext.getText(titleId); return this; } public Builder setTitle(CharSequence title) { P.mTitle = title; return this; } public Builder setCustomTitle(View customTitleView) { P.mCustomTitleView = customTitleView; return this; } public Builder setMessage(@StringRes int messageId) { P.mMessage = P.mContext.getText(messageId); return this; } public Builder setMessage(CharSequence message) { P.mMessage = message; return this; } public Builder setIcon(@DrawableRes int iconId) { P.mIconId = iconId; return this; } public Builder setIcon(Drawable icon) { P.mIcon = icon; return this; } public Builder setIconAttribute(@AttrRes int attrId) { TypedValue out = new TypedValue(); P.mContext.getTheme().resolveAttribute(attrId, out, true); P.mIconId = out.resourceId; return this; } public Builder setPositiveButton(@StringRes int textId, final OnClickListener listener) { P.mPositiveButtonText = P.mContext.getText(textId); P.mPositiveButtonListener = listener; return this; } public Builder setPositiveButton(CharSequence text, final OnClickListener listener) { P.mPositiveButtonText = text; P.mPositiveButtonListener = listener; return this; } public Builder setNegativeButton(@StringRes int textId, final OnClickListener listener) { P.mNegativeButtonText = P.mContext.getText(textId); P.mNegativeButtonListener = listener; return this; } public Builder setNegativeButton(CharSequence text, final OnClickListener listener) { P.mNegativeButtonText = text; P.mNegativeButtonListener = listener; return this; } public Builder setNeutralButton(@StringRes int textId, final OnClickListener listener) { P.mNeutralButtonText = P.mContext.getText(textId); P.mNeutralButtonListener = listener; return this; } public Builder setNeutralButton(CharSequence text, final OnClickListener listener) { P.mNeutralButtonText = text; P.mNeutralButtonListener = listener; return this; } public Builder setCancelable(boolean cancelable) { P.mCancelable = cancelable; return this; } public Builder setOnCancelListener(OnCancelListener onCancelListener) { P.mOnCancelListener = onCancelListener; return this; } public Builder setOnDismissListener(OnDismissListener onDismissListener) { P.mOnDismissListener = onDismissListener; return this; } public Builder setOnKeyListener(OnKeyListener onKeyListener) { P.mOnKeyListener = onKeyListener; return this; } public Builder setItems(@ArrayRes int itemsId, final OnClickListener listener) { P.mItems = P.mContext.getResources().getTextArray(itemsId); P.mOnClickListener = listener; return this; } public Builder setItems(CharSequence[] items, final OnClickListener listener) { P.mItems = items; P.mOnClickListener = listener; return this; } public Builder setAdapter(final ListAdapter adapter, final OnClickListener listener) { P.mAdapter = adapter; P.mOnClickListener = listener; return this; } public Builder setCursor(final Cursor cursor, final OnClickListener listener, String labelColumn) { P.mCursor = cursor; P.mLabelColumn = labelColumn; P.mOnClickListener = listener; return this; } public Builder setMultiChoiceItems(@ArrayRes int itemsId, boolean[] checkedItems, final OnMultiChoiceClickListener listener) { P.mItems = P.mContext.getResources().getTextArray(itemsId); P.mOnCheckboxClickListener = listener; P.mCheckedItems = checkedItems; P.mIsMultiChoice = true; return this; } public Builder setMultiChoiceItems(CharSequence[] items, boolean[] checkedItems, final OnMultiChoiceClickListener listener) { P.mItems = items; P.mOnCheckboxClickListener = listener; P.mCheckedItems = checkedItems; P.mIsMultiChoice = true; return this; } public Builder setMultiChoiceItems(Cursor cursor, String isCheckedColumn, String labelColumn, final OnMultiChoiceClickListener listener) { P.mCursor = cursor; P.mOnCheckboxClickListener = listener; P.mIsCheckedColumn = isCheckedColumn; P.mLabelColumn = labelColumn; P.mIsMultiChoice = true; return this; } public Builder setSingleChoiceItems(@ArrayRes int itemsId, int checkedItem, final OnClickListener listener) { P.mItems = P.mContext.getResources().getTextArray(itemsId); P.mOnClickListener = listener; P.mCheckedItem = checkedItem; P.mIsSingleChoice = true; return this; } public Builder setSingleChoiceItems(Cursor cursor, int checkedItem, String labelColumn, final OnClickListener listener) { P.mCursor = cursor; P.mOnClickListener = listener; P.mCheckedItem = checkedItem; P.mLabelColumn = labelColumn; P.mIsSingleChoice = true; return this; } public Builder setSingleChoiceItems(CharSequence[] items, int checkedItem, final OnClickListener listener) { P.mItems = items; P.mOnClickListener = listener; P.mCheckedItem = checkedItem; P.mIsSingleChoice = true; return this; } public Builder setSingleChoiceItems(ListAdapter adapter, int checkedItem, final OnClickListener listener) { P.mAdapter = adapter; P.mOnClickListener = listener; P.mCheckedItem = checkedItem; P.mIsSingleChoice = true; return this; } public Builder setOnItemSelectedListener(final AdapterView.OnItemSelectedListener listener) { P.mOnItemSelectedListener = listener; return this; } public Builder setView(int layoutResId) { P.mView = null; P.mViewLayoutResId = layoutResId; P.mViewSpacingSpecified = false; return this; } public Builder setView(View view) { P.mView = view; P.mViewLayoutResId = 0; P.mViewSpacingSpecified = false; return this; } public Builder setRecycleOnMeasureEnabled(boolean enabled) { P.mRecycleOnMeasure = enabled; return this; } public AlertDialog create() { // Context has already been wrapped with the appropriate theme. final AlertDialog dialog = new AlertDialog(P.mContext, 0, false); P.apply(dialog.mAlert); dialog.setCancelable(P.mCancelable); if (P.mCancelable) { dialog.setCanceledOnTouchOutside(true); } dialog.setOnCancelListener(P.mOnCancelListener); dialog.setOnDismissListener(P.mOnDismissListener); if (P.mOnKeyListener != null) { dialog.setOnKeyListener(P.mOnKeyListener); } return dialog; } public AlertDialog show() { final AlertDialog dialog = create(); dialog.show(); return dialog; } } 这个类是AlertDialog.java类中的一个静态内部类，我们一般使用AlertDialog就是通过它创建的，像这样： AlertDialog alertDialog = new AlertDialog.Builder(this).setTitle(&quot;复选框&quot;).setMultiChoiceItems(new String[] { &quot;Item1&quot;, &quot;Item2&quot; }, null, null).setPositiveButton(&quot;确定&quot;, null).setNegativeButton(&quot;取消&quot;, null).create(); // 或者 new AlertDialog.Builder(this).setTitle(&quot;复选框&quot;).setMultiChoiceItems(new String[] { &quot;Item1&quot;, &quot;Item2&quot; }, null, null).setPositiveButton(&quot;确定&quot;, null).setNegativeButton(&quot;取消&quot;, null).show(); 可以看到，对于AlertDialog，他有很多属性供我们自定义，这些属性的组合又会产生很多不同的AlertDialog，所以他很复杂，如果我们使用抽象工厂模式，我们的工厂类在我们的产品对象中也会导致我们的产品更复杂，所以我们在这种情况下，一般使用建造者模式去创建如此复杂的产品]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之中介者模式]]></title>
      <url>%2F2016%2F12%2F14%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%B8%AD%E4%BB%8B%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[小明开始了解更多的模式小明买房的事正在顺利的进展着，同时他也知道了代理模式的用处，为了掌握更多的设计模式，他开始自己学习其他模式了，首先它想到的就是中介者模式，因为它似乎觉得中介者模式更能体现他买房的方式。 从名字来看，似乎买房应该用到的是中介者模式，的确，名字容易产生误解，那么中介者模式是怎么定义的呢，它又是解决什么问题的呢？我们先回忆一下外观模式，它帮助极客小明用简单的方法操作了许多影音设备，不然他需要用很繁琐的程序才能看到电影。外观模式解决了一个类和多个类耦合的问题，然而我们的中介者模式是为了解决多个类相互之前的相互依赖。更加准确的说，中介者模式是为了帮助我们解决同事类之间的复杂关系，那么什么是同事类呢？举一个例子，类A和类B存在这样的关系，类A中有一个数字，类B中也有一个数字，类A、类B的数字是10倍的关系，也就是说如果A的数字是10，那么B中的数字就应该是是100，相应的，如果类B数字是200，那么类A中的数字就应该是20 类A： class A { int number; public void setNumber(int number, A a) { this.number = number; coll.setNumber(number*100); } public void setNumber(int number){ this.number = number; } } 类B： class B { int number; public void setNumber(int number, A a) { this.number = number; coll.setNumber(number*100); } public void setNumber(int number){ this.number = number; } } 使用： public class Client { public static void main(String[] args){ A a = new A(); B b = new B(); a.setNumber(1288, b); b.setNumber(87635, a); } } 如果只有像上面两个这样的同事类，我们还能应付过来，但如果像下面这样呢？ 如果对象1发生变化了，有4个对象会被影响，对象5变化了，将有5个对象被影响，所以这种情况下，我们必须解决这种困境，也就是假如对象1发生变化，它不需要关心和去处理它的同事类变化，它只负责自己，不管是变化还是怎样也好，它的职责应该是单一的 我们优化一下上面的A和B，引进一个中介者： abstract class AbstractMediator{ protected A a; protected B b; public AbstractMediator(A a, B b) { this.a = a; this.b = b; } public abstract void aAffectB(); public abstract void bAffectA(); } class Mediator extends AbstractMediator { public Mediator(A a, B b) { super(a, b); } public void aAffectB() { int number = a.getNumber(); b.setNumber(number*100); } public void bAffectA() { int number = b.getNumber(); a.setNumber(number/100); } } 类A： class A { int number; public void setNumber(int number, AbstractMediator am) { this.number = number; am.aAffectB(); } } 类B： class B { int number; public void setNumber(int number, AbstractMediator am) { this.number = number; am.bAffectA(); } } 使用 public class Client { public static void main(String[] args){ A a = new A(); B b = new B(); AbstractMediator am = new Mediator(a, b); a.setNumber(1288, am); b.setNumber(87635, am); } } 在代码中，虽然类A和类B有很大的关系，但是都没有在类A和类B中体现出来了，而是通过一个中介者类解耦了。所以有了中介者模式，我们可以将上图中多个同事类的关系改变为这样： 定义用一个中介者对象封装一系列的对象交互，中介者使各对象不需要显示地相互作用，从而使耦合松散，而且可以独立地改变它们之间的交互 角色 同事类（多个） 抽象中介者 实现中介者 中介者模式是一种比较常用的模式，也是一种比较容易被滥用的模式。对于大多数的情况，同事类之间的关系不会复杂到混乱不堪的网状结构，因此，大多数情况下，将对象间的依赖关系封装的同事类内部就可以的，没有必要非引入中介者模式。滥用中介者模式，只会让事情变的更复杂]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之代理模式]]></title>
      <url>%2F2016%2F12%2F13%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E4%BB%A3%E7%90%86%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[小明要买房了小明的公司的新项目应接不暇，这不，小明拿之前做项目积累的积蓄准备买房了，但是万事开头难，小明不知道该怎么如手，作为他在工作和生活上导师的主管说，我们来写一个程序你就明白该怎么做了。 小明很诧异，这和程序需有什么关系啊，主管说，当然有，我们来实现一下你买房的场景： public interface IHouse{ public String getInfo(); } 一套具体的房子： public class House implements IHouse{ String info; public House(String info){ this.info = info; } public String getInfo(){ return info; } } 因为消息不对称，你并不知道这套房子在出售，那么你要找一个知道的人，然后找他了解情况，这个人就是代理： public class HouseProxy implements IHouse{ IHouse house; public HouseProxy(IHouse house){ this.house = house; } public String getInfo(){ return house.info; } } 所以，对于你来说，你只需要找到代理即可，而代理是你很容易接触到的，这就是代理模式： public class XiaoMing { public static void main(String[] args) { IHouse houseProxy = new HouseProxy(new House(&quot;三环的房子&quot;)); houseProxy.getInfo(); } } 小明很快就明白该怎么做了，但是小明觉得这个模式在程序中没有存在的价值啊，我们不需要借用一个类去访问另一个类啊，因为在程序中不像我们现实中，程序中有多少类我们应该都是知道的。主管说，别着急，我们慢慢看，首先我们来看看代理模式的定义。 定义为另一个对象提供一个替身或者占位符以控制对这个对象的访问 角色 抽象角色 代理角色 真实角色 代理模式的用法代理模式的定义我们已经很清楚了，但是它到底有什么用处呢，还是它是一个没有多大用处的模式呢，恰巧相反，代理模式的用法非常非常多，所以我们来一个一个详细的了解 静态代理代理类和被代理类的关系在运行前就确定了，也就是一个代理类对应一个被代理的真实角色，正如我们上面的列子，就是一个静态代理，他只是控制了对真实角色的直接访问，他有一个缺点，就是一个代理类代理一个真实角色，这样如果需要代理的角色很多，会造成代理类大量增加。那么有什么方式解决吗？接下来我们要说的代理模式的另一种形式就可以解决这个问题 动态代理动态代理相比前面的静态代理，动态代理具有更强的灵活性，因为它不用在我们设计实现的时候就指定某一个代理类来代理哪一个被代理对象，我们可以把这种指定延迟到程序运行时由JVM来实现。我们知道，所谓代理，就是需要代理类和被代理类有相同的对外接口，所以代理类一般都必须实现了所有被代理类已实现的接口，因为接口就是制定了一系列对外服务的标准。正因为动态代理有这样灵活的特性，所以我们在设计动态代理类（DynamicProxy）时不用显式地让它实现与真实角色相同的接口，而是把这种实现推迟到运行时。我们把上面的例子用动态代理实现 抽象角色和真实角色不变： public interface IHouse{ public String getInfo(); } 一套具体的房子： public class House implements IHouse{ String info; public House(String info){ this.info = info; } public String getInfo(){ return info; } } 变化的使我们的代理类： public class DynamicProxyHouse implements InvocationHandler { Object obj = null; public DynamicProxyHouse(Object obj) { this.obj = obj; } public Object invoke(Object proxy, Method method, Object[] args) throws Throwable { //do something Object result = method.invoke(this.obj, args); return result; } } 它并没有实现我们的抽象角色，而是实现JDK中的InvocationHandler，先看新的代理的的使用： public class XiaoMing { public static void main(String[] args) { IHouse realHouse = new House(&quot;二环的房子&quot;); ClassLoader loader = realHouse.getClass().getClassLoader(); Class&lt;?&gt;[] interfaces = realHouse.getClass().getInterfaces(); InvocationHandler handler = new DynamicProxyHouse(realHouse); IHouse houseProxy = (IHouse) Proxy.newProxyInstance(loader, interfaces, handler); houseProxy.getInfo(); } } 我们可以看到，新的代理可以代理任何需要被代理的对象，而不需要像静态代理那样为每个需要代理的类定义一个代理类。当调用被代理类的方法时，是由InvocationHandler的invoke去调用，所以我们可以在invoke方法中增加我们要做的事，接下来我们看一下动态代理的过程： 动态代理用了Java中的反射，同时它也是一种AOP的体现，大家可以自行去深入了解一下反射和AOP。 远程代理远程代理就是通过代理去调用远程对象的方法，这个对象存在于不同的地址空间。Java RMI就是远程代理的一个实际运用，另外Android中的AIDL也是通过代理模式实现的不同进程间通讯很好的例子，只是它们各自的实现原理不一样 虚拟代理虚拟代理主要是被代理的对象实例化的开销很大，通过代理，可以管理被代理对象的加载。比如，在加载图片时，未加载出图片时，先显示一串提示文字，代理类作为被代理类的替身 安全代理安全代理很简单，就是用来控制对真实对象的访问 智能代理代理类在代理时，会在调用真实类方法时，在前面或者后面增加一些操作。如上面的房产代理，除了卖房（其实是房屋所有者卖房）还会收取佣金]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之状态模式]]></title>
      <url>%2F2016%2F12%2F12%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%8A%B6%E6%80%81%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[自动贩卖机公司的需求小明的公司在他们当地越来越有名，有很多公司都找到了他们，最近又有一家制作自动贩卖机的公司找到了他们，他们公司是做自动贩卖机的，他们需要将他们的售卖过程用程序实现，所以他们找到了小明的公司。 自动贩卖机公司递交了一份关于贩卖机售卖过程的文档给小明他们： 小明拿到这张图一看，觉得整个需求和过程都非常清晰，椭圆表示售卖机不同的状态，横线上面的动作表示售卖机的动作。于是开始写代码了，很快完成了售卖机。 public class VendingMachine { final static int FREE = 0; final static int HAS_MONEY= 1; final static int HAS_GOODS = 2; final static int SOLD = 3; final static int HAS_CHANGE = 4; int state = FREE; double money = 0; double change = 0; public VendingMachine(int count) { } public void insertMoney(double money) { if (state == FREE) { state = HAS_MONEY; System.out.println(&quot;你已经投入&quot; + money + &quot;元&quot;); } else if (state == HAS_MONEY) { System.out.println(&quot;你已经投入&quot; + (this.money + money) + &quot;元&quot;); } else if (state == HAS_GOODS) { System.out.println(&quot;不能再投入&quot;); } else if (state == SOLD) { System.out.println(&quot;不能再投入&quot;); }else if (state == HAS_CHANGE) { System.out.println(&quot;不能再投入&quot;); } } public void selectGoods() { if (state == FREE) { System.out.println(&quot;你还没有投入钱&quot;); } else if (state == HAS_MONEY) { if(商品价格 &gt; money){ System.out.println(&quot;商品价格大于你投入的钱&quot;); }else { state = HAS_GOODS; System.out.println(&quot;你已经选择商品&quot;); } } else if (state == HAS_GOODS) { if(商品价格 &gt; money){ System.out.println(&quot;商品价格大于你投入的钱&quot;); }else { state = HAS_GOODS; System.out.println(&quot;你已经选择商品&quot;); } } else if (state == SOLD) { System.out.println(&quot;不能再选择&quot;); }else if (state == HAS_CHANGE) { System.out.println(&quot;不能再选择&quot;); } } public void clickConfirm() { if (state == FREE) { System.out.println(&quot;你还没有投入钱&quot;); } else if (state == HAS_MONEY) { System.out.println(&quot;你还没有选择商品&quot;); } else if (state == HAS_GOODS) { state = SOLD; System.out.println(&quot;售出&quot;); } else if (state == SOLD) { System.out.println(&quot;已经售出&quot;); }else if (state == HAS_CHANGE) { System.out.println(&quot;已经售出&quot;); } } public void shipment() { if (state == SOLD) { change = money - 商品价格; if (change &gt; 0) { state = HAS_CHANGE; }else { state = FREE; } }else { System.out.println(&quot;错误&quot;); } } public void giveChange() { if (state == FREE) { System.out.println(&quot;你还没有投入钱&quot;); } else if (state == HAS_MONEY) { state = FREE; } else if (state == HAS_GOODS) { System.out.println(&quot;不能找零&quot;); } else if (state == SOLD) { System.out.println(&quot;没有零钱&quot;); } else if (state == HAS_CHANGE) { state = FREE; System.out.println(&quot;找零&quot;); } } } 代码很容易理解，在售卖机执行不同动作时，判断售卖机之前的状态，然后执行不同的动作，并且将售卖机更新为新的状态。小明很开心的把程序交给了主管，主管拿到项目并没有说什么，只是给小明说，你的程序没有问题，但是现在售卖机工厂增加了一个需求，在出货时随机（百分之一的概率）让当前购买用户可以中奖，小明这时候准备开始修改代码，但是发现，代码改动的非常大，不仅要加入新的状态，还要修改每个动作内的代码。主管发现了小明的犹豫说，我知道你已经发现了问题，你的代码对于之前的需求是没有问题的，但是之前说过，我们的程序是一定会变的，所以你的代码对于更新会出现很大的问题，违反了很多设计的原则，所以我们必须重构你的代码，而且是完全的重构，抛弃你现在的方式。我们先来分析一下售卖机厂的的需求：对于售卖机，有不同的状态，在不同的状态下发生不同动作时需要做不同的处理和更新，而且可能会加入新的状态和动作，所以状态对于售卖机是变化的部分，我们应该将它独立出来，那么针对这样的情况，我们使用状态模式就再适合不过了： 首先，定义一个状态接口： public interface State { public void insertMoney(double money); public void selectGoods(); public void clickConfirm(); public void shipment(); public void giveChange(); } 修改售卖机的代码： public class VendingMachine { State freeState; State hasMoneyState; State hasGoodsState; State soldState; State hasChangeState; State status; double money; double change; public VendingMachine() { freeState = new FreeState(this); hasMoneyState = new HasMoneyState(this); hasGoodsState = new HasGoodsState(this); soldState = new SoldState(this); hasChangeState = new HasChangeState(this); state = freeState; } public void insertMoney(double money) { state.insertMoney(money); } public void selectGoods() { state.selectGoods(); } public void clickConfirm() { state.clickConfirm(); } public void shipment() { state.shipment(); } public void giveChange() { state.giveChange(); } } 实现一个Free状态的实现类： public class FreeState implements State { VendingMachine vendingMachine; public FreeState(VendingMachine vendingMachine) { this.vendingMachine = vendingMachine; } public void insertMoney(double money) { vendingMachine.money += money; vendingMachine.state = vendingMachine.hasMoneyState; System.out.println(&quot;你已经投入&quot; + vendingMachine.money + &quot;元&quot;); } public void selectGoods() { System.out.println(&quot;你还没有投入钱&quot;); } public void clickConfirm() { System.out.println(&quot;你还没有投入钱&quot;); } public void shipment() { System.out.println(&quot;你还没有投入钱&quot;); } public void giveChange() { System.out.println(&quot;你还没有投入钱&quot;); } } 实现已投入钱状态的实现类： public class HasMoneyState implements State { VendingMachine vendingMachine; public HasMoneyState(VendingMachine vendingMachine) { this.vendingMachine = vendingMachine; } public void insertMoney(double money) { vendingMachine.money += money; System.out.println(&quot;你已经投入&quot; + vendingMachine.money + &quot;元&quot;); } public void selectGoods() { vendingMachine.state = vendingMachine.hasGoodsState; System.out.println(&quot;你已经选择商品&quot;); } public void clickConfirm() { System.out.println(&quot;你还没有选择商品&quot;); } public void shipment() { System.out.println(&quot;你还没有选择商品&quot;); } public void giveChange() { vendingMachine.state = vendingMachine. freeState; System.out.println(&quot;已经将钱退出&quot;); } } 其他三种状态的实现相信大家已经很清楚了，在这里就不在赘述了。这样一来，我们的售卖机程序就非常清晰了，也利于我们的扩展或修改，如果要加入一个状态，只需要修改和这个状态相关的代码，而不会影响其他状态，这就是我们的状态模式。 定义允许对象在内部状态改变时改变它的行为，对象看起来好像修改了它的类 角色 上下文环境 抽象状态 具体状态 它与策略模式的区别首相我们看看策略模式的类图： 惊人的相似！那么，他们是不是同一种模式呢，根据以往的经验，一般这种情况的两种模式一定是有区别的，不然它们不应该被分别定义，对于策略模式和状态模式的区别又是怎样的呢？其实两种模式最大的区别就是它们各自的意图，策略模式的上下文会选择不同的策略以表示该类不同的表现，类的表现从初始化后已经决定。而状态模式会决定上下文的状态和在不同状态下的表现，你某个时刻的体现取决于当前的状态对象，而下一个状态取决于当前状态对当前动作的结果，状态模式中会体现动作和改变，而策略模式中只体现了动作，只是动作被封装成了其他类，由其他类管理起来了。当两者有共同的作用就是解耦，把类的可变部分由独立出来的类实现，不同的策略或者状态会体现出不同的动作。当然我们也发现，对于状态模式，不同的状态我们会实现不同状态接口，所以有多少状态，就会有多少的状态类，这样我们类的数量是必定会增加的，这是它的缺点。不过，如果我们类的状态过多，而且状态的切换非常复杂的话，那么我们的状态模式的优点是显而易见的。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之组合模式]]></title>
      <url>%2F2016%2F12%2F09%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%BB%84%E5%90%88%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[提示：此篇文章与上一篇文章耦合度较高，请先观看我 合并的新店发现了新的问题新店老板找到小明他们，说之前的方式的确让我们的服务员减少不少的工作，但是我们现在的各种菜单越来越多，每家一种菜单，就必须在服务员里添加一次，最关键的是，我们准备在某些菜单中加入一些子菜单，就是说菜单里除了菜品，可能还有菜单。 小明看了看主管，疑惑的问这样可以实现吗？主管说，当然可以，我们会用到一种新的模式，用了这种模式，新店遇到的两个问题都解决了！服务员只用知道一个菜单，而这个菜单里面既有菜品又有子菜单，小明说，那这不就成了一个树状结构的菜单了么，菜品属于叶节点，而子菜单属于组合节点，组合节点又可以出现新的叶节点和组合节点…… 主管说，对，我们就是要实现这样一种结构，它的名字叫组合模式，我们现在来看看它强大的威力吧！ 首先，我们需要定义一个抽象类，它是我们叶节点和组合节点的共同接口： public abstract class MenuComponent { public void add(MenuComponent menuComponent) { throw new UnsupportedOperationException(); } public void remove(MenuComponent menuComponent) { throw new UnsupportedOperationException(); } public MenuComponent getChild(int i) { throw new UnsupportedOperationException(); } public String getName() { throw new UnsupportedOperationException(); } public String getDescription() { throw new UnsupportedOperationException(); } public double getPrice() { throw new UnsupportedOperationException(); } public boolean isVegetarian() { throw new UnsupportedOperationException(); } public void print() { throw new UnsupportedOperationException(); } } 实现具体的一个菜品，也就是我们的也叶节点： public class MenuItem extends MenuComponent { String name; String description; boolean vegetarian; double price; public MenuItem(String name, String description, boolean vegetarian, double price) { this.name = name; this.description = description; this.vegetarian = vegetarian; this.price = price; } public String getName() { return name; } public String getDescription() { return description; } public double getPrice() { return price; } public boolean isVegetarian() { return vegetarian; } public void print() { System.out.print(&quot; &quot; + getName()); if (isVegetarian()) { System.out.print(&quot;(v)&quot;); } System.out.println(&quot;, &quot; + getPrice()); System.out.println(&quot; -- &quot; + getDescription()); } } 我们可以看到，对于菜品类，并没覆盖父类的add、remove、getChild方法，因为对于叶节点，它在没有向下的叶节点和组合节点了。 实现菜单项，也就是我们的组合节点，它包含了叶节点和组合节点，也就是又有菜品，又有子菜单： public class Menu extends MenuComponent { ArrayList menuComponents = new ArrayList(); String name; String description; public Menu(String name, String description) { this.name = name; this.description = description; } public void add(MenuComponent menuComponent) { menuComponents.add(menuComponent); } public void remove(MenuComponent menuComponent) { menuComponents.remove(menuComponent); } public MenuComponent getChild(int i) { return (MenuComponent)menuComponents.get(i); } public String getName() { return name; } public String getDescription() { return description; } public void print() { System.out.print(&quot;\n&quot; + getName()); System.out.println(&quot;, &quot; + getDescription()); System.out.println(&quot;---------------------&quot;); Iterator iterator = menuComponents.iterator(); while (iterator.hasNext()) { MenuComponent menuComponent = (MenuComponent)iterator.next(); menuComponent.print(); } } } 和上面一样，对于父类的一些方法，我们的菜单项也没有实现的，因为对于菜单项那些方法是没有意义。再比较一下print()方法，上面的叶节点，它是以明确的菜品，我们可以打印出它的一些信息，而对于组合节点，由于它只是一个菜单，我们要打印的不光是它的信息，我们还需要它里面包含的菜品，当然还有它里面包含的子菜单的菜品，和子菜单中子菜单的菜品……于是我们使用迭代器遍历它，然后再调用里面包含的菜单信息的打印方法（可能是菜单、也可能是菜品，如果是菜单会有递归）。 现在，服务员轻松了： public class Waitress { MenuComponent allMenus; public Waitress(MenuComponent allMenus) { this.allMenus = allMenus; } public void printMenu() { allMenus.print(); } } 定义允许你将对象组合成树形结构来表现“整体/部分”层次结构。组合能让客户以一致的方式处理个别对象以及对象组合。 定义组合模式的迭代器在组合模式中，定义一个迭代器似乎是有必要的，因为组合节点是一个集合，所以我们需要遍历它，在上面的实现中，我们已经使用了迭代器来打印，他只是在组合节点中来使用迭代来遍历组合节点中的集合，现在我们需要一个迭代器来访问组合模式中的所有元素，首先我们需要在叶节点和组合节点的实现类中加入一个方法，其他实现不变 叶节点加入： public Iterator createIterator() { return new NullIterator(); } public class MenuItem extends MenuComponent { String name; String description; boolean vegetarian; double price; public MenuItem(String name, String description, boolean vegetarian, double price) { this.name = name; this.description = description; this.vegetarian = vegetarian; this.price = price; } public String getName() { return name; } public String getDescription() { return description; } public double getPrice() { return price; } public boolean isVegetarian() { return vegetarian; } public Iterator createIterator() { return new NullIterator(); } public void print() { System.out.print(&quot; &quot; + getName()); if (isVegetarian()) { System.out.print(&quot;(v)&quot;); } System.out.println(&quot;, &quot; + getPrice()); System.out.println(&quot; -- &quot; + getDescription()); } } 组合节点加入： public Iterator createIterator() { return new CompositeIterator(menuComponents.iterator()); } public class Menu extends MenuComponent { ArrayList menuComponents = new ArrayList(); String name; String description; public Menu(String name, String description) { this.name = name; this.description = description; } public void add(MenuComponent menuComponent) { menuComponents.add(menuComponent); } public void remove(MenuComponent menuComponent) { menuComponents.remove(menuComponent); } public MenuComponent getChild(int i) { return (MenuComponent)menuComponents.get(i); } public String getName() { return name; } public String getDescription() { return description; } public Iterator createIterator() { return new CompositeIterator(menuComponents.iterator()); } public void print() { System.out.print(&quot;\n&quot; + getName()); System.out.println(&quot;, &quot; + getDescription()); System.out.println(&quot;---------------------&quot;); Iterator iterator = menuComponents.iterator(); while (iterator.hasNext()) { MenuComponent menuComponent = (MenuComponent)iterator.next(); menuComponent.print(); } } } 先看看叶节点中加入的方法返回的迭代器： public class NullIterator implements Iterator { public Object next() { return null; } public boolean hasNext() { return false; } public void remove() { throw new UnsupportedOperationException(); } } 很容易理解，由于叶节点不需要遍历，所以他的实现如上所示，重点是组合节点遍历的实现，我们直接上代码： public class CompositeIterator implements Iterator { Stack stack = new Stack(); public CompositeIterator(Iterator iterator) { stack.push(iterator); } public Object next() { if (hasNext()) { Iterator iterator = (Iterator) stack.peek(); MenuComponent component = (MenuComponent) iterator.next(); if (component instanceof Menu) { stack.push(component.createIterator()); } return component; } else { return null; } } public boolean hasNext() { if (stack.empty()) { return false; } else { Iterator iterator = (Iterator) stack.peek(); if (!iterator.hasNext()) { stack.pop(); return hasNext(); } else { return true; } } } public void remove() { throw new UnsupportedOperationException(); } } 这段代码我不会做具体的解释，因为比较抽象，有一种只可意会不可言传的感觉，相信大家能看懂。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之迭代器模式]]></title>
      <url>%2F2016%2F12%2F09%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%BF%AD%E4%BB%A3%E5%99%A8%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[披萨店和咖啡店合并了主管告诉小明，披萨店和咖啡店合并了，小明说你怎么知道啊？因为他们在合并是遇到了问题，由于他们的菜单不一样，所以在服务员在使用时很麻烦，这不新店找到了小明他们帮助解决这个问题。 菜单上的单项（庆幸的是他们菜单上菜品是用的相同的类）： public class MenuItem { String name; String description; boolean vegetarian; double price; public MenuItem(String name, String description, boolean vegetarian, double price) { this.name = name; this.description = description; this.vegetarian = vegetarian; this.price = price; } public String getName() { return name; } public String getDescription() { return description; } public double getPrice() { return price; } public boolean isVegetarian() { return vegetarian; } } 披萨店菜单： public class PizzaMenu implements Menu { ArrayList menuItems; public PizzaMenu() { menuItems = new ArrayList(); addItem(&quot;芝士披萨&quot;, &quot;芝士加番茄&quot;, true, 2.99); addItem(&quot;榴莲披萨&quot;, &quot;榴莲味&quot;, true, 3.99); } public void addItem(String name, String description, boolean vegetarian, double price) { MenuItem menuItem = new MenuItem(name, description, vegetarian, price); menuItems.add(menuItem); } public ArrayList getMenuItems() { return menuItems; } // other menu methods here } 咖啡店菜单： public class CoffeeMenu implements Menu { static final int MAX_ITEMS = 6; int numberOfItems = 0; MenuItem[] menuItems; public CoffeeMenu() { menuItems = new MenuItem[MAX_ITEMS]; addItem(&quot;焦糖玛奇朵&quot;, &quot;&quot;, true, 12); addItem(&quot;拿铁&quot;, &quot;&quot;, true, 10); } public void addItem(String name, String description, boolean vegetarian, double price) { MenuItem menuItem = new MenuItem(name, description, vegetarian, price); if (numberOfItems &gt;= MAX_ITEMS) { System.err.println(&quot;Sorry, menu is full! Can&apos;t add item to menu&quot;); } else { menuItems[numberOfItems] = menuItem; numberOfItems = numberOfItems + 1; } } public MenuItem[] getMenuItems() { return menuItems; } // other menu methods here } 合并以后，服务员在使用两个菜单必须这样 public class Waitress { PizzaMenu pizzaMenu; CoffeeMenu coffeeMenu; public Waitress(PizzaMenu pizzaMenu, Menu coffeeMenu) { this.pizzaMenu = pizzaMenu; this.coffeeMenu = coffeeMenu; } public void printMenu() { ArrayList pizzaMenuItems = pizzaMenu. getMenuItems(); // 打印披萨菜单 MenuItem[] cafeMenuItems = coffeeMenu. getMenuItems(); // 打印咖啡菜单 } } 对于两个菜单，他们用不同的集合实现了内部的菜品管理，一个是ArrayList，一个是数组，所以服务员在操作时，就必须按照它们数据结构不同的操作方式去操作这些数据，最严重的问题时，如果再合并一家其他的餐厅，而该餐厅用的又是Map来管理的，那么不但要修改服务员的代码，还需要用map的遍历方式去阅读菜单。这样服务员和菜单的耦合就太严重了，所以必须要有一种方式防止这个的问题，小明问主管，有什么方式呢？主管说，迭代器模式可以很好的解决这个问题，让我们开始动手优化吧！ 首先，创造一个迭代器： public interface Iterator { boolean hasNext(); Object next(); } 分别针对两个菜单都实现它： 披萨菜单迭代器： public class PizzaMenuIterator implements Iterator { ArrayList items; int position = 0; public PizzaMenuIterator(ArrayList items) { this.items = items; } public Object next() { Object object = items.get(position); position = position + 1; return object; } public boolean hasNext() { if (position &gt;= items.size()) { return false; } else { return true; } } } 咖啡菜单迭代器： public class CoffeeMenuIterator implements Iterator { MenuItem[] items; int position = 0; public CoffeeMenuIterator(MenuItem[] items) { this.items = items; } public Object next() { MenuItem menuItem = items[position]; position = position + 1; return menuItem; } public boolean hasNext() { if (position &gt;= items.length || items[position] == null) { return false; } else { return true; } } } 新的披萨店菜单： public class PizzaMenu implements Menu { ArrayList menuItems; public PizzaMenu() { menuItems = new ArrayList(); addItem(&quot;芝士披萨&quot;, &quot;芝士加番茄&quot;, true, 2.99); addItem(&quot;榴莲披萨&quot;, &quot;榴莲味&quot;, true, 3.99); } public void addItem(String name, String description, boolean vegetarian, double price) { MenuItem menuItem = new MenuItem(name, description, vegetarian, price); menuItems.add(menuItem); } public Iterator createIterator() { return new PizzaMenuIterator(menuItems); } // other menu methods here } 新的咖啡店菜单： public class CoffeeMenu implements Menu { static final int MAX_ITEMS = 6; int numberOfItems = 0; MenuItem[] menuItems; public CoffeeMenu() { menuItems = new MenuItem[MAX_ITEMS]; addItem(&quot;焦糖玛奇朵&quot;, &quot;&quot;, true, 12); addItem(&quot;拿铁&quot;, &quot;&quot;, true, 10); } public void addItem(String name, String description, boolean vegetarian, double price) { MenuItem menuItem = new MenuItem(name, description, vegetarian, price); if (numberOfItems &gt;= MAX_ITEMS) { System.err.println(&quot;Sorry, menu is full! Can&apos;t add item to menu&quot;); } else { menuItems[numberOfItems] = menuItem; numberOfItems = numberOfItems + 1; } } public Iterator createIterator() { return new CoffeeMenuIterator(menuItems); } // other menu methods here } 两个新的菜单将之前获取具体数据集的方式修改成了createIterator()方法，我们看看新的方式下，服务员再使用他们时的用法： public class Waitress { PizzaMenu pizzaMenu; CoffeeMenu coffeeMenu; public Waitress(PizzaMenu pizzaMenu, Menu coffeeMenu) { this.pizzaMenu = pizzaMenu; this.coffeeMenu = coffeeMenu; } public void printMenu() { Iterator pizzaIterator = pizzaMenu.createIterator(); printMenu(pizzaIterator); Iterator coffeeIterator = coffeeMenu.createIterator(); printMenu(coffeeIterator); } private void printMenu(Iterator iterator) { while (iterator.hasNext()) { MenuItem menuItem = (MenuItem)iterator.next(); System.out.print(menuItem.getName() + &quot;, &quot;); System.out.print(menuItem.getPrice() + &quot; -- &quot;); System.out.println(menuItem.getDescription()); } } } 和之前的方式相比，服务员浏览（打印所有菜品）菜单只用了一个方法printMenu(Iterator iterator)，如果以后新增了用其他集合管理的菜单，只需要用一个新的迭代器去实现相应数据集合的迭代即可，服务员只需要拿到这个新的菜单就可以浏览了，而不用去修改服务员内部代码。这不是适配器吗？稍等，先看看定义，然后我们再总结他们的区别。 定义提供一种方法顺序访问集合对象中的各个元素，而又不暴露其内部的表示。 角色 迭代器 迭代器实现 聚合 主要是定义createIterator方法 聚合的实现 迭代器和集合同存亡 深入认识一下迭代器首先回答上面那个问题，它和适配器有什么区别，其实从定义可以看出来，迭代是为了访问集合中的元素，而适配器将不满足要求的接口适配为满足要求的接口。而且有很重要的一点，适配器不仅仅是为了统一接口，它的作用还体现了一个重要的原则单一职责原则，像上面我们的菜单，它主要的职责是菜单本身，如果将访问菜单也加入菜单类的功能，那么就违背了单一职责原则，所以将这个功能用单独的一个迭代器去实现，将更好的体现菜单本身的职责。 实际的运用我们刚才实现了两个迭代器，分别针对ArrayList和数组，其实JDK本身已经给我们在ArrayList提供了这个功能: @Override public Iterator&lt;E&gt; iterator() { return new ArrayListIterator(); } private class ArrayListIterator implements Iterator&lt;E&gt; { /** Number of elements remaining in this iteration */ private int remaining = size; /** Index of element that remove() would remove, or -1 if no such elt */ private int removalIndex = -1; /** The expected modCount value */ private int expectedModCount = modCount; public boolean hasNext() { return remaining != 0; } @SuppressWarnings(&quot;unchecked&quot;) public E next() { ArrayList&lt;E&gt; ourList = ArrayList.this; int rem = remaining; if (ourList.modCount != expectedModCount) { throw new ConcurrentModificationException(); } if (rem == 0) { throw new NoSuchElementException(); } remaining = rem - 1; return (E) ourList.array[removalIndex = ourList.size - rem]; } public void remove() { Object[] a = array; int removalIdx = removalIndex; if (modCount != expectedModCount) { throw new ConcurrentModificationException(); } if (removalIdx &lt; 0) { throw new IllegalStateException(); } System.arraycopy(a, removalIdx + 1, a, removalIdx, remaining); a[--size] = null; // Prevent memory leak removalIndex = -1; expectedModCount = ++modCount; } } 如上面的PizzaMenu菜单中的createIterator()方法，其实直接可以这样使用 public class PizzaMenu implements Menu { ArrayList menuItems; public PizzaMenu() { menuItems = new ArrayList(); addItem(&quot;芝士披萨&quot;, &quot;芝士加番茄&quot;, true, 2.99); addItem(&quot;榴莲披萨&quot;, &quot;榴莲味&quot;, true, 3.99); } public void addItem(String name, String description, boolean vegetarian, double price) { MenuItem menuItem = new MenuItem(name, description, vegetarian, price); menuItems.add(menuItem); } public Iterator createIterator() { return menuItems.iterator(); } // other menu methods here } 当然我们之前的Iterator是我们自己定义的，其实JDK也有现成的迭代器接口，我们可以直接使用，它提供了三个方法供我们实现： public interface Iterator&lt;E&gt; { public boolean hasNext(); public E next(); public void remove(); } 而且在JDK1.5之后，我们可以用for/in语法遍历迭代器，而不用再像上面那种方式去遍历数据了： 之前： private void printMenu(Iterator iterator) { while (iterator.hasNext()) { MenuItem menuItem = (MenuItem)iterator.next(); System.out.print(menuItem.getName() + &quot;, &quot;); System.out.print(menuItem.getPrice() + &quot; -- &quot;); System.out.println(menuItem.getDescription()); } } 现在： ArrayList&lt;MenuItem&gt; menuItems = new ArrayList(); menuItems.add(new MenuItem()); // …… for(MenuItem menuItem : menuItems){ System.out.print(menuItem.getName() + &quot;, &quot;); System.out.print(menuItem.getPrice() + &quot; -- &quot;); System.out.println(menuItem.getDescription()); } JDK中的迭代器： ArrayList --&gt; ArrayListIterator HahsMap --&gt; KeyIterator、ValueIterator、EntryIterator LinkedList --&gt; LinkIterator Vector --&gt; SimpleListIterator …… 内部迭代器刚才我们实现的是一个外部迭代器，什么是外部迭代器呢，其实很简单，就是客户端通过调用next()方法取得下一个元素，而内部迭代器是由迭代器内部控制一切，我们只需要告诉它要做的操作，其他的事就由它自己完成了。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之模板方法模式]]></title>
      <url>%2F2016%2F12%2F08%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E6%A8%A1%E6%9D%BF%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[小明拿到了一个半成品这天，主管发了一个项目给小明，说这是之前咖啡厅的一个小需求，他们的生意越来越好，开始买其他的饮品了，比如茶。咖啡店想把泡咖啡和泡茶的过程规范一下，所以需要小明他们公司迭代一个程序的版本。 但是小明打开项目后，发现项目里面只有两个类，其中一个是抽象类，而主管的说，你的任务就是实现这个抽象类，完成这个项目。 饮料抽象类： public abstract clsaa Beverage{ final void made(){ boilWater(); addBeverage(); waterInCup(); addCondiments(); } abstract void addBeverage(); abstract void addCondiments(); void boilWater(){ // 煮开水 } void waterInCup(){ // 把水放进水杯 } } 很快小明实现了咖啡和茶： public clsaa Coffee extends Beverage{ void addBeverage(){ // 加咖啡 } void addCondiments(){ // 加其他调料 } } public clsaa Tea extends Beverage{ void addBeverage(){ // 加茶叶 } void addCondiments(){ // 加其他调料 } } 主管说好，我们现在可以开始煮咖啡、泡茶了： public class Customer { public static void main(String[] args){ // 煮咖啡 Beverage coffee = new Beverage(); coffee.made(); // 泡茶 Beverage tea = new Tea(); tea.made(); } } 小明发现这种方式真不错呢，于是请教了主管，这是什么用法。主管说，这叫模板方法模式，我们可以看到在抽象类中，我们定义了一些抽象方法，这些方法由子类去实现，还定义了一些默认实现的方法（boilWater()、waterInCup()），另外还有一个被final修饰的made()方法，我们把这个方法就称为模板方法（不会被子类覆盖），它调用了一些抽象方法和已经实现的方法去实现，抽象方法中的实现不是在抽象类中，而是在子类中，这就是我们的模板方法模式。 定义在一个方法中定义一个算法的骨架，而将一些步骤延迟到子类中。模板方法使得子类可以在不改变算法结构的情况下，重新定义算法中某些步骤。 优点： 模板方法模式在一个类中形式化地定义算法，而由它的子类实现细节的处理 模板方法是一种代码复用的基本技术。它们在类库中尤为重要，它们提取了类库中的公共行为 模板方法模式导致一种反向的控制结构，这种结构有时被称为“好莱坞法则” ，即“别找我们，我们找你”通过一个父类调用其子类的操作(而不是相反的子类调用父类)，通过对子类的扩展增加新的行为，符合“开闭原则” 缺点: 每个不同的实现都需要定义一个子类，这会导致类的个数增加，系统更加庞大，设计也更加抽象，但是更加符合“单一职责原则”，使得类的内聚性得以提高 再加一个方法 public abstract clsaa Beverage{ final void made(){ boilWater(); addBeverage(); waterInCup(); addCondiments(); addIce(); } abstract void addBeverage(); abstract void addCondiments(); void boilWater(){ // 煮开水 } void waterInCup(){ // 把水放进水杯 } void addIce(){ // 不实现 } } 在抽象类里面，我们又加了一个方法，偶尔顾客可能需要在咖啡或者茶里面加冰块，于是增加了addIce()方法。他和之前我们的三种方法都不同，他是一个没有实现的方法——钩子方法。那钩子方法的作用是什么呢，模板方法定义了整个算法，子类实现算法中的一部分，但是仅仅是这样，子类的作用就只是实现，而为了让子类也能做一些决定，于是加入了钩子方法，也就是钩子方法是为了让子类也可以做一些决定，如果它不想做决定，那么不去覆盖钩子方法就可以了。仿佛有点绕了，我们来理一理：抽象对象依赖了实现它的子类，子类的整个功能又依赖了它的抽象父类，父类由依赖了钩子方法，而钩子方法又由子类来决定，这不违背了我们的依赖倒置原则吗？其实它是遵循了我们的另外一个原则好莱坞原则：别调用我们，我们会调用你。子类不需要调用父类，而通过父类来调用子类，子类可以实现父类的可变部份，却继承父类的逻辑，不能改变业务逻辑。 现实中的模板方法使用Java中大家一定使用过Arrays.sort(Object[] array)方法，其实它就是模板方法的一个应用，不过它又和我们上面的实现有所不同，看看排序具体的方法： private static void binarySort(Object[] a, int lo, int hi, int start) { if (DEBUG) assert lo &lt;= start &amp;&amp; start &lt;= hi; if (start == lo) start++; for ( ; start &lt; hi; start++) { @SuppressWarnings(&quot;unchecked&quot;) Comparable&lt;Object&gt; pivot = (Comparable) a[start]; // Set left (and right) to the index where a[start] (pivot) belongs int left = lo; int right = start; if (DEBUG) assert left &lt;= right; /* * Invariants: * pivot &gt;= all in [lo, left). * pivot &lt; all in [right, start). */ while (left &lt; right) { int mid = (left + right) &gt;&gt;&gt; 1; if (pivot.compareTo(a[mid]) &lt; 0) right = mid; else left = mid + 1; } if (DEBUG) assert left == right; /* * The invariants still hold: pivot &gt;= all in [lo, left) and * pivot &lt; all in [left, start), so pivot belongs at left. Note * that if there are elements equal to pivot, left points to the * first slot after them -- that&apos;s why this sort is stable. * Slide elements over to make room to make room for pivot. */ int n = start - left; // The number of elements to move // Switch is just an optimization for arraycopy in default case switch(n) { case 2: a[left + 2] = a[left + 1]; case 1: a[left + 1] = a[left]; break; default: System.arraycopy(a, left, a, left + 1, n); } a[left] = pivot; } } 注意两个地方：Comparable&lt;Object&gt; pivot = (Comparable) a[start]和if (pivot.compareTo(a[mid]) &lt; 0)，首先它将我们做排序的类类型转换成了Comparable接口，而这个接口有一个方法需要实现就是： int compareTo(T another); 大家应该比较清楚了，如果我们需要自定义我们对象的排序规则，就需要实现Comparable，然后实现compareTo方法，根据自己的需求返回不同的值。是不是和我们之前的方式完全不同，但是它的确是模板方法的具体使用。所以，模板方法的使用可能形式多种多样，只要是遵守模板方法的大义，就像这个例子，静态方法sort通过和Comparable的组合实现了排序，但是中心思想也是被比较的对象来实现了排序中的大小比较的规则。等一下！这个方式用策略模式来称呼它不是更合适么？通过组合，不关心实现！所以不得不说一说他们之间的区别，最大的区别：策略模式实现整个算法，而模板方式的子类只是实现了整个算法中的一部分。像上面的排序，整个排序方法是sort，而compareTo方法只是辅助sort方法而已。 还有一个和它类似的模式，他们之间才是有关联的，那就是工厂方法，工厂方法模式是一种特殊的模板方法，特殊就特殊在工厂方法模式的方法是为了专门实例化需要的类。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之适配器模式和外观模式]]></title>
      <url>%2F2016%2F12%2F08%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F%E5%92%8C%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[工厂也来了小明公司的项目越来越多，一家做污水处理的工厂也找上门了，这家污水处理厂最近和一家新的工厂签约了，这家新签约排放污水的工厂之前是和另一个污水处理厂合作，但是之前那家倒闭了，找到了他们，但是他们遇到了一个问题，排放污水的工厂不想改变他们之前排放污水的方式，但是现在这家污水处理厂接收污水的方式又和之前的污水处理厂的接收污水的方式完全不同，所以找到小明他们公司，希望能帮助解决。 这是排放污水工厂之前的方式，排放类： public interface Discharge{ public void oldDischargeSewage(); } 排放实现类： public class OldFactoryDischarge implements Discharge{ // 省略其他细节 public void oldDischargeSewage(){ // 具体的实现 } } 污水排放工厂： public class SewageFactory{ // 用排放类排放 pubclic void discharge(Discharge discharge){ discharge.oldDischargeSewage(); } } 排放： Discharge discharge = new OldFactoryDischarge(); // 工厂不想变动使用排放的方式 SewageFactory sewageFactory = new SewageFactory(); sewageFactory.discharge(discharge); 而新的污水处理厂接收污水并处理的是这样的： public class NewFactoryDischarge { // 省略其他细节 public void newDischargeSewage(){ // 接收污水的实现 } } 小明和主管一起开会讨论，主管说是该适配器登场的时候了。小的主管只让小明新加了一个类： public class FactoryDischargeAdapter implements Discharge{ NewFactoryDischarge newFactoryDischarge; public NewFactoryDischarge(NewFactoryDischarge newFactoryDischarge){ this.newFactoryDischarge = newFactoryDischarge; } public void oldDischargeSewage(){ newFactoryDischarge.newDischargeSewage(); } } 然后新的排放方式就成这样了： Discharge discharge = new FactoryDischargeAdapter(new NewFactoryDischarge()); // 工厂不想变动使用排放的方式和之前没有任何变化 SewageFactory sewageFactory = new SewageFactory(); sewageFactory.discharge(discharge); 小明很快就清楚了这就是适配器模式，接口使用者，在这里也就是污水排放的工厂不想改变旧的排放方式，但接收方又和之前的方式不一样，这样就引进了适配器类，它的作用就是完全的避免使用接口的客户端和实现接口的另一端的耦合。小明的主管又说了，小明，刚才我们使用的这种方式，严格的说它应该叫对象适配器模式，还有另外一种适配器模式，它叫类适配器，你知道该怎么做吗？小明思考了一会，从名字领悟到了这两种方式的区别，然后很快的实现了它： public class FactoryDischargeAdapter extends NewFactoryDischarge implements Discharge{ public void newDischargeSewage(){ // 接收污水的实现 } public void oldDischargeSewage(){ newDischargeSewage(); } } 排放污水： Discharge discharge = new FactoryDischargeAdapter(); // 工厂不想变动使用排放的方式和之前没有任何变化 SewageFactory sewageFactory = new SewageFactory(); sewageFactory.discharge(discharge); 的确，从名字就可以读出，对象适配器是通过适配器和新的需要适配的类组合实现适配，而类的方式没有组合，通过直接继承需要适配的类实现适配，两者用法不同，但是都达到了同样的效果。两种应该在不同的场景下被选择，比如对象的适配器比较适配那些变化不大的，不会有更新扩展的的类，因为一旦对象变化了，需要修改适配器本身去适应新的变化。而类的适配器更适合适配单一的需要适配的类，因为如果适配器中牵扯到多个类时，类的适配方式就不那么灵活了，所以我们应该因材施教。 适配器定义将一个类的接口，装换成客户期望的另一个接口。适配器让原本接口不兼容的类可以合作无间。 对象适配器： 类适配器： 说一说适配器模式和装饰者模式回想一下装饰者模式，好像和适配器非常相似，那么两者有什么区别呢？其实他们的区别从定义就可以总结出来：装饰者会对装饰的组件增加新的责任，也就是功能，但是适配器没有给适配对象增加的责任，而只是让它满足客户的需求，好比有一个中间人，联络着客户和适配方。 标题中的另一种模式文章的标题还提到了另一种模式：外观模式，为什么这次是两个模式一起来讲呢？因为外观模式和适配器模式非常相似，甚至有人任务两种模式是同一种模式，其实不然，外观模式和适配器模式用法是不一样的，也就是他们有各自的用途，我们已经知道适配器模式的用途，那么接下来看看外观模式的用途。 极客小明小明是一名极客，特别喜欢把各种东西攒在一起，这不，他为了给家里营造更好的观影感受，买了一大堆电子产品，有投影仪、自动屏幕、音响、DVD，甚至还有一个爆米花机。但是每次观影时的他是这样的： 打开投影仪 接通自动屏幕 打开调试音响音量 打开DVD放入碟片 将玉米放入爆米花机…… 实在太繁琐了！小明不想做这一切，如果他只需要按一下遥控器，其他的这些动作都不用他去一个一个完成该多好，这时候，外观模式就派上用场了！外观模式是干什么的呢，他就是向外部提供一个接口，然后内部去完成一些复杂的、多步骤的、使用其他很多对象动作的功能。而对于外观的使用者来说，只需要调用一个动作即可，这就是外观模式。所以，小明去国外买了一个机器人，然后让机器人学会了他之前做的上述一切事情，每次小明回家就只对机器人说：我要看电影！然后只需要美美的坐在沙发上稍加等待，就可以开始观看优美的电影了。 以前的小明： openProjector(); openSceen(); openSound(); openDVD(); …… // 观影结束后还要关闭它们（省略）…… 现在的小明： Robot robot = new Robot(); robot.open(); // 观影结束 robot.off(); 我们看到，对于小明来说，之前需要做很多事，现在只需要做很简单的动作就可以了，这就是外观模式给使用者带来的好处。 外观模式的定义提供一个统一的接口，用来访问子系统中的一群接口。外观模式定义了一个高层接口，让子系统更容易使用。 外观模式完美体现了最少知道原则 那么通过对外观模式和适配器模式的深入了解，我们也能很清楚的知道他们之间的不同点了：外观模式是为了让接口更简单，而适配器是为了适配客户的接口。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之命令模式]]></title>
      <url>%2F2016%2F12%2F06%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%91%BD%E4%BB%A4%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[披萨店的生意越来越好小明公司之前给披萨店做了一个项目，主要用了工厂模式，披萨店的老板非常满意，这不，由于披萨店的生意越来越好，小明他们公司又接到了披萨店的新需求。 披萨店招了一名服务员，专门负责顾客的下单，主要职责就是将顾客点的菜单交给做披萨的师傅，然后师傅将披萨做好。现在需要有一套程序来模拟这个场景，小明这次很开心，因为他知道这种就是一个很明确的命令模式的场景：对于顾客来说，每个人点的披萨是不一样的，他们并不关心厨师做披萨的过程，而主要在意是自己的需求能够明确到厨师那里。而服务员主要做的就是将顾客的想法传单到厨师那里，然后一个简单的命令模式就出现了： 芝士披萨厨师： public class CheesePizzaChef { public void createCheesePizza(){ // 做一个芝士披萨 } } 榴莲披萨厨师： public class DurianPizzaChef { public void createDurianPizza(){ // 做一个榴莲披萨 } public void sendGift(){ // 送一个礼物 } } 抽象命令： public interface Order { public void execute(); } 点一个芝士披萨： public class CheesePizzaOrder implements Order{ CheesePizzaChef chef; public CheesePizzaOrder(CheesePizzaChef chef){ this.chef = chef; } public void execute(){ chef.createCheesePizza(); } } 点一个榴莲披萨： public class DurianPizzaOrder implements Order{ DurianPizzaChef chef; public DurianPizzaOrder(DurianPizzaChef chef){ this.chef = chef; } public void execute(){ chef.createDurianPizza(); chef.sendGift(); } } 服务员： public class Service { Order order; public Service(){ } public void setOrder(Order order){ this.order = order; } public void orderUp(){ order.execute(); } } 顾客： public class Customer { public static void main(String[] args){ Service sevice = new Service(); //点一个芝士披萨 CheesePizzaChef cheesePizzaChef = new CheesePizzaChef(); CheesePizzaOrder cheesePizzaOrder = new CheesePizzaOrder(cheesePizzaChef); service.setOrder(cheesePizzaOrder); service.orderUp(); //又点了一个榴莲披萨 DurianPizzaChef durianPizzaChef = new DurianPizzaChef(); DurianPizzaOrder durianPizzaOrder = new DurianPizzaOrder(durianPizzaChef); service.setOrder(durianPizzaChef); service.orderUp(); } } 顾客先点了一个芝士披萨，又点了一个榴莲披萨，可以看到，对于顾客而言，他只用了服务员做了点餐（setOrder()方法），而服务员和厨师之前也没有过多的耦合，服务员就只是再执行了orderUp()方法，然后接下来的的事顾客和服务员就再也没有关心了，那么可以看到里面有很重要的一个类就是实现Order接口的两个类：CheesePizzaOrder和DurianPizzaOrder，他们就被称为命令，命令里面包含了真正的接收者，对于这两个命令，他们的接收者分别是CheesePizzaChef和DurianPizzaChef，也就是最终做事的对象，服务员每次都设置了不同的命令，然后在orderUp()方法了调用命令的execute()方法，命令实现类对execute()做了不同实现，在CheesePizzaOrder里面是调用CheesePizzaChef做了一个芝士披萨，DurianPizzaOrder是DurianPizzaChef做了一个榴莲披萨，而且还送了一个礼物。我们注意到，在两个Order的实现类里，execute()方法用不同的类做了不同的事情，这也是我们命令模式很重要的一点，请求发出者不用关心最终的接收者到底做了什么，任何类都可以接收者，所以命令的接收者彼此之间是独立的（上面的两个厨师并没有关联，我们的接接收者还可以是老板、经理等店里任何可以为顾客服务的人），顾客和最终的接收者之间的桥梁是我们服务员中的命令对象，也就是CheesePizzaOrder和DurianPizzaOrder，这样让顾客和接收者之间是松耦合，同样服务员和接收者之间也是松耦合。 定义命令模式将“请求”封装成对象，以便使用不同的请求、队列、或者日志来参数化其他对象。 角色 抽象命令 Command 具体命令 ConcreteCommand 接收者 Receiver 要求命令对象执行请求 Invoker 创建命令者 Client 接收者不是必须的，具体的命令也可以自己处理一些事 优缺点优点： 降低对象之间的耦合度。 新的命令可以很容易地加入到系统中。 可以比较容易地设计一个组合命令。 调用同一方法实现不同的功能 缺点： 使用命令模式可能会导致某些系统有过多的具体命令类。因为针对每一个命令都需要设计一个具体命令类，因此某些系统可能需要大量具体命令类，这将影响命令模式的使用 命令模式的具体使用对象命令模式的定义大家可能还是很模糊，那我们就再仔细看看命令的使用，加深一下对命令模式的理解。接下来我们实现一个空调遥控器调节风力的功能： 空调： public class AirConditioner { public static final int HIGH = 3; public static final int MEDIUM = 2; public static final int LOW = 1; public static final int OFF = 0; String name; int speed = 0; public AirConditioner(String name){ this.name = name; } public void high(){ // 设置强风 speed = HIGH; } public void medium(){ // 设置低风 speed = MEDIUM; } public void low(){ // 设置弱风 speed = LOW; } public void off(){ // 空调关 speed = OFF; } public int getSpeed(){ return speed; } } 抽象命令： public interface Command { public void execute(AirConditioner airConditioner); public void undo(); } 强风命令： public class ConditionerHighCommand implements Command{ AirConditioner airConditioner; int speed; public void execute(AirConditioner airConditioner){ speed = airConditioner.getSpeed(); this.airConditioner = airConditioner; airConditioner.high(); } public void undo(){ if(speed = AirConditioner.HIGH) airConditioner.high(); else if (speed = AirConditioner.MEDIUM) airConditioner.medium(); else if (speed = AirConditioner.LOW) airConditioner.low(); else if (speed = AirConditioner.OFF) airConditioner.off(); } } 弱风命令： public class ConditionerLowCommand implements Command{ AirConditioner airConditioner; int speed; public void execute(AirConditioner airConditioner){ speed = airConditioner.getSpeed(); this.airConditioner = airConditioner; airConditioner.low(); } public void undo(){ if(speed = AirConditioner.HIGH) airConditioner.high(); else if (speed = AirConditioner.MEDIUM) airConditioner.medium(); else if (speed = AirConditioner.LOW) airConditioner.low(); else if (speed = AirConditioner.OFF) airConditioner.off(); } } 关闭命令： public class ConditionerLowCommand implements Command{ AirConditioner airConditioner; int speed; public void execute(AirConditioner airConditioner){ speed = airConditioner.getSpeed(); this.airConditioner = airConditioner; airConditioner.off(); } public void undo(){ if(speed = AirConditioner.HIGH) airConditioner.high(); else if (speed = AirConditioner.MEDIUM) airConditioner.medium(); else if (speed = AirConditioner.LOW) airConditioner.low(); else if (speed = AirConditioner.OFF) airConditioner.off(); } } 空命令: public class NoCommand implements Command{ public void execute(AirConditioner airConditioner){ // 什么也不做 } public void undo(){ // 什么也不做 } } 遥控器： public class RemoteControl { // 记录最后一次命令，首次为空命令 Command lastCommand = new NoCommand(); //遥控器上一共有4个按钮：除了撤销，其他按钮是可以自由让它有特定的功能 Command[] commands; public RemoteControl(Command[] commands){ commands = commands; } public void onePressed(AirConditioner airConditioner){ commands[0].execute(airConditioner); lastCommand = commands[0]; } public void twoPressed(AirConditioner airConditioner){ commands[1].execute(airConditioner); lastCommand = commands[1]; } public void threePressed(AirConditioner airConditioner){ commands[2].execute(airConditioner); lastCommand = commands[2]; } // 撤销按钮被按 public void undoPressed(){ lastCommand.undo(); } } 人： public class People { public static void main(String[] args){ Command[] commands = new Command[3]; commands[0] = new ConditionerHighCommand(); commands[1] = new ConditionerLowCommand(); commands[2] = new ConditionerOffCommand(); // 暂且给三个按钮赋予这三个相应的功能，强风、弱风、关闭功能 RemoteControl rc = new RemoteControl(commands); AirConditioner airConditioner = new AirConditioner(&quot;客厅的空调&quot;); rc.twoPressed(airConditioner); rc.onePressed(airConditioner); rc.twoPressed(airConditioner); rc.undoPressed(airConditioner); // 最终风速为？ } } 我们可以按遥控器了，每一次按了以后，接收者空调会做出相应的处理（除了撤销按钮），处理由被赋予按钮的命令决定，而且我们还可以更换三个按钮为其他功能，比如已经有的一个命令：空命令，如果实例化空调时，给其中一个按钮赋予空命令职责，他将什么都不会做，空命令在也是一个有非常大用处的命令。不过这个遥控器的还有很多需要优化的地方，比如撤销按钮，目前看来，撤销只能撤销前一次操作（恢复到前一次操作后的状态），大家可以再优化一下，看看怎么实现连续撤销功能，这也和命令模式的一个很重要的作用类似：实现事务系统。 还有哪些用法队列请求命令模式可以用来实现一个异步耗时队列请求的功能，我们可以实现一些列不同的命令，这些命令可能是某一个功能，也可能是一组功能，我们创建很多不同的命令，把他们放进一个队列，然后可能会有另一个线程从队列里面取出这些命令，挨个去执行他们。 状态恢复当我们程序执行一些命令，我们可以将每一次的执行的命令写进我们的日志，当电脑死机重启后，我们将日志信息读取出来，然后再挨个的去执行这些命令，让电脑恢复到之前死机时候的状态。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之单例模式]]></title>
      <url>%2F2016%2F12%2F05%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[小明请假了，直入主题单例模式，望文生义，就是只有一个实例的类，我们真的需要这种只有一个实例的类吗？答案的肯定的，在平时的程序中，单例也是我们经常会遇见和使用的，现在我们就来深入的认识一下单例模式。 用途我们都知道单例模式的用途很多，那么具体哪些情况下会使用它呢？现在我们就来总结一下：线程池、缓存、对话框、处理偏好设置和注册表对象、日志对象、充当打印机、显卡等设备的驱动程序对象等等……在这些情况下，一般我们不需要也不允许存在多个对象，如果不这样，可能会给我们带来一些问题。单例模式我们一定要清楚一点，就是在程序中有且只有一个类的实例。 如何确保只有一个实例我们都知道，实例化对象的方式是通过new的方式，那么其实我们可以在很多地方通过new的方式生成一个类的实例，如果只能让类有一个实例，我们就必须去屏蔽这种做法，让这个类不能通过这种方式去实例化，那么可以这样做吗？好消息是：在Java中，我们可以申明一个私有的构造方法，像这样 public MyClass { private MyClass(){ } } 这样，我们的类就不能被实例化了，那么新的问题来了，我们怎么实例化那唯一的一个实例呢？在类的外部我们不能访问这个类的构造函数，但是在类的内部我们可以访问啊，但是这个类没有实例化，我们不能访问它啊！这不就成了先有蛋还是先有鸡的问题了么，其实不然，我们不能用它的实例对象名，我们可以访问它的类名啊，在Java中可以通过类名去访问一个静态的方法，在这个方法中我们就可以实例化这个唯一个的对象： public MyClass { private MyClass(){ } public static MyClass getInstance(){ return new MyClass(); } } 似乎还有一些问题，我们并没有确保唯一性，所以稍微修改一下： 方法一（懒汉式）： public Singleton { private static Singleton instance; private Singleton(){ } public static Singleton getInstance(){ if(instance == null){ instance = new Singleton(); } return instance; } } 代码很容易理解，在单线程中，我们要获得这个类的实例，只能通过Singleton.getInstance()方法去得到，而且返回的实例永远都是同一个（第一次会先实例化）。那么这就是一个单例模式的实现。 定义单例模式确保只有一个实例，并提供一个全局访问点。 优点 单例模式会阻止其他对象实例化其自己的单例对象的副本，从而确保所有对象都访问唯一实例 因为类控制了实例化过程，所以类可以灵活更改实例化过程 缺点 虽然数量很少，但如果每次对象请求引用时都要检查是否存在类的实例，将仍然需要一些开销。可以通过使用静态初始化解决此问题 还有更重要的事我们可以看到，单例模式的缺点很少，这也是因为他足够简单（但是作用很大），那么先解决上面缺点说的解决每次都检查实例是否存在的问题，解决他的方式也是实现单例模式的一种很重要的方式之一：饿汉式 public class Singleton{ private static final Singleton instance = new Singleton(); private Singleton(){ } public static Singleton getInstance(){ return instance; } } 这样，在类被加载时，我们需要的那个唯一的实例就存在了，以后的每一次访问都是那同一个实例。但是这样的就完美了吗？在某些情况下，它是完美的，就是我们的这个实例所占的资源很少，并且在程序的生命周期里，它是一定会被使用的。这样，我们就可以使用这种方式，否则这种方式可能会造成一些资源的浪费。那么如果有那种占用资源很多，还可能不会被使用的单例，我们怎么去设计呢？很容易想到，在我们真正使用到它的时候才去实例化它，就如我们上面的懒汉式。但在大多数情况下，我们的程序是多线程的，所以使用上面的方法一会出现一个问题，因为我们的new不是原子操作，所以在多线程情况下，还是会出现多实例化的情况。我们知道在多线程情况下，为了防止某个资源同时被多个线程访问，我们需要给它加锁进行同步： public class SingletonClass{ private static SingletonClass instance; public static synchronized SingletonClass getInstance(){ if(instance==null){ instance=new SingletonClass(); } return instance; } private SingletonClass(){ } } 这种方式防止了在多线程情况下会出现的问题，并且是在需要的时候才去实例化它。但是它完美了吗？同样的，在某些情况下它是完美的。因为加锁同步的方式会比不加锁的方式更低效，而且懒汉式的单例模式每次访问单例时都会加锁再释放锁，所以会失去一些效率。所以，懒汉式的方式在我们对效率要求不那么严苛的情况下，它是完美的。那如果我们对效率有要求，单例又很占用资源，还可能不会经常使用到它，那么在这种情况下有完美的方式吗？答案是肯定的，那就是双重检查加锁： public class SingletonClass{ private volatile static SingletonClass instance; public static SingletonClass getInstance(){ if(instance == null){ synchronized(SingletonClass.class){ if(instance == null){ instance=new SingletonClass(); } } } return instance; } private SingletonClass(){ } } 如果对性能的要求极高，而且单例被访问的频率很高，双重检查加锁的方式是可取的，否则这种方式可能会是杀鸡用了牛刀。那么这种方式是怎么避免效率的损失呢，可以看到，我们不是每一次都对资源进行了加锁，而是当知道单例对象为空时再加锁，这样就只会在第一次会出现加锁，不会有效率问题（同样会有每一次的为空判断）。那么volatile的作用呢？模拟一下，ThreadOne到第一个为空判断时，发现instance为空，这时候系统将资源给ThreadTwo，由于ThreadOne还没来得及对单例实例化，所以ThreadTwo任然判断instance为空，所以会继续往下实例化instance，实例化完成以后，ThreadOne继续往下走……现在明白了吧，如果没有volatile的修饰，在ThreadOne中的instance还是为空，有了volatile，会更新ThreadOne中的instance，这样再第二次判断为空时，instance已经不再为空了，就不会再实例化了。明白刚刚说的为什么这是牛刀了吧！ 单例的新鲜实现化在Android中，我们会经常使用一个类就是LayoutInflater，用它将我们的布局文件转化成具体的View控件，其实在程序中我们的LayoutInflater就是一个单例，我们看看它如何实现： LayoutInflater.java中from方法 public static LayoutInflater from(Context context) { LayoutInflater LayoutInflater = (LayoutInflater)context .getSystemService(Context.LAYOUT_INFLATER_SERVICE); if (LayoutInflater == null) { throw new AssertionError(&quot;LayoutInflater not found.&quot;); } return LayoutInflater; } 最终会调用到Contextimpl.java中的 @Override public Object getSystemService(String name) { return SystemServiceRegistry.getSystemService(this, name); } 然后是SystemServiceRegistry中的getSystemService(ContextImpl ctx, String name)方法，这个方法是这样的 private static final HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt; SYSTEM_SERVICE_FETCHERS =new HashMap&lt;String, ServiceFetcher&lt;?&gt;&gt;(); public static Object getSystemService(ContextImpl ctx, String name) { ServiceFetcher&lt;?&gt; fetcher = SYSTEM_SERVICE_FETCHERS.get(name); return fetcher != null ? fetcher.getService(ctx) : null; } private static &lt;T&gt; void registerService(String serviceName, Class&lt;T&gt; serviceClass,ServiceFetcher&lt;T&gt; serviceFetcher) { SYSTEM_SERVICE_NAMES.put(serviceClass, serviceName); SYSTEM_SERVICE_FETCHERS.put(serviceName, serviceFetcher); } 可以看到我们的对象是从一个map中通过key的方式取出来的，而单例的对象又是通过registerService(String serviceName, Class serviceClass, ServiceFetcher serviceFetcher)方法将服务类单例添加到map中的。这也是一种Android中单例模式的使用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之工厂模式]]></title>
      <url>%2F2016%2F12%2F04%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[又来了新的项目这一天，小明主管找到小明说：我们之前的项目里面其实有很多通过new的方式去创建对象，而且是创建的一些实际的对象，这样的做法是不太好的。小明很诧异，不通过new方式，还有其他的方式创建？主管对小明说：没事，做了我们的项目你就明白这一切了。这次我们的新项目是做给一家披萨店的，我和你一起来做这个项目，你先做，我再做进一步的改进。 小明很快做了一个版本出来： Pizza orderPizza(String type) { Pizza pizza; if(type.equals(&quot;cheese&quot;)){ pizza = new CheesePizza(); }else if(type.equals(&quot;greek&quot;)){ pizza = new GreekPizza(); }else if(type.equals(&quot;durian&quot;)){ pizza = new DurianPizza(); } pizza.prepare(); pizza.make(); pizza.cut(); pizza.box(); return pizza; } 主管对小明说：如果我现在有新种类的Pizza，你的程序会犯了什么问题？小明一下发觉了问题所在，代码里面除了make()方法以外，上面的都是变化的，我应该把它们独立出来： public class SimplePizzaFactory{ public Pizza createPizza(String type) { Pizza pizza; if(type.equals(&quot;cheese&quot;)){ pizza = new CheesePizza(); }else if(type.equals(&quot;greek&quot;)){ pizza = new GreekPizza(); }else if(type.equals(&quot;durian&quot;)){ pizza = new DurianPizza(); } return pizza; } } public class PizzaStore{ SimplePizzaFactory factory; public PizzaStore(SimplePizzaFactory factory){ this.factory = factory; } public Pizza orderPizza(String type) { Pizza pizza = factory.createPizza(type); pizza.prepare(); pizza.make(); pizza.cut(); pizza.box(); return pizza; } } 主管继续对小明说，嗯，不错，已经慢慢走上正轨了，你现在使用的就是不算是一种设计模式的模式—简单工厂：将对象的创建放在另外的类中去解决，这样能够简单的将变化的部分独立出来，我们再有新的Pizza或者其中一种Pizza不在制作时，可以不用去修改PizzaStore的代码，因为PizzaStore是不应该被经常修改的。但是，简单工厂还不是我们想要的，如果出现了其他加盟店，我们需要将其他加盟店的整个流程都管理起来，那么仅仅只有生成Pizza的工厂是不够的，从准备到装盒的整个流程我们都需要规范其起来（prepare()、make()、cut()、box()方法），不然其他的加盟店只利用我们提供的工厂生产Pizza，而这些流程有自己的方式，那Pizza店的服务就不能统一标准了。那小明问那我们应该怎么改进呢？主管说，很简单，我们使用工厂方法模式： public abstract class PizzaStore{ public Pizza orderPizza(String type) { Pizza pizza = createPizza(type); pizza.prepare(); pizza.make(); pizza.cut(); pizza.box(); return pizza; } abstract Pizza createPizza(String type); } public class ChengDuPizzaStore extends PizzaStore{ Pizza createPizza(String type){ if(type.equals(&quot;cheese&quot;)){ return new CheesePizza(); }else if(type.equals(&quot;greek&quot;)){ return new GreekPizza(); }else if(type.equals(&quot;durian&quot;)){ return new DurianPizza(); }else { return null; } } } 小明说，等等，这种模式怎么又出现了可能会改变的部分啊？而且这和简单工厂的方式区别就是新的创建对象类成了PizzaStore的子类。主管说，你说到关键了，这和简单工厂的方式很相似，但是仅仅只是相似，它和简单工厂的区别很大：简单工厂仅仅只是把对象的创建封装到另一个类中，而工厂方法模式提供了一个框架，所有子类都依靠这个框架（prepare()、make()、cut()、box()），然后把对象的创建交给了子类，因为在Pizza店和其他的一些实际的需求中，子类可能只需要决定产生什么要的东西，而其他的流程都是统一规范的。这里面体现了一个很重要的原则：依赖倒置原则，披萨店在使用Pizza时，没有具体依赖某一种披萨实现自己的流程（prepare()、make()、cut()、box()），而是一个通过依赖于一个Pizza接口。 工厂方法模式定义定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类的实例化推迟到子类。 角色 抽象产品 产品实现 抽象工厂 具体工厂 优缺点优点 在工厂方法中，用户只需要知道所要产品的具体工厂，无须关系具体的创建过程，甚至不需要具体产品类的类名 在系统增加新的产品时，我们只需要添加一个具体产品类和对应的实现工厂，无需对原工厂进行任何修改，很好地符合了“开闭原则” 缺点 每次增加一个产品时，都需要增加一个具体类和对象实现工厂，是的系统中类的个数成倍增加，在一定程度上增加了系统的复杂度，同时也增加了系统具体类的依赖。这并不是什么好事 披萨店的新问题没过多久，主管找到小明说，披萨店在使用我们的程序时，出现了一个问题，披萨店的出售流程是规范了，但是有一些加盟店开始在原料上偷工减料，造成披萨在顾客中的口碑褒贬不一，所以我们需要改进一下，让每个店使用的原料是可以被监控的。小明很快想到了办法，我们将披萨生成（new的时候）统一为一个简单工厂，那么就可以统一知道披萨的生成了。主管说这样表面是解决了问题，但其实这样会使每个店生成的都是一样的，我们的目的是为了监控原料，而非统一原料。所以我们真正需要使用的是抽象工厂模式： public interface PizzaIngredientFactory{ public Dough createDough(); public Sauce createSauce(); public Cheese createCheese(); public Veggies[] createVeggies(); public Clams createClams(); } public abstract class Pizza{ String name; Dough dough; Sauce sauce; Cheese cheese; Veggies[] veggies; Clams clams; public void make(){ } public void cut(){ } public void box(){ } abstract void prepare(); } public class CheesePizza extends Pizza{ PizzaIngredientFactory factory; public CheesePizza(PizzaIngredientFactory factory){ this.factory = factory; } void prepare(){ dough = factory.createDough(); sauce = factory.createSauce(); cheese = factory.createCheese(); veggies = factory.createVeggies(); clams = factory.createClams(); } } 这样一来，我们的披萨名字是一样的，但是不同的地方制作相同披萨的原料可以不一样（自己实现PizzaIngredientFactory），这就是抽象工厂模式。 抽象工厂模式定义提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。 角色 抽象工厂 实现工厂 抽象产品 具体产品 产品族不同的产品等级结构，功能相关联的产品组成的家族。抽象工厂就是创建出分属于不同产品等级机构的对象组成产品族。 优缺点优点： 抽象工厂模式隔离了具体类的生产，使得客户并不需要知道什么被创建 当一个产品族中的多个对象被设计成一起工作时，它能保证客户端始终只使用同一个产品族中的对象 增加新的具体工厂和产品族很方便，无须修改已有系统，符合“开闭原则” 缺点： 增加新的产品等级结构很复杂，需要修改抽象工厂和所有的具体工厂类，对“开闭原则”的支持呈现倾斜性]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之装饰器模式]]></title>
      <url>%2F2016%2F12%2F03%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A3%85%E9%A5%B0%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[经典咖啡厅问题小明的公司又接到了新的项目，这次是要做程序的是一家咖啡厅，他们需要把他们的咖啡好好的管理起来，小明了解需求以后，很快就根据咖啡店的情况设计出了第一版咖啡厅程序： 很快，新的需求来了，由于顾客的增多，有许多客户对咖啡有特殊的要求，如加奶、加糖，巧克力风味的等等，加了不同料的咖啡价格是不一样的。小明很快就着手开始新建更多类，加奶焦糖玛奇朵，巧克力摩卡……但这时的他突然发现有问题：相同的咖啡，因为加料的不同出现了很多的配搭，会导致严重的类剧增。 小明立即请教了主管，并提出了新的解决方案，给Coffee接口增加方法，如setMilk()、hasMilk()等方法来确保某一个咖啡是加了哪些其他调料的，但是一个问题直接就否定了这样设计：如果我要加双倍调料呢？而且如果出现了一种新的不能加任何调料的饮料时，就会违背接口隔离原则，小明陷入了很大的困难之中，这是主管让小明去了解一下装饰器模式，然后再做出新的设计，小明再了解之后，很快做出了新的设计： 定义小明用的设计模式就叫装饰者模式：动态的将责任附加到对象上。若要扩展功能，装饰者提供了比继承更有弹性的替代方案。 角色 抽象组件（Component） 具体组件（Concrete Component） 装饰（Decorator） 具体装饰角色（Concrete Decorator） 注意：装饰者模式并非针对具体的组件进行装饰 真实世界的装饰者：Java I/O 这是Java I/O中字节输入流的类图结构，我们发现和咖啡厅的设计几乎是一样的，不同的是InputStream是通过抽象类实现，而非接口。我们把左边的三个类（FileInputStream、 StringBufferInputStream、ByteArrayInputStream，不止这是三个）在装饰者模式中称为组件，而把继承至FilterInputStream的类称之为装饰者，装饰者就是用来装饰组件的。看看I/O内部BufferedInputStream是怎么修饰的呢？我们可以用BufferedInputStream来修饰FileInputStream，如果不用BufferedInputStream修饰，直接使用FileInputStream，在调用read()方法时，我们每读出一个字节，就需要做处理，使用了BufferedInputStream，它会给我们提供一个缓冲区，这个缓冲区可以我们自定义大小，也可以使用BufferedInputStream的默认8兆的大小，缓冲区都作用就是将读取出来的数据缓存起来供我们使用，而不是读取一个字节就要使用。 装饰者模式的优缺点和体现的原则优点： 不用继承扩展了类的功能 装饰者可以叠加使用，创造不同的功能，体现了不针对实现的编程 缺点： 程序复杂性会增加 会出现很多小类 针对抽象组件编程，而非具体组件 原则 多有组合，少用继承 开闭原则：对扩展开发，对修改关闭]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之观察者模式]]></title>
      <url>%2F2016%2F12%2F02%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[论坛每日精选项目小明的公司又接到了新的项目，这次的项目是一个论坛管理员给他们的论坛做的，论坛每天会选出优秀的文章发给读者，读者需要订阅这个推送，小明不太明白从何入手，于是请教了他的主管…… 然后小明的主管很快设计出了两套程序让小明选择， 程序A: 程序B: 程序A和B都是通过注册的方式将观察者关联到可观察者中，当有新的文章时，在notifyObservers()方法中调用所有Observer的update()方法。主管问小明我们应该选择哪一个呢？小明仔细分析了A和B，然后说选择B。主管说，A中我用的JDK中的可观察者类（java.util.Observable），为什么不选择A呢，还要自己定一个接口去做和Observable做差不多的事呢？小明说，上个项目用到策略模式时，有一个原则：针对接口编程，如果我们用继承的方式，会有很多问题： 1）如果ArticleData还需要干其他事情，因为Java不能多继承，所以会陷入两难 2）建立自己的实现时，破坏对扩展开发，对修改关闭的原则。因为Observable中已经对注册、删除、更新做了自己的实现 3）直接使用Observable时，很大的情况下Observable无法满足我们的需求 主管补充了一条： 4）JDK中的Observable在调用notifyObservers()时，依赖与setChanged()中的changed(boolean)，可能不是我们需要的 还有一个需要注意的地方：注意Observable中的存放Observer的Vector是倒序遍历的，所以要注意调用Observer update()方法的顺序和我们注册时的顺序是相反的。另外一个值得我们关注的地方，对于更新，我们可以有两种方式：被观察者主动推和观察者自己取拉。JDK中Observable的notifyObservers(Object)和notifyObservers()体现了这两种不同的方式。 定义在对象之间建立一对多的依赖，这样一来，当一个对象改变状态，依赖它的对象会受到通知，并自动更新。优缺点优点： 观察者模式在被观察者和观察者之间建立一个抽象的耦合。被观察者角色所知道的只是一个具体现察者聚集，每一个具体现察者都符合一个抽象观察者的接口。被观察者并不认识任何一个具体观察者，它只知道它们都有一个共同的接口。由于被观察者和观察者没有紧密地耦合在一起，因此它们可以属于不同的抽象化层次 观察者模式支持广播通信。被观察者会向所有的登记过的观察者发出通知 缺点： 如果一个被观察者对象有很多直接和间接的观察者的话，将所有的观察者都通知到会花费很多时间 如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。在使用观察考模式时要特别注意这一点 如果对观察者的通知是通过另外的线程进行异步投递的话，系统必须保证投递是以自恰的方式进行的 虽然观察者模式可以随时使观察者知道所观察的对象发生了变化，但是观察者模式没有相应的机制使观察者知道所观察的对象是怎么发生变化的 观察者模式中体现的原则找出变化的部分，和不变的地方分离改变的是关注者的数量和类型，所以观察者被分离出来了 针对接口编程，不针对实现编程被观察者和观察者都使用接口，观察者利用被观察者接口注册、取消注册，被观察者利用观察者的更新接口通知观察者。这样让两者之间独立运作，具有松耦合的优点 多用组合，少用继承被观察者和观察者是通过关联在一起，而不是通过继承的方式 观察者模式的运用如在Java中JButton的监听事件注册；另外在Android中的控件适配器Adapter这一功能，我们的控件（ListView、RecycleView、GridView等）里面都有一个观察者实现类通过继承AdapterDataSetObserver实现了对变化的观察，在setAdapter()时，将该实现了对象注册到Adapter中。看一看源码一下就清楚了： BaseAdapter.java public abstract class BaseAdapter implements ListAdapter, SpinnerAdapter { private final DataSetObservable mDataSetObservable = new DataSetObservable(); /……/ public void registerDataSetObserver(DataSetObserver observer) { mDataSetObservable.registerObserver(observer); } public void unregisterDataSetObserver(DataSetObserver observer) { mDataSetObservable.unregisterObserver(observer); } /** * Notifies the attached observers that the underlying data has been changed * and any View reflecting the data set should refresh itself. */ public void notifyDataSetChanged() { mDataSetObservable.notifyChanged(); } /** * Notifies the attached observers that the underlying data is no longer valid * or available. Once invoked this adapter is no longer valid and should * not report further data set changes. */ public void notifyDataSetInvalidated() { mDataSetObservable.notifyInvalidated(); } /……/ } AbsListView.java public abstract class AbsListView extends AdapterView&lt;ListAdapter&gt; implements TextWatcher, ViewTreeObserver.OnGlobalLayoutListener, Filter.FilterListener, ViewTreeObserver.OnTouchModeChangeListener, RemoteViewsAdapter.RemoteAdapterConnectionCallback { AdapterDataSetObserver mDataSetObserver; /……/ class AdapterDataSetObserver extends AdapterView&lt;ListAdapter&gt;.AdapterDataSetObserver { @Override public void onChanged() { super.onChanged(); if (mFastScroll != null) { mFastScroll.onSectionsChanged(); } } @Override public void onInvalidated() { super.onInvalidated(); if (mFastScroll != null) { mFastScroll.onSectionsChanged(); } } } /……/ } ListView.java public class ListView extends AbsListView { /……/ @Override public void setAdapter(ListAdapter adapter) { if (mAdapter != null &amp;&amp; mDataSetObserver != null) { mAdapter.unregisterDataSetObserver(mDataSetObserver); } resetList(); mRecycler.clear(); if (mHeaderViewInfos.size() &gt; 0|| mFooterViewInfos.size() &gt; 0) { mAdapter = new HeaderViewListAdapter(mHeaderViewInfos, mFooterViewInfos, adapter); } else { mAdapter = adapter; } mOldSelectedPosition = INVALID_POSITION; mOldSelectedRowId = INVALID_ROW_ID; // AbsListView#setAdapter will update choice mode states. super.setAdapter(adapter); if (mAdapter != null) { mAreAllItemsSelectable = mAdapter.areAllItemsEnabled(); mOldItemCount = mItemCount; mItemCount = mAdapter.getCount(); checkFocus(); mDataSetObserver = new AdapterDataSetObserver(); mAdapter.registerDataSetObserver(mDataSetObserver); mRecycler.setViewTypeCount(mAdapter.getViewTypeCount()); int position; if (mStackFromBottom) { position = lookForSelectablePosition(mItemCount - 1, false); } else { position = lookForSelectablePosition(0, true); } setSelectedPositionInt(position); setNextSelectedPositionInt(position); if (mItemCount == 0) { // Nothing selected checkSelectionChanged(); } } else { mAreAllItemsSelectable = true; checkFocus(); // Nothing selected checkSelectionChanged(); } requestLayout(); } /……/ } 代码很清晰，在AbsListView中实现了一个观察者内部类，并在setAdapter()时，实例化了这个实现类，将它注册到了Adapter中，当Adapter中数据有更新时，就会调用观察者的更新方法，也就是AbsListView中的那个观察者中的onChanged方法。一般情况下，Adapter就只有一个观察者，我们可以通过调用Adapter中的registerDataSetObserver(DataSetObserver)方法增加观察者，可以观察Adapter的数据变化。大家可以想一想他和我们上面的实现有什么区别，然后为什么是这样的呢？思考一下………… 被观察者通过实现接口，而观察者是通过继承然后和AbsListView组合的方式构成的。为什么AbsListView不直接是观察者呢？就是我们上面说的，如果直接通过AbsListView继承Observable，那么AbsListView将不能再继承自View，这也是JDK种我们Observable不是一个接口会出现的问题，我们需要换一种方式去表示我们的被观察者，自己定义一个接口或者和JDK的Observable实现类组合使用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式之策略模式]]></title>
      <url>%2F2016%2F12%2F01%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F%2F</url>
      <content type="text"><![CDATA[马戏团问题现在程序员小明需要设计一个关于马戏团的程序，最初，马戏团只有一个人，也只有一个动物（猴子），因此，小明很快就设计出来了： 没过多久，马戏团又来了一只猴子，会表演跳舞，于是小明将程序改成了： 后来，马戏团的猴子越来越多，小明发现，每次来了一种会不同表演的猴子，都必须重新增加相应的类，并覆盖相应的perform()方法，小明发现这样程序这样下去会变得不好维护： 代码在多个子类中重复（有其他会表演跳舞的动物） 运行时行为不容易改变（比如有一只什么都不会表演的猴子学会了戴帽子） 牵一发动全身（修改父类的perform()方法，会造成不该改变的猴子改变） 很难知道猴子所有的表演 此时，小明的主管告诉小明，设计或者修改程序时，我们遵循一个原则：找出类中的变化部分，将它独立出来。小明首先想到了接口，用接口去表示猴子不同的表演，然后让不同的猴子去实现不同表演，但是仔细一想，上面的1）2）还是不可避免。这时，小明的主管说，把猴子的表演单独成一个类，然后和猴子通过组合模式进行组合，然后猴子的表演行为用其他一些类去实现，并且要记住：面向接口编程。小明经过深思熟虑，设计出了新的程序： 这样，我们再增加猴子时，只需要增加不同的表演实现类即可，如果来了其他会跳舞的动物，我们也可以复用表演实用类。那么主管给说小明说的面向接口编程又体现在哪里呢？注意Animal，与它组合的并不是具体实现的表演类，而是一个抽象出来的表演行为类（PerformBehavior），这也是设计模式中的依赖倒置原则 定义你刚刚看到的就是策略模式，定义：定义了方法族，分别封装起来，让他们相互之间可以替换，此模式让算法的变化独立于使用算法的客户，那么上面的表演行为就是一些列算法，而猴子就是使用它的客户，算法可以自己新增、修改而并不需要修改客户。我们也可以从上面的例子得出一个结论：组合比继承更好（有一个比是一个好）。 角色 客户：方法的调用者 抽象策略 具体策略 优缺点优点 策略模式提供了管理相关的算法族的办法。策略类的等级结构定义了一个算法或行为族。恰当使用继承可以把公共的代码转移到父类里面，从而避免重复的代码。 策略模式提供了可以替换继承关系的办法。继承可以处理多种算法或行为。如果不是用策略模式，那么使用算法或行为的环境类就可能会有一些子类，每一个子类提供一个不同的算法或行为。但是，这样一来算法或行为的使用者就和算法或行为本身混在一起。决定使用哪一种算法或采取哪一种行为的逻辑就和算法或行为的逻辑混合在一起，从而不可能再独立演化。继承使得动态改变算法或行为变得不可能。 使用策略模式可以避免使用多重条件转移语句。多重转移语句不易维护，它把采取哪一种算法或采取哪一种行为的逻辑与算法或行为的逻辑混合在一起，统统列在一个多重转移语句里面，比使用继承的办法还要原始和落后。 缺点： 客户端必须知道所有的策略类，并自行决定使用哪一个策略类。这就意味着客户端必须理解这些算法的区别，以便适时选择恰当的算法类。换言之，策略模式只适用于客户端知道所有的算法或行为的情况。 策略模式造成很多的策略类，每个具体策略类都会产生一个新类。有时候可以通过把依赖于环境的状态保存到客户端里面，而将策略类设计成可共享的，这样策略类实例可以被不同客户端使用。换言之，可以使用享元模式来减少对象的数量。 啰嗦一下继承（抽象、多态、封装）是我们的OO思想，我们可以用OO思想写出很多程序，但是为什么会出现设计模式呢？其实，设计模式就是在OO思想之后出现，工程师们一点一点总结出来的，它不是被发明的，而是被发现的。它是为了我们写出更容易扩展、修改和理解的程序，要知道软件开发过程中唯一不变得就是变化，所以设计模式有很多好处： 共享词汇，最大化沟通交流的价值 有利于程序的变化 有利于程序的理解 有利于程序的维护 有利于程序的复用]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[设计模式六大原则]]></title>
      <url>%2F2016%2F11%2F29%2F%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E5%85%AD%E5%A4%A7%E5%8E%9F%E5%88%99%2F</url>
      <content type="text"><![CDATA[开闭原则定义：对扩展开放，对修改关闭在平时我们程序迭代更新的过程当中，往往会对现有的功能进行修改，但是这样又往往会对我们的程序造成破坏甚至带来致命的错误，所以在对程序进行修改时，尽量不要修改原有的功能，而是通过扩展的方式增加新功能。开闭原则算是六大原则中的一个总原则，之后的五大原则都遵循这个总的开闭原则。 单一职责原则定义：一个类只负责一项职责（同样适用于方法和接口）当在设计一个类时，我们应该注意一个类应该只能具有某一种功能，而不能有多个。同样在重构时，如果发现某一个同时负责着多个功能，应该将它的功能进行拆分。此原则是为了防止我们一个类有多个职责时，我们在修改它的其中一个职责时，可能会对另外的职责功能造成影响。 里氏替换原则定义：在程序中，子类可以完整的替换父类完成父类的功能通俗的说，当使用继承时，子类可以可以扩展父类的功能，但不能改变父类的功能。主要有四层含义： 1）子类可以实现父类的抽象方法，但不能覆盖父类的非抽象方法 2）子类中可以增加自己特有的方法 3）当子类的方法重载父类的方法时，方法的前置条件（即方法的形参）要比父类方法的输入参数更宽松 4）当子类的方法实现父类的抽象方法时，方法的后置条件（即方法的返回值）要比父类更严格 依赖倒置原则定义：高层模块不应该依赖低层模块，二者都应该依赖其抽象；抽象不应该依赖细节，细节应该依赖抽象从定义看，有两层意思，分别解释，首先，高层模块不应该依赖底层模块：类A与类B存在依赖关系（何为依赖），当我们需要将类A修改为依赖于类C，这个时候，我们就需要修改类A。这种情况中，类B类C属于底层模块，类A属于高层模块，我们要做到不修改类A，那么我们的类A就不能依赖类B和类C(底层模块)，所以，我们需要将类A依赖改为类B类C的抽象，也就是类B类C实现同一接口，无论之后类需要依赖哪个类，我们都不再需要修改类A了。抽象不应该依赖细节，细节应该依赖抽象：在进行抽象时，不关注具体的细节，也就是具体的实现，而在具体实现时，要依赖抽象，有点不好理解。通俗的说，我们在设计一个框架时，首先要通过抽象的方式搭建，在Java中就是通过抽象类和接口的方式，而具体的实现通过抽象类和接口来实现实现类。依赖原则的中心思想就是面向接口编程。 接口隔离原则定义：实现类不应该依赖它不需要实现接口具体方法的接口接口I需要实现方法a、b、c，具体实现类A实现方法a、b，实现类B实现a、c。A,B都需要实现它们不需要的方法，就违背了这个原则，解决方法其实很简单，就是对接口I进行拆分，然后A和B取分别实现它需要的接口。 迪米特法则定义：一个对象应该对其他对象保持最少的了解迪米特法则又可以叫最少知道原则，就是一个类依赖另一个类时，应该对它的依赖类知道得越少越好，也就是降低类和类的耦合。违背这个原则带来的问题是显而易见的：类和类的之间的耦合过高，修改一个类时，会影响其他的类，所以我们要做到低耦合，高内聚。如何避免知道过多的对象，在该对象的方法内，我们应该调用属于以下范围的方法： 该对象本身 被当着方法的参数而传递进来的对象 此方法所创建或实例化的任何对象 对象的任何组件（组合关系）]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java内存回收简介]]></title>
      <url>%2F2016%2F09%2F12%2FJava%E5%86%85%E5%AD%98%E5%9B%9E%E6%94%B6%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[前言大家都知道，C++的内存管理是由开发人员自己掌握的，而Java则是自动完成的，那么它是怎么实现的呢？在前人们设计垃圾收集技术时，解决了下面三件事情： 1）那些内存需要回收？ 2）什么时候回收？ 3）如何回收？ 那些内存需要回收和什么时候回收要确认那些对象可以回收，就需要确认该对象实例是否已经不再被使用了，那么常见的实现由哪些呢？ 引用计数法此方法的实现为：给每一个对象实例添加一个引用计数器，每当有一个地方引用它了，该计数器就加一。当对象引用计数器为零的时候，说明没有再引用它的地方了，所以该对象实例“死了”，可以被回收了。那么是不是这种算法就可以了呢？但是实际情况中，主流的一些Java虚拟机并没有采用此算法，原因是因为，当遇到循环引用的情况时，就不好处理了。 Java采用的算法：可达性分析算法该算法通过一些列可以作为“GC Roots”的对象作为起始点，从这些节点向下搜索，搜索所走过的路径称为引用链（Reference Chain），当一个对象到GC Roots没有任何引用链相连时，说明该对象已死（不过不一定就被回收，可以自救，但是实际情况中不会这么做）。在Java中，可以作为GC Roots对象的对象包括： 1）栈帧中的局部变量引用的对象 2）方法区静态变量引用的对象 3）方法区中常量引用的对象 4）本地方法栈中Native方法里应用的对象 延伸上面讲的是堆中的垃圾回收，在Java中，除了堆中会有垃圾回收，还有其他内存区域有内存回收吗？是有的，那就是方法区，方法区中存放的是和类相关的一些信息，那么如果确定那些类可以被回收呢： 1）该类的所有实例都被回收，在堆中已经不存在该类的实例 2）加载该类的ClassLoader已经被回收 3）该类对应的Class对象没有在任何地方被引用，无法在任何地方通过反射访问该类的方法 如何回收如何回收已经成为垃圾对象实例，也有很多不同的算法，每种算法有它的优势和劣势。 标记-清除算法这种算法是最容易理解的，它就是通过上面可达性分析算法后，标记出已死的对象实例，然后将这些区域的内存进行回收。不过它有两个明显的不足： 1）标记和清除两个步骤的效率很低 2）由于被回收的区域可能是不连续的，所以当需要连续内存时，必须提前触发一次垃圾收集动作 复制算法复制的具体实现原理就是将内存分为两块，每次只使用其中一块，当这一块快使用完了的时候，就将这块中还存活的对象复制到另一块中，然后清理掉前一块中的内存空间。这种算法用于商业虚拟机回收新生代，因为新生代的对象98%都是“朝生夕死”，就将这块区域分为一块大的Eden空间和两块较小的Survivor空间，每次使用Eden和其中一块Survivor，当回收时，将较少存活对象复制到另一块Survivor中，清理掉之前使用的Eden和其中一块Survivor。 标记-整理算法标记-整理算法和标记-清除算法的前面步骤是一样的，只是在标记后，并不马上清理，而是让所有存货的对象向一端移动，然后清理掉另一端的边界以外的对象。这种算法和上面的标记-清除算法用于虚拟机中老年代的回收算法。 分代收集法 分代收集法就是根据对象的存活周期将内存划分为两块：新生代和老年代，然后不同的区域采用不同的垃圾回收算法，如上面介绍到的：新生代采用复制算法，老年代采用标记-清除或者标记-整理算法。在实际情况中，当新生代中另一块Survivor区域无法存放下存活下来的对象时，这些对象将进入老年代，那么有哪些情况，新生代的对象会进入老年代呢？ 1）大对象 2）每次Eden进行MinorGC后对象年龄加1进入survivor，对象年龄达到15时进入老年代 3）如果Survivor空间中相同年龄所有对象大小的总和大于survivor空间的一半，年龄大于等于该年龄的对象就直接进入老年代 4）如果survivor空间不能容纳Eden中存活的对象。由于担保机制会进入老年代。如果survivor中的对象存活很多，担保失败，那么会进行一次Full GC]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java内存区域简介]]></title>
      <url>%2F2016%2F09%2F12%2FJava%E5%86%85%E5%AD%98%E5%8C%BA%E5%9F%9F%E7%AE%80%E4%BB%8B%2F</url>
      <content type="text"><![CDATA[前言为什么是简介呢？因为自己实在不敢用详解两字，不过还是希望用简短易懂的语言来描述，使大家能有一个初步的认识，这些内容主要是从《深入Java虚拟机》中同时加入自己的一些零碎知识总结而来的，所以还是希望大家可以多看书，然后总结为自己的知识体系。 线程和进程为什么会提到这两个老生常谈的东西呢？因为Java的内存区域是分为共享和非共享的，那么直接就和线程和进程相关了，线程和进程的区别在这里我就不详细介绍了，不太了解的同学可以看看这篇文章进程与线程的一个简单解释，比较形象和生动。 单核可以多线程吗我们从这个问题入手，看看Java虚拟机是如何实现多线程的。首先，这个问题的答案是肯定的（可以），多个线程会被CPU分配不同的时间，CPU快速的切换（一般在几十毫秒）不同的线程来实现多线程，我们把分配给线程的时间叫着时间片，不停的切换时间片就是上下文切换，在一秒时间里，上下文切换的次数可以达到数千次（2000次左右）。所以接下来第一块我们需要介绍到的，就是在切换中起着很大作用的程序计数器。 运行时数据区 程序计数器程序计数器是一块很小的内存，它是线程私有的，它记录着当前线程Java方法虚拟机字节码指令的地址（如果为Native方法，计数器值为空），为什么需要记录这个东西呢？因为再上下文不断切换时，我们需要保存将被切换线程执行到哪里了，然后再恢复时，可以根据保存的信息进行恢复。在这个内存区域中，是不会出现OutOfMemoryError的，也是内存区域中唯一个。 Java虚拟机栈Java虚拟机栈也是线程私有的，它的生命周期和线程相同。一个线程中有多个方法，每一个方法都会创建一个栈帧，这个栈帧里面保存了局部变量表、操作数栈、动态链接、方法出口等信息。很多个栈帧不断的在虚拟机栈中入栈和出栈，就是这个线程不断的执行，同时随着入栈和出栈，一个方法的调用也执行完成了。 局部变量表一个方法有一个局部变量表，它存放了方法中各种基本数据类型（boolean、byte、char、short、int、float、long、double）、对象引用（reference类型，对象引用不是对象本身，而是指向对象起始地址的引用指针、一个代表对象的句柄或者其他对象的相关位置）、returnAddress类型（指向了一条字节码指令的地址）。虚拟机栈中局部变量表的大小在运行期间是不会变化的，进入一个方法时，这个大小就已经确定了。 异常在虚拟机栈中，可能会发生两种异常：StackOverflowError和OutOfMemoryError。发生这两种异常的情况分别是： 1）线程所请求的栈深度大于虚拟机所允许的深度。 2）如果虚拟机扩展无法申请足够的内存。 这两个描述还是比较模糊的，那么实际情况中，什么情形下会产生这两种不同的异常呢？有一个统一的结论，大家可以实际去证明，那就是：在单个线程下，无论是由于栈帧太大还是栈容量太小（大小是可配置的），但内存无法分配时，都抛出StackOverflowError。在多线程中，线程越多，供每个线程瓜分的虚拟机栈空间越少，当把最后能被瓜分的内存耗尽时，就会抛出OutOfMemoryError。 本地方法栈本地方法栈和Java虚拟机栈作用是非常相似的，Java虚拟机栈是服务于Java方法（也就是字节码），而本地方法栈是服务于Native方法的。甚至有的虚拟机（如HotSpot，目前最新版本JDK使用的虚拟机）直接将这两部分合二为一，所以同样的，本地方法栈也会抛出StackOverflowError和OutOfMemoryError。 Java堆Java堆一般来说是Java虚拟机所管理的内存中最大的一块。它是一块被线程共享的内存区域。他存放的就是对象的实例和数组，如上面提到局部变量中对象引用就可能指向这里。这一块的内容主要就是内存回收相关的东西，这里不再深入，后面单独对内存回收做介绍。无论这块内存有多大，还是会出现无法再扩展的情况，就会抛出OutOfMemoryError异常。 方法区这个区域和堆一样，是线程共享的，它用来存储已被虚拟机加载的类信息（类名、访问修饰符等）、常量、静态变量、即时编译器编译后的代码等数据，因此它是堆得一个逻辑区域。不过大家容易被这个名字所误导，所以需要特别注意。 运行时常量区此区域属于方法区的一部分，在编译时，会产生一些类的常量信息，就存放在此区域中，当然在运行时，也可以产生一些常量，如调用String的intern方法，就会将该常量放入常量池中。在方法区中，如果无法满足内存分配时，将抛出OutOfMemoryError异常。 延伸知识刚才提到，使用String的intern方法，会把常量放入方法区的运行时常量区中，不过JDK 1.6和JDK 1.7有一些区别： 1）1.6intern方法会把首次遇到的字符串实例复制到永久代中，并返回实例的引用。 2）1.7不会复制实例，而是在常量池中记录首次出现的实例引用。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[LeetCode 394.Decode String]]></title>
      <url>%2F2016%2F09%2F08%2FLeetCode%20394.Decode%20String%2F</url>
      <content type="text"><![CDATA[LeetCode新题LeetCode最近好像又更新了，之前刷了100道左右的Easy和Medium，但是之前刷的题都没有写博客，这次写是因为网上的解法还很少，所以发上来供大家查阅。 题意和解法这道题的题意其实很简单，就不过多解释了，看到此类表达式的计算，我们第一个想到的数据结构就是栈，利用栈的先进后出性质进行计算。 过程遍历字符串，遇到数字、字母和[直接进栈，遇到]，然后出栈，先找出所有字母，直到[(也要出栈)，然后再继续出栈找出数字，这里注意数字可能是多位的，比如123[a]，所以出栈的终止条件是栈空或者遇到非数字的字符，通过上面出栈的字符串和数字，组成新的字符串，如字符串2[ab]，新的字符串应该为abab，这些新的字符也必须再重新进栈。就这么简单~ AC代码第一版代码，后面如果优化了会再更新 public static String decodeString(String s) { if (s == null || s.length() == 0) return s; Stack&lt;Character&gt; stack = new Stack&lt;&gt;(); for (char c : s.toCharArray()) { if (c == &apos;]&apos;) { StringBuilder sb = new StringBuilder(); while (!stack.isEmpty() &amp;&amp; ((stack.peek() &gt;= &apos;a&apos; &amp;&amp; stack.peek() &lt;= &apos;z&apos;) || stack.peek() == &apos;[&apos;)) { char ccc = stack.pop(); if (ccc == &apos;[&apos;) break; sb.insert(0, ccc); } if (stack.isEmpty()) { return sb.toString(); } else { int count = 0; int w = 1; while (!stack.isEmpty() &amp;&amp; stack.peek() &gt;= &apos;0&apos; &amp;&amp; stack.peek() &lt;= &apos;9&apos;) { int val = stack.pop() - &apos;0&apos;; count += val * w; w *= 10; } char[] chars = sb.toString().toCharArray(); while (count &gt; 0) { for (char cc : chars) stack.push(cc); count--; } } } else stack.push(c); } StringBuilder sb = new StringBuilder(); while (!stack.isEmpty()) sb.insert(0, stack.pop()); return sb.toString(); }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[马拉车(Manacher)算法]]></title>
      <url>%2F2016%2F08%2F25%2F%E9%A9%AC%E6%8B%89%E8%BD%A6(Manacher)%E7%AE%97%E6%B3%95%2F</url>
      <content type="text"><![CDATA[解决的问题马拉车算法主要是为了解决求一个字符串的最长回文串，当然求解这个问题的算法很多，比如穷举法（轮询所有子串得出最长的是回文串子串），但是时间复杂度太高（复杂度为O(n^3)）。马拉车算法可以有效的降低时间复杂度（复杂度为O(n)）。 原理与实现原理利用已知的对称信息和回文串的对称性得出其他位置的对称信息，并且不用考虑字符串长度是奇数还是偶数的，因为首先我们对字符串进行处理：在字符串的首尾和字符间加上&quot;#&quot;，如&quot;nbbn&quot;改变后为&quot;#n#b#b#n#&quot;，再在首位加上&quot;&amp;&quot;，所以最终经过处理的字符串为&quot;&amp;#n#b#b#n#&quot;。另外我们还需要辅助一个和处理后长度一致的int数组，该数组用来存字符串对应位置的最长回文长度加上本身（就是最长回文数+1），如下： 如字符串第二个b两边对称的长度为1，所以它对应的int数组内的值为2。有了这个表格，我们就知道，只要求出字符串对应位置上int数组的值，那么回文串自然就出来了，那int[]数组怎么求出来呢？也就是怎么利用已知的对称信息和回文串的对称性得出其他位置的对称信息呢？首先假设最长回文所在位置为id，到最长回文长度的位置为idMax,如果我们要求i位置上的最长回文长度（也就是int[i]的值），可以根据int[j]的值，前提条件是(0&lt;=j&lt;i,所以int[j]是已知的)，那么是什么原理呢？分为两种情况： i &lt;= idMax，通过id的位置找到和i位置对称的j点 如过int[j] &lt; idMax - i，那么int[i]就等于int[j]。如果int[j] &gt;= idMax - i，那么int[i]的值大于或者等于int[j]。然后再在这个位置继续向左右延伸判断是否还有回文长度。i &gt; idMax时，所以中心点为i的回文还没有匹配，只有通过循环去匹配了。实现这里就直接用Java代码实现了，每一次算出当前位置的回文长度后，要更新相关信息： public static String longestPalindrome(String s) { if (s.length() &lt;= 1){ return s; } StringBuilder stringBuilder = new StringBuilder(&quot;$&quot;); for (char c : s.toCharArray()) { stringBuilder.append(&quot;#&quot;); stringBuilder.append(c); } stringBuilder.append(&quot;#&quot;); String str = stringBuilder.toString(); int id = 0; int idMax = 0; int index = 0; int maxLength = 0; int p[] = new int[str.length()]; for (int curr = 1; curr &lt; str.length(); curr++) { int j = 2 * id - curr; // p[curr] = idMax &gt; curr ? Math.min(p[symmetryId], idMax - curr) : 1; // 更容易理解的写法 if (idMax &gt; curr) { if (p[j] &lt; idMax - curr) p[curr] = p[j]; else p[curr] = idMax - curr; } else { p[curr] = 1; } while (curr + p[curr] &lt; str.length() &amp;&amp; str.charAt(curr + p[curr]) == str.charAt(curr - p[curr])) { p[curr]++; } if (curr + p[curr] &gt; idMax) { id = curr; idMax = curr + p[curr]; } if (p[curr] &gt; maxLength) { maxLength = p[curr]; index = curr; } } return s.substring((index - maxLength) / 2, (index + maxLength) / 2 - 1); }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java设计模式中类的关系总结]]></title>
      <url>%2F2016%2F08%2F08%2FJava%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B8%AD%E7%B1%BB%E7%9A%84%E5%85%B3%E7%B3%BB%E6%80%BB%E7%BB%93%2F</url>
      <content type="text"><![CDATA[概述在面向对象设计模式中，类与类之间的关系存在6中，分别为：依赖、关联、聚合、组合、继承和实现，它们的耦合度依次增强。下面我们在Java中讨论它们的定义和特点。 汇总 关系 定义 UML图例表示 赋值方式 例子 依赖（Dependence） 类A中使用了类B，其中类B作为类A中方法的参数、方法中的局部变量或者静态方法的调用 无 无 关联（Association） 单向：类A中使用了类B作为成员变量。双向：类A当中使用了类B作为成员变量；同时类B中也使用了类A作为成员变量。类A类B无任何关系 类中赋值 车和房 聚合（Aggregation） 关联的一种，类A和类B存在包容关系，但相互是可以独立的（整体-个体） set方法 人（车和房） 组合（Composition） 关联的一种，类B是类A的一部分，类B不能单独存在（整体-部分），整体代表了部分的生命周期 构造方法中 人（灵魂和肉体） 继承（Generalization） 子类和父类的关系，子类是具有父类的属性和行为，并且扩展了新的能力 无 无 实现（Implementation） 实现一个或多个接口方法的类 无 无 注意1：判断关系通过语义，然后结合上下文判断。 注意2：UML图例的箭头指向。]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[Java异常详解]]></title>
      <url>%2F2016%2F06%2F07%2FJava%E5%BC%82%E5%B8%B8%E8%AF%A6%E8%A7%A3%2F</url>
      <content type="text"><![CDATA[异常和错误首先，我们需要重塑对异常和错误的理解，在我们的程序中，不存在所谓的“异常”，只存在错误，错误会导致我们的程序在运行期无法继续运行，如除数为零、尝试打开不存在的文件、试图使用指向为空的对象引用……如果是上述任意一个情形发生，那么我们的程序都将无法继续运行，当然这些错误都是可以通过编码避免，但如果某一个方法的功能就是实现除法的功能，这个方法无法控制不接受获取除数为零的意外，也无法处理当接收到除数为零时的情况，那么这个时候，你需要从当前环境中抛出一个异常，通知其他环境，这里发生了一个问题，我无法处理，我将它交给你处理（不然程序就中止了）。到这里，大家大概知道了Java中的异常和问题的关系了，异常是Java为了解决在出现问题时发出的一个通知，这个通知到达它该到达的地方，然后在这个地方得到解决，然后使程序继续向错误发生时的情况运行。 Java中的异常结构图Java异常类结构图 ErrorError用来表示编译时和系统错误，一般我们不用关心，这里再重申一个概念，异常是发生错误时被抛出的一个通知，所以Error是在编译时和系统错误时被抛出的异常。 Exception这是我们需要关心的异常，因为当这些异常抛出时，说明了我们程序出现了问题，我们需要处理这些问题。Exception又分为不检查异常和检查异常： 不检查异常 public void method(String s) { if(s == null) throw new NullPointerException(); } 首先，我们在代码中不会写这样的代码，因为这样的情况在我们的中可能数不胜数，如果都需要我们去手动的抛出异常，那么我们的代码会很难维护，那么当出现使用了指向空的引用时，系统会自动帮你抛出，所以我们不用手动抛出所有RuntimeException类型（它的子类）的异常。 其次，当有方法会抛出RuntimeException类型的异常时（系统自动抛出），我们不需要去捕获它（try-catch），所以这类异常被称为`不检查异常`。有经验的大家会知道，往往我们的程序的问题就是出现在这些不被检查的异常，如NullPointerException（经常在一些群中发现新手贴出空指针异常，然后求助……）。所以正因为RuntimeException类型的异常不用我们去捕获，因此我们在Code的时候一定要注意防止RuntimeException的发生。 #### 检查异常 这一类异常抛出时，我们必须去捕获它，如SQLException、XMLStreamException等异常。至于说如何处理，根据具体的业务逻辑来编写处理的代码，那么接下来我们来看看Java中是如何设计异常处理的。 ## 捕获异常 ### 监控区域 如果在方法内部抛出了异常或者在方法内部调用的其他方法抛出了异常，这方法将在抛出异常后终止，如果不希望方法就此终止，那么在方法内设置一个特殊的块来捕获异常，所以称为`try块`： try { // Code that might generate exceptions } ### 异常处理程序 再次强调一下，不被检查的异常编译时不会强制让我们捕获，所以需要大家自己注意这些异常。抛出的异常需要在某处得到处理，这个“地点”就是`异常处理程序`，而且在Java中，针对捕获到的不同异常，有不同的处理程序： try { // Code that might generate exceptions } catch(Type1 t1){ // Handle exceptions of type1 } catch(Type2 t2){ // Handle exceptions of type2 } catch(Type3 t3){ // Handle exceptions of type3 } 当发生异常事时（监控区域抛出异常），Java异常处理机制将负责搜寻catch中与异常类型相匹配的第一个处理程序，进入这个catch块，也就是说只有匹配的catch字句才能执行，即便是下面还有匹配的类型（为什么下面还会存在匹配的类型，因为类继承原因，下面还存在父类的异常），也不会执行，具有唯一匹配性。Java的这种异常捕获、处理的模式，可以很好的将正常的代码和出现问题时处理的代码分开，而不是混在一起。 ### finally 有一些代码，无论try中是否抛出异常，它们都能得到执行，这就是`finally字句`的作用。 try { // Code that might generate exceptions } catch(Type1 t1){ // Handle exceptions of type1 } catch(Type2 t2){ // Handle exceptions of type2 } catch(Type3 t3){ // Handle exceptions of type3 } finally { } 无论放生了什么，finally字句始终都会执行，即便是你在try或catch中加入了continue、break或者return。 #### finally用来做什么 Java中主要通过finally把资源恢复到它们的初始状态，如：已打开的文件或网络链接等，总言之，就是与外界“世界”的某个开关。这里有一个原则，就是在产生了一个必须被清理的对象之后，立即进入一个try-finally语句块，为什么会是在之后而不是把这个对象初始化也放进这个try中呢，因为finally总会执行，就会导致可能去做了释放没有被初始化的对象，这样会出现不良的代码结构。 ### 终止模式 Java对于异常的处理采取的是`终止模式`，一旦发生问题，程序将不能继续执行，与之对应的是`恢复模式`，就是当异常抛出时，程序能够继续执行，而不是终止。在Java中如果我们要使用恢复模式，就需要将try块放在while循环中，直到满意，但这明显是不靠谱的，也是我们不提倡的。所以当当前方法终止时，我们只能在异常处理块中使程序向不同的方向继续执行，而具体向什么方向，取决于具体的实现。 ## 异常说明 `异常说明`属于方法说明的一部分，紧跟在参数列表之后： void method() throws IOException{ //………… } 如果某个方法有了异常说明，我们在使用的时候就必须捕获它，即使可能该方法根本不可能真实的抛出过该异常。当然，必须捕获的情况还要除去RuntimeException类型的异常（它的所有子类），因为他是不检查异常，即便是我们加了RuntimeException类型的异常说明，也是可以不去捕获的，所以我们加RuntimeException类型的异常说明是多此一举的（特别是对于不能看到方法源码的情况下）。 ### 继承中的方法说明限制 在继承了某个类时，如果父类中某个方法（public或者protected）有异常说明，子类在覆盖方法时，异常说明只能是父类的一样的异常说明或者无异常说明，不能添加父类方法没有的异常说明。还有一个特殊情况，一个类的父类方法和接口方法同名，而且都添加了异常说明： class A { void a() throws XPathException { } } interface B { void a() throws DataFormatException; } class AB extends A implements B { @Override public void a() {} // public void a() throws XPathException {} 不能编译 } 这种情况该方法不能添加任何异常说明。 ## 异常类型 Java中已存在许多定义好的异常类型供我们使用，可通过查看[Java文档](http://tool.oschina.net/apidocs/apidoc?api=jdk_7u4)查看，我们可以自己定义异常类，就必须从现有的异常类继承。那我们先来看看Throwable类相关的方法。 ### 方法汇总 直到Java1.7，Throwable提供了4个公开的(public)和1个自身和子类可以访问（protected）的构造方法： // 构造方法 // public Throwable() Throwable(String message) Throwable(Throwable cause) Throwable(String message, Throwable cause) // protected Throwable(String message, Throwable cause, boolean enableSuppression, boolean writableStackTrace) addSuppressed(Throwable exception) fillInStackTrace() getCause() getLocalizedMessage() getMessage() getStackTrace() getSuppressed() initCause(Throwable cause) printStackTrace() printStackTrace(PrintStream s) printStackTrace(PrintWriter s) setStackTrace(StackTraceElement[] stackTrace) toString() 接下来通过一些例子来看看部分方法的使用： ### 方法使用例子 public class Test { public static void main(String[] args) { try { throw new Exception("My Exception"); } catch (Exception ex) { System.out.println("getMessage(): " + ex.getMessage()); System.out.println("getLocalizedMessage(): " + ex.getLocalizedMessage()); System.out.println("toString(): " + ex.toString()); System.out.println("printStackTrace(): "); ex.printStackTrace(System.out); } } }/* Output: getMessage(): My Exception getLocalizedMessage(): My Exception toString(): java.lang.Exception: My Exception printStackTrace(): java.lang.Exception: My Exception at com.exercise.Test.main(Test.java:13) *///:~ 在不改写getLocalizedMessage()方法时，getLocalizedMessage()和getMessage()获取的都是使用了带有参数的构造方法传入的信息，如上列为“My Exception”。toString()方法包含了getMessage()方法的信息，printStackTrace()方法则包含了toString()方法的内容，printStackTrace()方法打印的的是此异常调用栈的轨迹，显示了把你带到异常抛出点的方法调用序列，可以根据类名和行号具体定位。接下里我们结详细介绍一下printStackTrace()打印的栈轨迹。 ### 栈轨迹 printStackTrace()提供的信息可以通过getStackTrace()方法获取到更详细的内容，该方法将返回一个数组，由栈轨迹元素(StackTraceElement)构成，每个元素表示栈中的一桢，元素0是栈顶元素，是方法调用序列中最后一个方法调用，也就是在这个方法中创建或抛出了异常。数组中最后一个元素（栈底）是调用序列中的第一个方法调用。如下： public class Test { static void methodOne() { try { throw new Exception(); } catch (Exception e) { for (StackTraceElement stackTraceElement : e.getStackTrace()) { System.out.println(stackTraceElement.getMethodName()); } } } static void methodTwo() { methodOne(); } static void methodThree() { methodTwo(); } public static void main(String[] args) { methodOne(); System.out.println("------------分割线------------"); methodTwo(); System.out.println("------------分割线------------"); methodThree(); } }/* Output: methodOne main ------------分割线------------ methodOne methodTwo main ------------分割线------------ methodOne methodTwo methodThree main *///:~ 此例只打印了方法名，还可以通过StackTraceElement答应更多的信息。其他方法不会专门为了介绍它而介绍，注意下面的内容，会不断地提到其他的方法。 ## 重新抛出异常和异常链 有时我们在捕获到异常后，可能在捕获的地方不适合处理该异常，我们需要将它重新抛出： catch(Exception e){ throw e; } 这样有一个好处，我们可以将异常交给上一级环境处理，但是这样就会存在一个问题，抛出的的异常携带的信息，也就是printStackTrace()方法显示的是原来异常抛出点的调用栈信息，而非重新抛出点的信息，这样重新抛出点的调用信息就被掩盖了。如果想更新重新抛出点信息到这个异常调用栈中，就可以使用fillInStackTrace()方法： catch(Exception e){ throw e.fillInStackTrace(); } 那么当前调用栈的信息就更新到了这个异常对象中了，还有一种情况，也会存在类似的丢失现象： catch(Exception e){ throw new Exception(); } 这样我们上一级的抛出的异常信息就丢了，接收异常的地方就是只能得到`new Exception()`这个异常的信息。在JDK1.4以前如果你希望保存丢失的那个异常信息，只能通过编码的方式自己实现，而在JDK1.4后，Throwable类有一个构造方法接收一个Throwable类型的参数（文章上方`方法汇总`可以查看该构造方法）。那么这个传入的参数称为`cause`，它用来表示原始异常，那么就可以通过异常链从新的异常追踪到异常最初发生的位置。除了构造方法，我们还可以通过initCause(Throwable cause)方法传入一个Throwable对象，它的作用和构造函数传入一个Throwable对象是一样的。大家还记得之前介绍过finally字句吗？，它其实也会造成异常丢失： class VeryImportantException extends Exception { @Override public String toString() { return "A very important exception!"; } } class OtherException extends Exception { @Override public String toString() { return "Other exception"; } } public class Test { void f() throws VeryImportantException { throw new VeryImportantException(); } void dispose() throws OtherException { throw new OtherException(); } public static void main(String[] args) { try { Test test = new Test(); try { test.f(); } finally { test.dispose(); } } catch (Exception e) { System.out.println(e); } } }/* Output: Other exception *///:~ 我们把最外一层try看着是上一级程序的处理，在这个try里面发生了两次异常，但是我们只能获得从finally中抛出的异常信息，而在f()方法中的异常信息丢失，这种情况我们称上一个`异常被抑制了`。这在JDK1.7之前同样需要我们自己编码去解决这个问题，在JDK1.7之后，新加入了两个方法帮助我们能够很好的去解决这个问题了，那就是addSuppressed(Throwable exception)和getSuppressed()，对于上述问题的解决： class VeryImportantException extends Exception { @Override public String toString() { return "A very important exception!"; } } class OtherException extends Exception { @Override public String toString() { return "Other exception"; } } public class Test { void f() throws VeryImportantException { throw new VeryImportantException(); } void dispose() throws OtherException { throw new OtherException(); } public static void main(String[] args) { try { Test test = new Test(); Exception exception = null; try { test.f(); } catch (VeryImportantException e) { exception = e; } finally { try { test.dispose(); } catch (OtherException e) { if (exception != null) { exception.addSuppressed(e); } else { exception = e; } } if (exception != null) { throw exception; } } } catch (Exception e) { System.out.println(e); for (Throwable throwable : e.getSuppressed()) { System.out.println(throwable); } } } }/* Output: A very important exception! Other exception *///:~ ## Throwable JDK1.7新特性补充 ### 同时捕获多个异常 try { Integer.parseInt("Hello"); } catch (NumberFormatException | RuntimeException e) { } 这种情况不能将RuntimeException放在首位，编译不能通过。 ### try-with-resources 之前我们释放资源的需通过finally，但在JDK1.7后，可以使用try-with-resources方式，它可以实现自动释放功能，而不需要加上finally子句。需要做的就是将需要释放的资源对象放在try语句： public String read(String filename) throws IOException { try (BufferedReader reader = new BufferedReader(new FileReader(filename))) { StringBuilder builder = new StringBuilder(); String line = null; while((line=reader.readLine())!=null){ builder.append(line); builder.append(String.format("%n")); } return builder.toString(); } } 并且可以放入多个需要释放的资源： public void copyFile(String fromPath, String toPath) throws IOException { try (InputStream input = new FileInputStream(fromPath); OutputStream output = new FileOutputStream(toPath)) { byte[] buffer = new byte[8192]; int len = -1; while ((len = input.read(buffer)) != -1) { output.write(buffer, 0, len); } } } 关于Java的异常就介绍到这里，希望大家能支持，你的支持是我继续前进的不断动力！]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[泰国曼谷、苏梅岛8日游]]></title>
      <url>%2F2016%2F06%2F07%2F%E6%B3%B0%E5%9B%BD%E6%9B%BC%E8%B0%B7%E3%80%81%E8%8B%8F%E6%A2%85%E5%B2%9B8%E6%97%A5%E6%B8%B8%2F</url>
      <content type="text"><![CDATA[行程时间安排 时间 地点 安排 03-28 成都东-永川 与老友小聚 03-29 永川 茶山竹海半日游 03-29 永川-重庆江北机场 搭乘到曼谷飞机 03-29 曼谷 入住Tara Place 03-30 曼谷 曼谷一日游（大皇宫、四面佛） 03-30 曼谷-南园岛 搭乘Lomprayah公司车船联运前往南园岛 03-31 南园岛 到达入住南园岛、潜泳 04-01 南园岛-苏梅岛 入住Code Hotel 04-02 苏梅岛 环岛 04-03 苏梅岛 换酒店入住Rajapruek Samui Resort 04-04 苏梅岛-曼谷 搭乘亚航联运前往曼谷，入住Asias Boutique Club /The homestays 04-05 曼谷-重庆江北机场 购买动车票回成都 04-05 重庆-成都 回到成都 为什么又是苏梅岛这是第二次去苏梅岛了，很多朋友知道了都问为什么又去泰国？！又是苏梅岛？！首先选择去泰国是因为机票很便宜，往返1098元/人。第一次去泰国时单身汪一枚，也是我第一次出国旅游，有了女朋友后，不想让她错过我去过的地方。虽然和女朋友也已经去过一些地方，但是这种长时间、出国的度假还是第一次，而且是自由行，所以选择了比较熟悉的苏梅岛。 详细行程三月二十九日一高中好哥们在永川定居了，也是借这次要去重庆路过永川的机会，小聚了一下，他带我们去了《十面埋伏》的拍摄地茶山竹海。 十面埋伏 竹海中午下山吃完饭，坐车前往江北机场，从永川到重庆江北机场留了2个小时，但是差点误了飞机~ 18:50准时起飞 3个小时后准时到达曼谷 入住的酒店 选择这个酒店的主要原因是因为离考山路比较近，因为第二天要在考山路坐车船联运去南苑岛，然后这个酒店的评价还不错。入住后，整个酒店很干净，然后前台有24小时中文服务，进门左手有一个小桌子，上面有一些小吃、饮料和咖啡，小吃的味道还是很不错的。如果在考山路一带活动，这个酒店是很不错的选择。 三月三十日Lomprayah是在晚上，所以今天安排了曼谷一日游，选择了大皇宫和四面佛，起床后退了房，把行李寄存到酒店（免费），然后坐头天晚上在酒店预定好的免费突突车去大皇宫了。 然后故事开始了，本来打算在大皇宫周围先转转，没一会遇到一个很热情的大叔，很有激情的给我们介绍着，大概意思是说现在大皇宫还没开门，建议我们先去坐船，然后帮我们叫了一个突突车，很便宜，20泰铢就把我们送到了河边，坐船是1200泰铢一个人，当时想了一会，到底坐不坐呢？最后还是决定坐一次，但是到了船上以后，想想就发现有点不太对劲，有点怀疑刚才那个大叔，心里就有点不太美丽了~ 下了船，就前往大皇宫了，里面人山人海，而且大多数都是中国旅行团，本来是打算买票进大皇宫参观的，但是还在刚才被坑的坏心情当中，所以买了个冰棍坐了一会就走了，打车前往四面佛。 到了四面佛，开始买香火拜佛，又一件不太开心的事情发生了，被外面的小贩坑惨了，拜完佛以后，小哥还硬要了300泰铢的小费，在结合介绍坐船的大叔那件事，此刻的我对泰国的印象从第一次来后的好评变成了差评，不过这个印象在我离开泰国的最后一天又被刷新了，后面会介绍。也在这提醒大家，去四面佛拜佛时，千万不要在外面购买香火，那怕你已经把价格讲到最低了！直接进去，在里面购买，价格是最合理的。拜完佛差不多也就快天黑了，然后打了个的回酒店，然后在Tripadvisor上选择了酒店附近排名第一的、在整个泰国排名第64位的纯素泰国餐馆：May Kaidee Samsen - Vegetarian Restaurant 然后随便逛了逛，就回到酒店了，因为退了房，所以就在酒店大厅里的沙发上休息，蹭着免费的WiFi，还下了几集《欢乐喜剧人》，晚上坐夜车的时候打发时间，酒店落地窗上有很多小壁虎 时间差不多了，拿上行李准备前往考山路坐长途汽车了，这次去苏梅岛选择的是坐Lomprayah的车船联运（比较便宜），然后从苏梅岛回来是坐亚航的飞机，不过也要坐船加大巴到机场，只是时间比较Lomprayah的要少一点，至于Lomprayah如何订票和安排，推荐看看这篇攻略写得比较详细。夜班车开始，这个大巴大概要从晚上9点到第二天早上6、7点左右，是从曼谷到春蓬的一个码头 三月三十一日早上天还没亮就到了，要在码头上等天亮再上船出发，这就是到了海边了，天没亮时可以听听海浪声，早上还可以看日出，大概早上9点左右，开始检票上船 上船以后就没什么可讲的了，因为女朋友晕船了，这也是我这次旅程中没有考虑好的一点，以后再也不选择这种船了，晕到开始吐，但我不知道她是什么时候还在船尾拍了一张 船要到达是南苑岛，南苑岛是苏梅岛一个附属小岛屿，是被一个日本人买了的，在泰国，这个岛就永久属于这个日本人了，这个岛很小很小，但是上岛有限制，如果你没在上面预定住宿，就要给上岛费，而且不能携带垃圾上岛，如果要在上面住，需要提前预定，相对于住宿的环境和配备：小贵，可以在某宝上搜索，也可以进他们的官网预定，推荐某宝，因为官网有很多房型，不知道怎么选择，某宝上可以咨询着预定，而且价格好像还便宜一点 酒店是独栋的，在小山上，山上有很多树。所以蚊子很多，备好驱蚊液，南苑岛水很清，可以自己潜浮，潜浮可以看到各种鱼，因为是私人岛，和住的一样，吃的也没有选择，味道一般。白天潜浮了一会就回房间睡觉了,这个时间段海里的珊瑚特别多，特别硌脚，不像上次11月份来的时候，整个沙滩都是很柔软的。一直到天黑，下去吃了点饭，拿了两瓶啤酒，在沙滩的躺椅上聊聊人生 四月一日早上起床以后就准备前往此次的最终目的地苏梅岛，方式也是坐船，女朋友又要开始晕船了，船票也是和之前的票在Lomprayah上预定的 到了以后，买了他们的接送服务，上岸以后直接送到你的酒店，酒店是之前已经订好了的，两天，名字叫Code Hotal，位置一般，不过酒店整体还是不错的，完全可以整天待在里面，好好度假休息，下面前三张张是酒店主页上的，后面是自己拍的 四月二日到了酒店后就开始休息了，晚上下去711买了点东西，在附近吃了点东西，有点远，最好找酒店借辆自行车，是免费的，然后就一直待在酒店到第二天。酒店是免早的，早餐很丰富，待在酒店一直到下午，酒店提供摩托租赁服务，一天好像是60RMB（24小时），然后租了一辆摩托车开始环岛，太阳非常毒，所以一定记得涂上防晒霜。本来打算去祖父石、祖母石那个景点看看，但是用导航走了很远都没有找到，最后就在附近的沙滩上转了转 中午去苏梅岛上一个在国内排行评价第一的大排档吃海鲜-米特拉苏梅大排档 （Mitra Samui Restaurant），味道还行，服务也还可以，价格也不贵，喜欢吃海鲜但是又不想太奢侈的可以考虑，而且这里来的大部分都是中国人，还能用支付宝支付，店里的服务员也会中文 环岛结束以后，回酒店休息了一下，又在Tripadvisor找了一家排名第一的餐厅，是吃欧洲菜的，因为不是自己的口味，所以就不评价味道了，但是老板娘很热情，给我们不断地翻译介绍 四月三日这一晚后我们会换一个酒店，是在这个岛上最后一个酒店，这个酒店离我们离开这个岛的码头非常近，只有5公里，挨着海滩，但是环境一般，吃的也一般，而且酒店人很少，有点阴冷的感觉 四月四日第二天回曼谷，先坐船，再汽车到机场，飞机再到曼谷，到了曼谷都大概中午了，天气很热，这家酒店在网上的评分很高很高，入住以后，的确，如果不是因为这个酒店，我们就会丢失我们的手机再也找不回，怎么回事呢？下面慢慢说，这家酒店的名字叫亚细亚精品俱乐部/民宿住宿加早餐旅馆 Asias Boutique Club /The homestays，离机场很近，强烈推荐！ 酒店能收到所有的国内频道，没错，是所有的。在酒店吃了点东西，然后就准备去市区购物，还记得之前说过四面佛的遭遇吗？我们打车又经过了四面佛，然后我心里还是很不爽，就说了一句：我下车去收拾一下他们。然后我女朋友就说，你不要在佛面前说这种话，果然，悲剧的事情发生了，下出租车时，手机掉在车上了，刚走进商场就发现了，因为我女朋友手机是电信的，在泰国不能使用，就找了一个中国同胞，借了一个手机，电话是通的，但是没人接听，还抱有一丝希望，然后想起酒店在临走时给了我们一个地图卡片，上面有酒店的位置和电话，是为了方便我们打车回去，再来苹果手机有一个丢失模式，然后我就用我女朋友的手机上了网，登录到查找我的iPhone，辛亏我的手机3G一直是打开的，在上面留了一条信息，电话是酒店的 过了一会，给酒店打电话，酒店说那个司机已经给酒店回了电话了，还是很激动，这个过程中，因为一直开着丢失模式，所以能够知道手机的定位，出租车司机是一个老人家，年龄66了，在这个过程当中一直还在城里跑，其实心里还是相信，他会把手机送回酒店。当时在市区草率的买了一点小东西，就又打车回酒店了，然后酒店的人说他会把手机送回来，只是可能会晚一点，我们一直都没回房间，在酒店的大厅里等着，一直等到晚上11点多，老人家把我们的手机送回来了，我们之前就想好了，过来往返费用还有一些小费，总共给老人家1000泰铢，但是老人家最后死活只收了500，这个时候，泰国给我的印象又好了，最后仔细想一想，其实不管在哪里，都有一部分人会因为生活而做一些不该做的事情，我们在旅游时，需要理智，平心而论，泰国整个国家的人的素质都是非常好的，他们的交通、他们每个人的朴实，整体上是超过国人的 四月五日手机找回来了，但是就没有购物了，回国后女朋友也说了很久，不过的确是因为我的一些小问题导致的，以后一定要做好所有准备，精确到小时，不然真的会出很多问题，还有旅游的一些坑都需要提前了解和时刻的理智，期待下一次旅行吧！回国……]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[编辑距离及算法实现]]></title>
      <url>%2F2016%2F03%2F08%2F%E7%BC%96%E8%BE%91%E8%B7%9D%E7%A6%BB%E5%8F%8A%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0%2F</url>
      <content type="text"><![CDATA[简要各位一定体验到过搜索引擎的纠错功能，当你在无意识的情况下将你搜索的内容输入错误时，搜索引擎会自动帮你纠错。如你本来想搜索happy，却不小心按到了y旁边的u，这时我们依然达到了我们想要的目的 那么这个是怎么实现的呢，先不考虑这个功能整体使用到的技术，先解决一个问题，它是怎么知道从happu到happy的，这就是我们今天要讲的编辑距离 概念编辑距离（Edit Distance）又称Levenshtein距离，是指两个字串之间，由一个转成另一个所需的最少编辑操作次数。许可的编辑操作包括将一个字符替换成另一个字符，插入一个字符，删除一个字符。一般来说，编辑距离越小，两个串的相似度越大。 从happu到happy只是把u替换成了y，操作次数为一次，所以编辑距离为1 运用因此，有了这个概念，当我们知道一个词是错误的时候（怎么知道它错了，后面讨论），就只需从正确的词中找出和它编辑距离最小的一个或多个，就可以帮助用户纠错了 如何计算编辑距离比如要计算cafe到coffee的编辑距离 先创建一个6x8的表（cafe长度为4，coffee长度为6，各加2）,先在表中如下位置填入相应数字 0 0 c o f f e e 0 0 1 2 3 4 5 6 c 1 o 2 f 3 e 4 再从c到c对应的表格，也就是表格的（3，3）位置开始，按照以下规则填充数字 如果最上方的字符等于最左方的字符，则为左上方的数字。否则为左上方的数字+1。（对于3,3来说为0） 左方数字+1（对于3,3格来说为2） 上方数字+1（对于3,3格来说为2） 取上面得出的三个数字中最小数字填入（3，3）位置，根据上面得出的，最小为0，所以在（3，3）位置填入0，以此类推，完成所有空格的填充，如下 0 0 c o f f e e 0 0 1 2 3 4 5 6 c 1 0 1 2 3 4 5 o 2 1 1 2 3 4 5 f 3 2 2 1 2 3 4 e 4 3 3 2 2 2 3 取得表中右下角数字，既为cafe和coffee的最小编辑距离，为3 Java代码 public static double ld(String s, String t) { int d[][]; int sLen = s.length(); int tLen = t.length(); int si; int ti; char ch1; char ch2; int cost; if(sLen == 0) { return tLen; } if(tLen == 0) { return sLen; } d = new int[sLen+1][tLen+1]; for(si=0; si&lt;=sLen; si++) { d[si][0] = si; } for(ti=0; ti&lt;=tLen; ti++) { d[0][ti] = ti; } for(si=1; si&lt;=sLen; si++) { ch1 = s.charAt(si-1); for(ti=1; ti&lt;=tLen; ti++) { ch2 = t.charAt(ti-1); if(ch1 == ch2) { cost = 0; } else { cost = 1; } d[si][ti] = Math.min(Math.min(d[si-1][ti]+1, d[si][ti-1]+1),d[si-1][ti-1]+cost); } } return 1 - (double) d[sLen][tLen] / Math.max(src.length(), tar.length()); }]]></content>
    </entry>

    
    <entry>
      <title><![CDATA[搭建Hexo静态博客]]></title>
      <url>%2F2016%2F03%2F07%2F%E6%90%AD%E5%BB%BAHexo%E9%9D%99%E6%80%81%E5%8D%9A%E5%AE%A2%2F</url>
      <content type="text"><![CDATA[概述开源项目Hexo是由Node.js完成，所有源码位于GitHib上，可以使用它搭建自己的静态博客网页。很重要的一点，该框架可以使用轻量级标记语言Markdown编辑文章，可参考Markdown入门资料 环境搭建(OS X)Node.js访问Node.js官网下载对应版本并安装 Hexo$ npm install hexo -g –no-optional –svaeHexo 3.0以后直接使用此命令，不然使用命令时可能会产生一些警告，-g是表示全局安装，--no-optional为了防止刚才提到的一些警告。 Git安装Xcode后会默认安装git，如还未安装git，可自行搜索安装，这里就不再赘述。 初始化Hexo进入你想存放文件的目录，如我是在/Document/hexo/blog下，命令进入到相应目录下，执行： 1 $ hexo init2 $ npm install启动本地服务器 $ hexo s浏览器打开http://localhost:4000，至此本地的静态网页博客已经搭建成功，那么如何让其他人也能够访问到呢，我们需要将他部署到GitHub上 部署到GitHub前提申请GitHub社区账号，并新建新的Repository，注意Repository的名字一定要遵守用户名.github.io，如图是我的 配置在本地的静态博客根目录下，找到_config.yml文件，找到deploy关键字，根据自己新建的Repository修改为如以下配置 deploy: type: git repo: git@github.com:Jucongyuan/Jucongyuan.github.io.git branch: master部署到GitHub，在博客根目录下执行以下命令 1 $ hexo clean2 $ hexo generate3 $ hexo deploy 注意事项由于采用的SSH，所以需要在本地生成SSH Key，可参照GitHub官网 访问你的http://用户名.github.io，至此完成整个搭建过程 Hexo可以配置不同的主题，如本博客采用的是国内的一个主题NexT，在该主题上可以在博客中增加其他如分享、搜索、评论等其他第三方功能和自定义样式主题，更多请访问NexT]]></content>
    </entry>

    
  
  
</search>
